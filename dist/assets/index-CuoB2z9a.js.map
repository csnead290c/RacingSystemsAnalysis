{"version":3,"file":"index-CuoB2z9a.js","sources":["../src/domain/config/raceLengths.ts","../src/domain/core/weather.ts","../src/worker/pipeline.ts","../src/domain/physics/core/units.ts","../src/domain/physics/engine/engine.ts","../src/domain/physics/vb6/exactMath.ts","../src/domain/physics/drivetrain/drivetrain.ts","../src/domain/physics/core/integrator.ts","../src/domain/physics/vb6/constants.ts","../src/domain/physics/vb6/bootstrap.ts","../src/domain/physics/vb6/air.ts","../src/domain/physics/vb6/forces.ts","../src/domain/physics/vb6/driveline.ts","../src/domain/physics/vb6/traction.ts","../src/domain/physics/vb6/pmi.ts","../src/domain/physics/vb6/tire.ts","../src/domain/physics/vb6/shift.ts","../src/domain/physics/vb6/tireslip.ts","../src/domain/physics/vb6/weight_transfer.ts","../src/domain/physics/vb6/integrator.ts","../src/domain/physics/models/rsaclassic.ts","../src/domain/physics/vb6/vb6SimulationStep.ts","../src/domain/physics/vb6/dtaby.ts","../src/domain/physics/vb6/calcWork.ts","../src/domain/physics/vb6/engineCurve.ts","../src/domain/physics/vb6/quarterJr.ts","../src/domain/physics/models/vb6Exact.ts","../src/state/models.ts","../src/domain/learning/model.ts","../src/domain/physics/models/blend.ts","../src/domain/physics/index.ts","../src/worker/index.ts"],"sourcesContent":["/**\n * Race distance configurations\n * \n * Drag Racing:\n * - EIGHTH: 1/8 mile (660 ft)\n * - QUARTER: 1/4 mile (1320 ft)\n * \n * Land Speed Racing (Bonneville/El Mirage):\n * - ONE_MILE: One mile course (5280 ft)\n * - EL_MIRAGE: El Mirage dry lake (1.3 miles, 6864 ft)\n * - MUROC: Muroc dry lake / Edwards AFB (1.5 miles, 7920 ft)\n * - TWO_MILE: Two mile course (10560 ft)\n * - BONNEVILLE_SHORT: Bonneville 3 mile course (15840 ft)\n * - BONNEVILLE_LONG: Bonneville 5 mile course (26400 ft)\n * - TEN_MILE: Ten mile test track (52800 ft)\n */\nexport const DISTANCES = {\n  // Drag racing\n  EIGHTH: [60, 330, 660] as const,\n  THOUSAND: [60, 330, 660, 1000] as const,\n  QUARTER: [60, 330, 660, 1000, 1320] as const,\n  \n  // Land speed racing - checkpoints at 1/4 mile intervals + terminal\n  ONE_MILE: [660, 1320, 2640, 3960, 5280] as const,\n  EL_MIRAGE: [660, 1320, 2640, 3960, 5280, 6864] as const,\n  MUROC: [660, 1320, 2640, 3960, 5280, 6600, 7920] as const,\n  TWO_MILE: [660, 1320, 2640, 5280, 7920, 10560] as const,\n  BONNEVILLE_SHORT: [660, 1320, 2640, 5280, 10560, 15840] as const,\n  BONNEVILLE_LONG: [660, 1320, 2640, 5280, 10560, 15840, 21120, 26400] as const,\n  TEN_MILE: [660, 1320, 2640, 5280, 10560, 26400, 52800] as const,\n};\n\nexport type RaceLength = keyof typeof DISTANCES;\n\n/**\n * Race length metadata for UI display\n */\nexport const RACE_LENGTH_INFO: Record<RaceLength, { \n  label: string; \n  shortLabel: string;\n  category: 'drag' | 'landspeed';\n  lengthFt: number;\n  lengthMiles: number;\n}> = {\n  EIGHTH: { \n    label: '1/8 Mile', \n    shortLabel: '1/8',\n    category: 'drag',\n    lengthFt: 660,\n    lengthMiles: 0.125,\n  },\n  THOUSAND: { \n    label: '1000 Foot', \n    shortLabel: '1000\\'',\n    category: 'drag',\n    lengthFt: 1000,\n    lengthMiles: 0.189,\n  },\n  QUARTER: { \n    label: '1/4 Mile', \n    shortLabel: '1/4',\n    category: 'drag',\n    lengthFt: 1320,\n    lengthMiles: 0.25,\n  },\n  ONE_MILE: { \n    label: 'One Mile Asphalt', \n    shortLabel: '1 Mi',\n    category: 'landspeed',\n    lengthFt: 5280,\n    lengthMiles: 1,\n  },\n  EL_MIRAGE: { \n    label: 'El Mirage Dry Lake', \n    shortLabel: 'El Mirage',\n    category: 'landspeed',\n    lengthFt: 6864,\n    lengthMiles: 1.3,\n  },\n  MUROC: { \n    label: 'Muroc Dry Lake (EAFB)', \n    shortLabel: 'Muroc',\n    category: 'landspeed',\n    lengthFt: 7920,\n    lengthMiles: 1.5,\n  },\n  TWO_MILE: { \n    label: 'Two Mile Asphalt', \n    shortLabel: '2 Mi',\n    category: 'landspeed',\n    lengthFt: 10560,\n    lengthMiles: 2,\n  },\n  BONNEVILLE_SHORT: { \n    label: 'Bonneville - 3 Miles', \n    shortLabel: 'BV 3Mi',\n    category: 'landspeed',\n    lengthFt: 15840,\n    lengthMiles: 3,\n  },\n  BONNEVILLE_LONG: { \n    label: 'Bonneville - 5 Miles', \n    shortLabel: 'BV 5Mi',\n    category: 'landspeed',\n    lengthFt: 26400,\n    lengthMiles: 5,\n  },\n  TEN_MILE: { \n    label: 'Ten Mile Test Track', \n    shortLabel: '10 Mi',\n    category: 'landspeed',\n    lengthFt: 52800,\n    lengthMiles: 10,\n  },\n};\n\n/**\n * Get traction index range for a track type\n * From VB6 BVPro Traction.frm\n */\nexport function getTractionIndexForTrack(raceLength: RaceLength): { typical: number; range: [number, number] } {\n  switch (raceLength) {\n    case 'EIGHTH':\n    case 'QUARTER':\n      return { typical: 1, range: [1, 5] };  // Best asphalt to best salt\n    case 'ONE_MILE':\n    case 'TWO_MILE':\n    case 'TEN_MILE':\n      return { typical: 3, range: [1, 6] };  // Typical street to slick asphalt\n    case 'EL_MIRAGE':\n      return { typical: 10, range: [8, 13] }; // Good dry lake to loose dry lake\n    case 'MUROC':\n      return { typical: 10, range: [8, 13] }; // Good dry lake to loose dry lake\n    case 'BONNEVILLE_SHORT':\n    case 'BONNEVILLE_LONG':\n      return { typical: 8, range: [5, 11] };  // Best salt to loose salt\n    default:\n      return { typical: 3, range: [1, 15] };\n  }\n}\n","/**\n * Weather and atmospheric calculations for racing performance.\n * All formulas use imperial units and are deterministic approximations.\n */\n\nimport type { Env } from '../schemas/env.schema';\n\n/**\n * Calculate density altitude in feet.\n * \n * Density altitude represents the altitude at which the air density would be\n * equal to the current conditions in standard atmosphere. Higher density altitude\n * means thinner air and reduced engine performance.\n * \n * Formula uses standard atmospheric approximations:\n * 1. Pressure altitude from barometer reading\n * 2. Temperature correction for non-standard conditions\n * \n * Standard conditions: 29.92 inHg, 59°F (15°C) at sea level\n * \n * @param env - Environment conditions\n * @returns Density altitude in feet (can be negative at low elevations with cold, high pressure)\n */\nexport function densityAltitudeFt(env: Env): number {\n  // Standard sea level pressure in inHg\n  const stdPressure = 29.92;\n  \n  // Pressure altitude: altitude correction for non-standard pressure\n  // ~1000 ft per 1 inHg difference from standard\n  const pressureAlt = env.elevation + (stdPressure - env.barometerInHg) * 1000;\n  \n  // Standard temperature at pressure altitude (°F)\n  // Standard lapse rate: ~3.5°F per 1000 ft\n  const stdTemp = 59 - (pressureAlt / 1000) * 3.5;\n  \n  // Temperature correction: ~120 ft per 1°F difference\n  // Higher temp = higher density altitude (thinner air)\n  const tempCorrection = (env.temperatureF - stdTemp) * 120;\n  \n  // Humidity correction (simplified): higher humidity = slightly higher DA\n  // Water vapor is less dense than dry air\n  // Approximate: +50 ft per 10% humidity at 80°F\n  const humidityCorrection = (env.humidityPct / 10) * 50 * (env.temperatureF / 80);\n  \n  return pressureAlt + tempCorrection + humidityCorrection;\n}\n\n/**\n * Calculate grains of water vapor per pound of dry air.\n * \n * This represents the absolute humidity in the air. One grain = 1/7000 pound.\n * Higher values indicate more moisture, which affects air density and combustion.\n * \n * Uses simplified psychrometric approximation for racing conditions.\n * Typical range: 20-200 grains/lb for racing conditions.\n * \n * @param env - Environment conditions\n * @returns Grains of water per pound of dry air\n */\nexport function grainsOfWater(env: Env): number {\n  // Saturation vapor pressure approximation (Tetens formula simplified)\n  // Units: inHg\n  const satVaporPressure = 0.0061 * Math.exp((17.27 * (env.temperatureF - 32) / 1.8) / \n                                              (237.3 + (env.temperatureF - 32) / 1.8));\n  \n  // Actual vapor pressure from relative humidity\n  const vaporPressure = satVaporPressure * (env.humidityPct / 100);\n  \n  // Grains of water per pound of dry air\n  // Formula: 7000 * 0.622 * (e / (P - e))\n  // where e = vapor pressure, P = total pressure\n  const grains = 7000 * 0.622 * (vaporPressure / (env.barometerInHg - vaporPressure));\n  \n  // Ensure finite result\n  return Math.max(0, Math.min(grains, 500)); // Cap at reasonable maximum\n}\n\n/**\n * Calculate horsepower correction factor for atmospheric conditions.\n * \n * Returns a multiplier for engine power based on air density.\n * - 1.0 = standard conditions (sea level, 59°F, 29.92 inHg, 0% humidity)\n * - >1.0 = more power (denser air)\n * - <1.0 = less power (thinner air)\n * \n * This is a simplified correction factor. More sophisticated models would\n * account for forced induction, fuel type, and engine-specific characteristics.\n * \n * Typical range: 0.85-1.05 for most racing conditions\n * \n * @param env - Environment conditions\n * @returns Power correction multiplier (dimensionless)\n */\nexport function hpCorrectionV1(env: Env): number {\n  // Standard conditions\n  const stdPressure = 29.92; // inHg\n  const stdTemp = 59; // °F\n  const stdTempRankine = stdTemp + 459.67; // Convert to absolute temperature\n  \n  // Current conditions in absolute temperature\n  const currentTempRankine = env.temperatureF + 459.67;\n  \n  // Air density ratio approximation\n  // ρ/ρ₀ = (P/P₀) * (T₀/T)\n  const pressureRatio = env.barometerInHg / stdPressure;\n  const tempRatio = stdTempRankine / currentTempRankine;\n  \n  // Base correction from pressure and temperature\n  let correction = pressureRatio * tempRatio;\n  \n  // Humidity correction: water vapor reduces air density slightly\n  // Approximate: -1% power per 50 grains of water\n  const grains = grainsOfWater(env);\n  const humidityFactor = 1 - (grains / 5000);\n  \n  correction *= humidityFactor;\n  \n  // Clamp to reasonable range to avoid extreme values\n  return Math.max(0.7, Math.min(correction, 1.15));\n}\n","/**\n * Baseline quarter-mile prediction pipeline.\n * Pure mathematical calculations with no side effects.\n */\n\nimport { DISTANCES } from '../domain/config/raceLengths';\nimport { hpCorrectionV1 } from '../domain/core/weather';\nimport type { PredictRequest, PredictResult } from '../domain/quarter/types';\n\n/**\n * Predict baseline quarter-mile performance.\n * \n * Uses cube-root power laws:\n * - Quarter-mile: ET ≈ 5.825 * cbrt(weight/HP), MPH ≈ 234 * cbrt(HP/weight)\n * - Eighth-mile: ET ≈ ETq * 0.64, MPH ≈ MPHq * 0.80\n * - Weather correction applied as small ET delta\n * \n * Timeslip is built by allocating time fractions to standard splits:\n * - 60ft: 16% of total ET\n * - 330ft: 44% of total ET\n * - 660ft: 79% of total ET (half-track)\n * - 1000ft: 93% of total ET\n * - Finish: 100% of total ET\n * \n * Only splits present in DISTANCES[raceLength] are included.\n * \n * @param req - Prediction request with vehicle, environment, and race length\n * @returns Prediction result with ET, MPH, timeslip, and correction factors\n */\nexport function predictBaseline(req: PredictRequest): PredictResult {\n  const { vehicle, env, raceLength } = req;\n\n  // Safety guards\n  if (vehicle.weightLb <= 0 || vehicle.powerHP <= 0) {\n    throw new Error('Invalid vehicle params');\n  }\n\n  // Get distances for this race length from SSOT\n  const distances = DISTANCES[raceLength];\n  if (!distances) {\n    throw new Error(`Invalid race length: ${raceLength}`);\n  }\n\n  // Apply weather correction to HP first\n  const corr = hpCorrectionV1(env); // >1 = more power\n  const effectiveHP = vehicle.powerHP * corr;\n  \n  // Quarter-mile baseline using cube-root power laws\n  const safeHP = Math.max(1, effectiveHP);\n  const safeWeight = Math.max(1, vehicle.weightLb);\n  \n  const ETq = 5.825 * Math.cbrt(safeWeight / safeHP);\n  const MPHq = 234 * Math.cbrt(safeHP / safeWeight);\n\n  // Eighth-mile conversion (rules of thumb)\n  const ETe = ETq * 0.64;\n  const MPHe = MPHq * 0.80;\n\n  // Select baseline based on race length\n  let baseET_s: number;\n  let baseMPH: number;\n\n  if (raceLength === 'EIGHTH') {\n    baseET_s = ETe;\n    baseMPH = MPHe;\n  } else {\n    baseET_s = ETq;\n    baseMPH = MPHq;\n  }\n\n  // Safety checks\n  if (!Number.isFinite(baseET_s) || !Number.isFinite(baseMPH)) {\n    throw new Error('Invalid ET or MPH calculation');\n  }\n\n  // Calculate weather impact for reporting\n  const baseETnoWeather = 5.825 * Math.cbrt(safeWeight / Math.max(1, vehicle.powerHP));\n  const weatherDelta_s = baseET_s - baseETnoWeather;\n\n  // Build timeslip using standard split fractions\n  // Only include distances that exist in DISTANCES[raceLength]\n  const splitFractions: Record<number, number> = {\n    60: 0.16,\n    330: 0.44,\n    660: 0.79,\n    1000: 0.93,\n    1320: 1.0,\n  };\n\n  const timeslip = distances.map((d_ft) => {\n    const fraction = splitFractions[d_ft] ?? 1.0;\n    const t_s = baseET_s * fraction;\n\n    // Calculate speed at this point - simple increasing ramp to baseMPH\n    // Ensure monotonicity by using distance-based progression\n    const distanceFraction = d_ft / distances[distances.length - 1];\n    const v_mph = baseMPH * distanceFraction;\n\n    return {\n      d_ft,\n      t_s: Math.max(0, t_s), // Ensure non-negative\n      v_mph: Math.max(0, v_mph), // Ensure non-negative\n    };\n  });\n\n  // Correction factors applied\n  const factors = [\n    {\n      name: 'Weather (HP)',\n      delta_s: weatherDelta_s,\n    },\n  ];\n\n  return {\n    baseET_s: Math.max(0, baseET_s),\n    baseMPH: Math.max(0, baseMPH),\n    timeslip,\n    factors,\n  };\n}\n","/**\n * Unit conversion utilities for RSACLASSIC physics engine.\n */\n\n/**\n * Conversion factor: mph per fps (VB6: Z5 = 3600 / 5280)\n */\nexport const MPH_PER_FPS = 3600 / 5280; // 0.681818...\n\n/**\n * Conversion factor: fps per mph\n */\nexport const FPS_PER_MPH = 5280 / 3600; // 1.466667...\n\n/**\n * Convert feet per second to miles per hour.\n */\nexport function fpsToMph(fps: number): number {\n  return fps * MPH_PER_FPS;\n}\n\n/**\n * Convert miles per hour to feet per second.\n */\nexport function mphToFps(mph: number): number {\n  return mph * FPS_PER_MPH;\n}\n\n/**\n * Convert RPM to radians per second.\n */\nexport function rpmToRadS(rpm: number): number {\n  return rpm * (2 * Math.PI / 60);\n}\n\n/**\n * Convert radians per second to RPM.\n */\nexport function radSToRpm(radS: number): number {\n  return radS * (60 / (2 * Math.PI));\n}\n\n/**\n * Convert pounds (force) to slugs (mass).\n * Uses standard gravity: 32.174 ft/s²\n */\nexport function lbToSlug(lb: number): number {\n  return lb / 32.174;\n}\n\n/**\n * Convert slugs (mass) to pounds (force).\n * Uses standard gravity: 32.174 ft/s²\n */\nexport function slugToLb(slug: number): number {\n  return slug * 32.174;\n}\n\n/**\n * Convert inches of mercury to pounds per square inch.\n */\nexport function inHgToPsi(inHg: number): number {\n  return inHg * 0.491154;\n}\n\n/**\n * Convert pounds per square inch to inches of mercury.\n */\nexport function psiToInHg(psi: number): number {\n  return psi / 0.491154;\n}\n\n/**\n * Clamp a value between min and max.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * Linear interpolation between a and b.\n * @param a - Start value\n * @param b - End value\n * @param t - Interpolation factor (0 to 1)\n */\nexport function lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t;\n}\n\n/**\n * Safe cube root that preserves sign.\n * Math.cbrt handles negative numbers correctly, but this is explicit.\n */\nexport function cbrtSafe(n: number): number {\n  if (n >= 0) {\n    return Math.cbrt(n);\n  } else {\n    return -Math.cbrt(-n);\n  }\n}\n\n/**\n * Standard gravity in ft/s²\n */\nexport const GRAVITY_FT_S2 = 32.174;\n\n/**\n * Air density at sea level, standard conditions (slugs/ft³)\n */\nexport const AIR_DENSITY_SEA_LEVEL = 0.002377;\n","/**\n * Engine torque model for RSACLASSIC physics engine.\n * Supports optional torque curves or fallback from power rating.\n */\n\nimport { lerp } from '../core/units';\nimport type { PowerPt } from './types';\n\n/**\n * Engine parameters for torque calculation.\n */\nexport interface EngineParams {\n  /**\n   * Optional torque curve (RPM vs torque in lb-ft).\n   * If provided, torque is interpolated from this curve.\n   * If not provided, torque is calculated from powerHP.\n   * Rows may have hp or tq_lbft (or both).\n   */\n  torqueCurve?: { rpm: number; hp?: number; tq_lbft?: number }[];\n  \n  /**\n   * Power rating in horsepower (used if no torque curve).\n   */\n  powerHP?: number;\n  \n  /**\n   * Correction factor (e.g., from weather/air density).\n   * Applied to torque: tq_corrected = tq_base * corr\n   */\n  corr: number;\n}\n\n/**\n * Ensure we have valid PowerPt array from various input formats.\n */\nfunction ensurePowerPts(src: any): PowerPt[] {\n  const hp =\n    (Array.isArray(src) ? src : src?.powerHP) ??\n    src?.engineParams?.powerHP; // last-ditch tolerance\n\n  if (!Array.isArray(hp) || hp.length < 2) {\n    const keys = src && typeof src === 'object' ? Object.keys(src) : [];\n    throw new Error(\n      `EngineParams must provide either torqueCurve or powerHP (got keys=${JSON.stringify(keys)}, len=${hp?.length ?? 0})`\n    );\n  }\n  return hp;\n}\n\n/**\n * Get power (HP) at RPM from power points.\n * Accepts either PowerPt[] directly or { powerHP: PowerPt[] }.\n */\nexport function power_hp_atRPM(rpm: number, src: PowerPt[] | { powerHP: PowerPt[] }): number {\n  const pts = ensurePowerPts(src);\n  // Simple linear interpolation\n  if (rpm <= pts[0].rpm) return pts[0].hp;\n  if (rpm >= pts[pts.length - 1].rpm) return pts[pts.length - 1].hp;\n  let lo = 0, hi = pts.length - 1;\n  while (hi - lo > 1) {\n    const mid = (lo + hi) >> 1;\n    if (pts[mid].rpm <= rpm) lo = mid; else hi = mid;\n  }\n  const a = pts[lo], b = pts[hi];\n  const t = (rpm - a.rpm) / (b.rpm - a.rpm);\n  return a.hp + t * (b.hp - a.hp);\n}\n\n/**\n * Calculate wheel torque from power points.\n * Accepts either PowerPt[] directly or { powerHP: PowerPt[] }.\n * \n * @param rpm - Engine RPM\n * @param src - Power points array or object containing powerHP\n * @param gearEff - Gear efficiency multiplier\n * @returns Torque in lb-ft\n */\nexport function wheelTorque_lbft(\n  rpm: number,\n  src: PowerPt[] | { powerHP: PowerPt[] } | EngineParams,\n  gearEff: number\n): number {\n  // Check if this is the old EngineParams format\n  if ('corr' in src && typeof src.corr === 'number') {\n    // Legacy path: use old logic\n    const p = src as EngineParams;\n    let baseTorque: number;\n    \n    if (p.torqueCurve && p.torqueCurve.length > 0) {\n      // Use torque curve\n      baseTorque = interpolateTorqueCurve(rpm, p.torqueCurve);\n    } else if (p.powerHP !== undefined) {\n      // Fallback: calculate from power\n      // tq = (HP * 5252) / rpm\n      // Guard against low RPM to avoid unrealistic torque\n      const safeRpm = Math.max(rpm, 1000);\n      baseTorque = (p.powerHP * 5252) / safeRpm;\n    } else {\n      throw new Error('EngineParams must provide either torqueCurve or powerHP');\n    }\n    \n    // Apply correction factor (e.g., air density)\n    const correctedTorque = baseTorque * p.corr;\n    return correctedTorque;\n  }\n  \n  // New path: use power points directly\n  const hp = power_hp_atRPM(rpm, src as PowerPt[] | { powerHP: PowerPt[] });\n  // 5252 * HP / RPM = lb-ft (guard RPM)\n  const tq = rpm > 0 ? (5252 * hp) / rpm : 0;\n  return tq * (Number.isFinite(gearEff) ? gearEff : 1);\n}\n\n/**\n * Interpolate torque from torque curve at given RPM.\n * Uses linear interpolation between curve points.\n * Clamps to curve bounds if RPM is outside range.\n * Handles curves with hp or tq_lbft fields.\n * \n * @param rpm - Engine RPM\n * @param curve - Torque curve points (may have hp or tq_lbft)\n * @returns Interpolated torque in lb-ft\n */\nfunction interpolateTorqueCurve(\n  rpm: number,\n  curve: { rpm: number; hp?: number; tq_lbft?: number }[]\n): number {\n  // Convert curve to tq_lbft if needed\n  const tqCurve = curve.map((p) => {\n    if (p.tq_lbft !== undefined) {\n      return { rpm: p.rpm, tq_lbft: p.tq_lbft };\n    } else if (p.hp !== undefined && p.rpm > 0) {\n      return { rpm: p.rpm, tq_lbft: (p.hp * 5252) / p.rpm };\n    } else {\n      throw new Error(`Invalid torque curve point: ${JSON.stringify(p)}`);\n    }\n  });\n  \n  // Sort curve by RPM (in case not sorted)\n  const sorted = [...tqCurve].sort((a, b) => a.rpm - b.rpm);\n  \n  // Clamp to curve bounds\n  if (rpm <= sorted[0].rpm) {\n    return sorted[0].tq_lbft;\n  }\n  if (rpm >= sorted[sorted.length - 1].rpm) {\n    return sorted[sorted.length - 1].tq_lbft;\n  }\n  \n  // Find surrounding points\n  for (let i = 0; i < sorted.length - 1; i++) {\n    const p1 = sorted[i];\n    const p2 = sorted[i + 1];\n    \n    if (rpm >= p1.rpm && rpm <= p2.rpm) {\n      // Linear interpolation\n      const t = (rpm - p1.rpm) / (p2.rpm - p1.rpm);\n      return lerp(p1.tq_lbft, p2.tq_lbft, t);\n    }\n  }\n  \n  // Should never reach here, but return last point as fallback\n  return sorted[sorted.length - 1].tq_lbft;\n}\n\n/**\n * Calculate peak power from torque curve.\n * \n * @param curve - Torque curve points\n * @returns Peak power in HP and RPM where it occurs\n */\nexport function peakPowerFromCurve(\n  curve: { rpm: number; tq_lbft: number }[]\n): { hp: number; rpm: number } {\n  let maxHP = 0;\n  let maxRPM = 0;\n  \n  for (const point of curve) {\n    // HP = (torque * rpm) / 5252\n    const hp = (point.tq_lbft * point.rpm) / 5252;\n    if (hp > maxHP) {\n      maxHP = hp;\n      maxRPM = point.rpm;\n    }\n  }\n  \n  return { hp: maxHP, rpm: maxRPM };\n}\n\n/**\n * Calculate peak torque from torque curve.\n * \n * @param curve - Torque curve points\n * @returns Peak torque in lb-ft and RPM where it occurs\n */\nexport function peakTorqueFromCurve(\n  curve: { rpm: number; tq_lbft: number }[]\n): { tq_lbft: number; rpm: number } {\n  let maxTQ = 0;\n  let maxRPM = 0;\n  \n  for (const point of curve) {\n    if (point.tq_lbft > maxTQ) {\n      maxTQ = point.tq_lbft;\n      maxRPM = point.rpm;\n    }\n  }\n  \n  return { tq_lbft: maxTQ, rpm: maxRPM };\n}\n","/**\r\n * VB6 Exact Math Helpers\r\n * \r\n * Enforce VB6-like Single (Float32) precision and banker's rounding.\r\n * Use these for bit-for-bit parity with VB6 Quarter Pro calculations.\r\n * \r\n * VB6 used Single precision (32-bit float) for most calculations.\r\n * JavaScript uses 64-bit doubles, so we must explicitly truncate to Float32\r\n * after each operation to match VB6's intermediate results.\r\n */\r\n\r\n/**\r\n * Convert a number to Float32 (VB6 Single precision).\r\n */\r\nexport const f32 = (x: number): number => Math.fround(x);\r\n\r\n/**\r\n * Float32 arithmetic operations.\r\n * Each operation converts inputs to f32 and returns f32 result.\r\n * This preserves VB6's associativity and precision behavior.\r\n */\r\nexport const F = {\r\n  /** Add two numbers in Float32 */\r\n  add: (a: number, b: number): number => Math.fround(Math.fround(a) + Math.fround(b)),\r\n  \r\n  /** Subtract two numbers in Float32 */\r\n  sub: (a: number, b: number): number => Math.fround(Math.fround(a) - Math.fround(b)),\r\n  \r\n  /** Multiply two numbers in Float32 */\r\n  mul: (a: number, b: number): number => Math.fround(Math.fround(a) * Math.fround(b)),\r\n  \r\n  /** Divide two numbers in Float32 */\r\n  div: (a: number, b: number): number => Math.fround(Math.fround(a) / Math.fround(b)),\r\n  \r\n  /** Square root in Float32 */\r\n  sqrt: (x: number): number => Math.fround(Math.sqrt(Math.fround(x))),\r\n  \r\n  /** Power in Float32 */\r\n  pow: (x: number, y: number): number => Math.fround(Math.pow(Math.fround(x), Math.fround(y))),\r\n  \r\n  /** Exponential in Float32 */\r\n  exp: (x: number): number => Math.fround(Math.exp(Math.fround(x))),\r\n  \r\n  /** Natural log in Float32 */\r\n  log: (x: number): number => Math.fround(Math.log(Math.fround(x))),\r\n  \r\n  /** Clamp in Float32 */\r\n  clamp: (x: number, lo: number, hi: number): number => \r\n    Math.fround(Math.min(Math.max(Math.fround(x), Math.fround(lo)), Math.fround(hi))),\r\n  \r\n  /** Absolute value in Float32 */\r\n  abs: (x: number): number => Math.fround(Math.abs(Math.fround(x))),\r\n  \r\n  /** Negate in Float32 */\r\n  neg: (x: number): number => Math.fround(-Math.fround(x)),\r\n};\r\n\r\n/**\r\n * Banker's rounding (half-to-even) like VB/VBA Round function.\r\n * VB6's Round() uses this rule: when exactly at .5, round to nearest even.\r\n * \r\n * Examples:\r\n *   vb6Round(2.5, 0) = 2  (rounds to even)\r\n *   vb6Round(3.5, 0) = 4  (rounds to even)\r\n *   vb6Round(2.4, 0) = 2\r\n *   vb6Round(2.6, 0) = 3\r\n */\r\nexport function vb6Round(x: number, places = 0): number {\r\n  const p = Math.pow(10, places);\r\n  const v = Math.fround(x * p);\r\n  const f = Math.floor(v);\r\n  const frac = v - f;\r\n  \r\n  if (frac > 0.5) return (f + 1) / p;\r\n  if (frac < 0.5) return f / p;\r\n  \r\n  // Exactly 0.5: round to even\r\n  return (f % 2 === 0 ? f : f + 1) / p;\r\n}\r\n\r\n/**\r\n * VB6 Int() function - truncates toward negative infinity.\r\n * Different from JavaScript's Math.floor() for negative numbers.\r\n */\r\nexport function vb6Int(x: number): number {\r\n  return Math.floor(Math.fround(x));\r\n}\r\n\r\n/**\r\n * VB6 Fix() function - truncates toward zero.\r\n * Same as JavaScript's Math.trunc().\r\n */\r\nexport function vb6Fix(x: number): number {\r\n  return Math.trunc(Math.fround(x));\r\n}\r\n\r\n// ============================================================================\r\n// VB6 Constants - EXACT values from Quarter Pro source\r\n// ============================================================================\r\n\r\n/** Gravitational constant: lbm*ft/(lbf*s^2) - exact VB6 value */\r\nexport const GC = Math.fround(32.174048556);\r\n\r\n/** Standard gravity: ft/s^2 */\r\nexport const G_FTPS2 = Math.fround(32.174);\r\n\r\n/** Conversion: 1 inHg to psf (pounds per square foot) */\r\nexport const INHG_TO_PSF = Math.fround(70.7262);\r\n\r\n/** Conversion: 1 inHg to psi */\r\nexport const INHG_TO_PSI = Math.fround(0.491154);\r\n\r\n/** Standard atmospheric pressure at sea level: inHg */\r\nexport const STD_BARO_INHG = Math.fround(29.921);\r\n\r\n/** Standard temperature at sea level: °F */\r\nexport const STD_TEMP_F = Math.fround(59.0);\r\n\r\n/** Rankine offset from Fahrenheit */\r\nexport const RANKINE_OFFSET = Math.fround(459.67);\r\n\r\n/** Specific gas constant for dry air: ft*lbf/(lbm*°R) */\r\nexport const R_DRY_AIR = Math.fround(53.35);\r\n\r\n/** Specific gas constant for water vapor: ft*lbf/(lbm*°R) */\r\nexport const R_WATER_VAPOR = Math.fround(85.78);\r\n\r\n/** Molecular weight ratio: water/air */\r\nexport const MW_RATIO_WATER_AIR = Math.fround(0.62198);\r\n\r\n/** Pi in Float32 */\r\nexport const PI_F32 = Math.fround(Math.PI);\r\n\r\n/** Feet per mile */\r\nexport const FT_PER_MILE = Math.fround(5280);\r\n\r\n/** Seconds per hour */\r\nexport const SEC_PER_HOUR = Math.fround(3600);\r\n\r\n// ============================================================================\r\n// VB6 Unit Conversions\r\n// ============================================================================\r\n\r\n/** Convert feet per second to miles per hour (Float32) */\r\nexport function fpsToMph(fps: number): number {\r\n  // mph = fps * 3600 / 5280 = fps * 0.681818...\r\n  return F.div(F.mul(f32(fps), SEC_PER_HOUR), FT_PER_MILE);\r\n}\r\n\r\n/** Convert miles per hour to feet per second (Float32) */\r\nexport function mphToFps(mph: number): number {\r\n  // fps = mph * 5280 / 3600\r\n  return F.div(F.mul(f32(mph), FT_PER_MILE), SEC_PER_HOUR);\r\n}\r\n\r\n/** Convert Fahrenheit to Rankine (Float32) */\r\nexport function fToR(tempF: number): number {\r\n  return F.add(f32(tempF), RANKINE_OFFSET);\r\n}\r\n\r\n/** Convert inches to feet (Float32) */\r\nexport function inToFt(inches: number): number {\r\n  return F.div(f32(inches), f32(12));\r\n}\r\n\r\n/** Convert feet to inches (Float32) */\r\nexport function ftToIn(feet: number): number {\r\n  return F.mul(f32(feet), f32(12));\r\n}\r\n\r\n// ============================================================================\r\n// VB6 Interpolation\r\n// ============================================================================\r\n\r\n/**\r\n * Linear interpolation in Float32, matching VB6's piecewise linear behavior.\r\n * \r\n * @param x - Input value\r\n * @param x0 - Lower bound x\r\n * @param x1 - Upper bound x\r\n * @param y0 - Value at x0\r\n * @param y1 - Value at x1\r\n * @returns Interpolated value in Float32\r\n */\r\nexport function lerpF32(x: number, x0: number, x1: number, y0: number, y1: number): number {\r\n  const xf = f32(x);\r\n  const x0f = f32(x0);\r\n  const x1f = f32(x1);\r\n  const y0f = f32(y0);\r\n  const y1f = f32(y1);\r\n  \r\n  // Avoid division by zero\r\n  if (x1f === x0f) return y0f;\r\n  \r\n  // t = (x - x0) / (x1 - x0)\r\n  const t = F.div(F.sub(xf, x0f), F.sub(x1f, x0f));\r\n  \r\n  // y = y0 + t * (y1 - y0)\r\n  return F.add(y0f, F.mul(t, F.sub(y1f, y0f)));\r\n}\r\n\r\n/**\r\n * Table lookup with linear interpolation in Float32.\r\n * Matches VB6's typical dyno curve interpolation.\r\n * \r\n * @param x - Input value (e.g., RPM)\r\n * @param table - Array of [x, y] pairs, sorted by x ascending\r\n * @returns Interpolated y value in Float32\r\n */\r\nexport function tableLookupF32(x: number, table: [number, number][]): number {\r\n  if (table.length === 0) return f32(0);\r\n  if (table.length === 1) return f32(table[0][1]);\r\n  \r\n  const xf = f32(x);\r\n  \r\n  // Clamp to table bounds (VB6 behavior)\r\n  if (xf <= f32(table[0][0])) return f32(table[0][1]);\r\n  if (xf >= f32(table[table.length - 1][0])) return f32(table[table.length - 1][1]);\r\n  \r\n  // Find bracketing points\r\n  for (let i = 0; i < table.length - 1; i++) {\r\n    const x0 = f32(table[i][0]);\r\n    const x1 = f32(table[i + 1][0]);\r\n    \r\n    if (xf >= x0 && xf <= x1) {\r\n      return lerpF32(xf, x0, x1, table[i][1], table[i + 1][1]);\r\n    }\r\n  }\r\n  \r\n  // Fallback (should not reach here)\r\n  return f32(table[table.length - 1][1]);\r\n}\r\n","/**\n * Drivetrain model for RSACLASSIC physics engine.\n * Handles gear ratios, final drive, and force/RPM calculations.\n */\n\nimport { F, f32 } from '../vb6/exactMath';\n\n/**\n * Tolerant accessor for gear ratios.\n * Accepts both `ratios` (Drivetrain interface) and `gearRatios` (VB6 format).\n * Returns empty array if neither is present.\n * \n * @param d - Drivetrain-like object with ratios or gearRatios\n * @returns Array of gear ratios (never undefined)\n */\nexport function getGearRatios(d: any): number[] {\n  if (Array.isArray(d?.ratios) && d.ratios.length > 0) {\n    return d.ratios;\n  }\n  if (Array.isArray(d?.gearRatios) && d.gearRatios.length > 0) {\n    return d.gearRatios;\n  }\n  return [];\n}\n\n/**\n * Drivetrain configuration.\n */\nexport interface Drivetrain {\n  /**\n   * Gear ratios (1st gear, 2nd gear, etc.)\n   * Higher ratio = more torque multiplication, lower top speed\n   */\n  ratios: number[];\n  \n  /**\n   * Final drive ratio (rear gear)\n   */\n  finalDrive: number;\n  \n  /**\n   * Transmission efficiency (0 to 1)\n   * Typical: 0.85-0.95\n   */\n  transEff: number;\n  \n  /**\n   * Tire diameter in inches\n   */\n  tireDiaIn: number;\n  \n  /**\n   * Upshift RPM thresholds per gear\n   * Length should match ratios.length\n   */\n  shiftRPM: number[];\n}\n\n/**\n * Calculate engine RPM from vehicle speed.\n * \n * Formula:\n * rpm = (v_fps / (π * tire_dia_ft)) * 60 * gear_ratio * final_drive * (1 + slip)\n * \n * Where:\n * - v_fps / (π * tire_dia_ft) = wheel rotations per second\n * - * 60 = wheel rotations per minute\n * - * gear_ratio * final_drive = engine rotations per wheel rotation\n * - * (1 + slip) = slip factor (0 = no slip, >0 = wheel slip)\n * \n * @param v_fps - Vehicle speed in feet per second\n * @param gearIdx - Current gear index (0-based)\n * @param d - Drivetrain configuration\n * @param slip - Tire slip factor (0 = no slip, 0.1 = 10% slip)\n * @returns Engine RPM\n */\nexport function rpmFromSpeed(\n  v_fps: number,\n  gearIdx: number,\n  d: Drivetrain | any,\n  slip = 0\n): number {\n  // Convert tire diameter to feet\n  const tireDia_ft = (d.tireDiaIn ?? 28) / 12;\n  \n  // Wheel circumference in feet\n  const wheelCirc_ft = Math.PI * tireDia_ft;\n  \n  // Wheel rotations per second\n  const wheelRPS = v_fps / wheelCirc_ft;\n  \n  // Wheel rotations per minute\n  const wheelRPM = wheelRPS * 60;\n  \n  // Get gear ratios using tolerant accessor\n  const ratios = getGearRatios(d);\n  const gearRatio = ratios.length > 0 \n    ? (ratios[Math.min(gearIdx, ratios.length - 1)] ?? 1.0)\n    : 1.0;\n  \n  // Engine RPM accounting for gear ratio, final drive, and slip\n  const rpm = wheelRPM * gearRatio * (d.finalDrive ?? 3.73) * (1 + slip);\n  \n  return rpm;\n}\n\n/**\n * Calculate wheel force from engine torque.\n * \n * Formula:\n * F = (tq * gear_ratio * final_drive * trans_eff) / tire_radius_ft\n * \n * Where:\n * - tq * gear_ratio * final_drive = torque at wheels (before losses)\n * - * trans_eff = torque at wheels (after transmission losses)\n * - / tire_radius_ft = force at contact patch\n * \n * @param tq_lbft - Engine torque in lb-ft\n * @param gearIdx - Current gear index (0-based)\n * @param d - Drivetrain configuration\n * @returns Wheel force in pounds\n */\nexport function wheelForce_lb(\n  tq_lbft: number,\n  gearIdx: number,\n  d: Drivetrain | any\n): number {\n  // Convert tire diameter to radius in feet\n  const tireRadius_ft = ((d.tireDiaIn ?? 28) / 12) / 2;\n  \n  // Get gear ratios using tolerant accessor\n  const ratios = getGearRatios(d);\n  const gearRatio = ratios.length > 0 \n    ? (ratios[Math.min(gearIdx, ratios.length - 1)] ?? 1.0)\n    : 1.0;\n  \n  // Torque at wheels (after gear multiplication and transmission losses)\n  const wheelTorque_lbft = tq_lbft * gearRatio * (d.finalDrive ?? 3.73) * (d.transEff ?? 0.9);\n  \n  // Force at contact patch: F = torque / radius\n  const force_lb = wheelTorque_lbft / tireRadius_ft;\n  \n  return force_lb;\n}\n\n/**\n * Calculate vehicle speed from engine RPM.\n * Inverse of rpmFromSpeed.\n * \n * @param rpm - Engine RPM\n * @param gearIdx - Current gear index (0-based)\n * @param d - Drivetrain configuration\n * @param slip - Tire slip factor\n * @returns Vehicle speed in feet per second\n */\nexport function speedFromRPM(\n  rpm: number,\n  gearIdx: number,\n  d: Drivetrain | any,\n  slip = 0\n): number {\n  // Get gear ratios using tolerant accessor\n  const ratios = getGearRatios(d);\n  const gearRatio = ratios.length > 0 \n    ? (ratios[Math.min(gearIdx, ratios.length - 1)] ?? 1.0)\n    : 1.0;\n  \n  // Wheel RPM\n  const wheelRPM = rpm / (gearRatio * (d.finalDrive ?? 3.73) * (1 + slip));\n  \n  // Wheel rotations per second\n  const wheelRPS = wheelRPM / 60;\n  \n  // Tire diameter in feet\n  const tireDia_ft = (d.tireDiaIn ?? 28) / 12;\n  \n  // Wheel circumference\n  const wheelCirc_ft = Math.PI * tireDia_ft;\n  \n  // Vehicle speed\n  const v_fps = wheelRPS * wheelCirc_ft;\n  \n  return v_fps;\n}\n\n// ============================================================================\n// VB6-STRICT Float32 versions\n// ============================================================================\n\n/**\n * VB6-STRICT: Calculate engine RPM from vehicle speed using Float32.\n * Matches VB6's exact calculation order and precision.\n */\nexport function rpmFromSpeed_f32(\n  v_fps: number,\n  gearIdx: number,\n  d: Drivetrain | any,\n  slip = 0\n): number {\n  const tireDia_ft = F.div(f32(d.tireDiaIn ?? 28), f32(12));\n  const wheelCirc_ft = F.mul(f32(Math.PI), tireDia_ft);\n  const wheelRPS = F.div(f32(v_fps), wheelCirc_ft);\n  const wheelRPM = F.mul(wheelRPS, f32(60));\n  \n  const ratios = getGearRatios(d);\n  const gearRatio = f32(ratios.length > 0 \n    ? (ratios[Math.min(gearIdx, ratios.length - 1)] ?? 1.0)\n    : 1.0);\n  \n  const finalDrive = f32(d.finalDrive ?? 3.73);\n  const slipFactor = F.add(f32(1), f32(slip));\n  \n  // rpm = wheelRPM * gearRatio * finalDrive * (1 + slip)\n  return F.mul(F.mul(F.mul(wheelRPM, gearRatio), finalDrive), slipFactor);\n}\n\n/**\n * VB6-STRICT: Calculate wheel force from engine torque using Float32.\n * VB6 order: torque * torqueMultEff * gearRatio * finalDrive * perGearEff * overallEff / tireRadius\n * \n * @param tq_lbft - Engine torque in lb-ft\n * @param gearIdx - Current gear index (0-based)\n * @param d - Drivetrain configuration\n * @param perGearEff - Per-gear efficiency array\n * @param overallEff - Overall driveline efficiency\n * @param torqueMultEff - Converter torque multiplication (Work factor), 1.0 for clutch\n */\nexport function wheelForce_f32(\n  tq_lbft: number,\n  gearIdx: number,\n  d: Drivetrain | any,\n  perGearEff?: number[],\n  overallEff?: number,\n  torqueMultEff?: number  // STRICT converter torque ratio (Work factor)\n): number {\n  const tireRadius_ft = F.div(F.div(f32(d.tireDiaIn ?? 28), f32(12)), f32(2));\n  \n  const ratios = getGearRatios(d);\n  const gearRatio = f32(ratios.length > 0 \n    ? (ratios[Math.min(gearIdx, ratios.length - 1)] ?? 1.0)\n    : 1.0);\n  \n  const finalDrive = f32(d.finalDrive ?? 3.73);\n  \n  // Apply converter torque multiplication FIRST (before gearing)\n  // This is the key fix: converter Work boosts torque at trans input\n  const T_boosted = f32(tq_lbft * (torqueMultEff ?? 1.0));\n  \n  // VB6 order: T * gearRatio * finalDrive first\n  let T_wheel = F.mul(F.mul(T_boosted, gearRatio), finalDrive);\n  \n  // Then apply per-gear efficiency\n  const gearEff = f32(perGearEff?.[gearIdx] ?? d.transEff ?? 0.97);\n  T_wheel = F.mul(T_wheel, gearEff);\n  \n  // Then apply overall efficiency\n  const eff = f32(overallEff ?? d.transEff ?? 0.97);\n  T_wheel = F.mul(T_wheel, eff);\n  \n  // Force = torque / radius\n  return F.div(T_wheel, tireRadius_ft);\n}\n","/**\n * Fixed timestep integrator for RSACLASSIC physics engine.\n * Uses semi-implicit Euler method for stability.\n */\n\n/**\n * State of the vehicle at a given timestep.\n */\nexport interface StepState {\n  /** Time in seconds */\n  t_s: number;\n  \n  /** Velocity in feet per second */\n  v_fps: number;\n  \n  /** Position/distance in feet */\n  s_ft: number;\n  \n  /** Engine RPM */\n  rpm: number;\n  \n  /** Current gear index (0-based) */\n  gearIdx: number;\n  \n  /** Accumulated warnings */\n  warnings: string[];\n}\n\n/**\n * Forces acting on the vehicle at a given timestep.\n */\nexport interface StepForces {\n  /** Tractive force at wheels (lb) */\n  tractive_lb: number;\n  \n  /** Aerodynamic drag force (lb) */\n  drag_lb: number;\n  \n  /** Rolling resistance force (lb) */\n  roll_lb: number;\n  \n  /** Vehicle mass (slugs) */\n  mass_slugs: number;\n}\n\n/**\n * Perform one integration step using semi-implicit Euler method.\n * \n * Semi-implicit Euler (symplectic Euler):\n * 1. Update velocity: v(t+dt) = v(t) + a(t) * dt\n * 2. Update position: s(t+dt) = s(t) + v(t+dt) * dt\n * \n * This method is more stable than explicit Euler for physical simulations.\n * \n * @param dt_s - Timestep in seconds\n * @param st - Current state\n * @param F - Forces acting on vehicle\n * @returns New state after timestep\n */\nexport function stepEuler(\n  dt_s: number,\n  st: StepState,\n  F: StepForces\n): StepState {\n  // Calculate net force: F_net = F_tractive - F_drag - F_roll\n  const netForce_lb = F.tractive_lb - F.drag_lb - F.roll_lb;\n  \n  // Calculate acceleration: a = F / m\n  // Using slugs for mass, so acceleration is in ft/s²\n  const acceleration_fps2 = netForce_lb / F.mass_slugs;\n  \n  // Semi-implicit Euler: update velocity first\n  const v_new_fps = st.v_fps + acceleration_fps2 * dt_s;\n  \n  // Then update position using new velocity\n  const s_new_ft = st.s_ft + v_new_fps * dt_s;\n  \n  // Time advances\n  const t_new_s = st.t_s + dt_s;\n  \n  // Copy warnings (will be updated by caller if needed)\n  const warnings = [...st.warnings];\n  \n  // Return new state\n  // Note: rpm and gearIdx are not updated here - they're managed by drivetrain logic\n  return {\n    t_s: t_new_s,\n    v_fps: v_new_fps,\n    s_ft: s_new_ft,\n    rpm: st.rpm,\n    gearIdx: st.gearIdx,\n    warnings,\n  };\n}\n\n/**\n * Create initial state for integration.\n */\nexport function createInitialState(): StepState {\n  return {\n    t_s: 0,\n    v_fps: 0,\n    s_ft: 0,\n    rpm: 0,\n    gearIdx: 0,\n    warnings: [],\n  };\n}\n","/**\n * VB6-ported constants (do not change).\n * \n * These constants are extracted from the VB6 codebase to ensure\n * identical physics calculations. Source file and line numbers are noted.\n */\n\n// ===== DECLARES.BAS =====\n\n/** PI constant - DECLARES.BAS:10 */\nexport const PI = 3.141593;\n\n/** Gravitational acceleration (ft/s²) - DECLARES.BAS:11 */\nexport const gc = 32.174;\n\n/** Z6 constant: (60 / (2 * PI)) * 550 - DECLARES.BAS:12 */\nexport const Z6 = (60 / (2 * PI)) * 550;\n\n// ===== QTRPERF.BAS Weather() =====\n\n/** Standard temperature (°R) - QTRPERF.BAS:1291 */\nexport const TSTD = 519.67;\n\n/** Standard pressure (psi) - QTRPERF.BAS:1292 */\nexport const PSTD = 14.696;\n\n/** Standard barometer (inHg) - QTRPERF.BAS:1293 */\nexport const BSTD = 29.92;\n\n/** Molecular weight of air - QTRPERF.BAS:1294 */\nexport const WTAIR = 28.9669;\n\n/** Molecular weight of water - QTRPERF.BAS:1295 */\nexport const WTH20 = 18.016;\n\n/** Universal gas constant - QTRPERF.BAS:1296 */\nexport const RSTD = 1545.32;\n\n// ===== TIMESLIP.FRM Constants =====\n\n/** Z5 constant: 3600 / 5280 (hours/mile to seconds/foot) - TIMESLIP.FRM:542 */\nexport const Z5 = 3600 / 5280;\n\n/** CMU: Rolling resistance coefficient for Quarter Jr/Pro - TIMESLIP.FRM:552 */\nexport const CMU = 0.025;\n\n/** CMUK: Distance-dependent CMU reduction for Quarter Jr/Pro - TIMESLIP.FRM:553 */\nexport const CMUK = 0.01;\n\n// ===== Bonneville Pro Constants (ISBVPRO) - TIMESLIP.FRM:560-569 =====\n\n/** CMU_BV: Rolling resistance coefficient for Bonneville Pro - TIMESLIP.FRM:562 */\nexport const CMU_BV = 0.03;\n\n/** CMUK_BV: Distance-dependent CMU reduction for Bonneville Pro (none) - TIMESLIP.FRM:563 */\nexport const CMUK_BV = 0;\n\n/** AX_BV: Traction coefficient multiplier for Bonneville Pro - TIMESLIP.FRM:561 */\nexport const AX_BV = 9.7;\n\n/** FRCT_BV: Driveline friction coefficient for Bonneville Pro - TIMESLIP.FRM:569 */\nexport const FRCT_BV = 1.01;\n\n/** KP21_BV: Engine PMI deceleration factor for Bonneville Pro (none) - TIMESLIP.FRM:567 */\nexport const KP21_BV = 0;\n\n/** KP22_BV: Engine PMI deceleration factor for Bonneville Pro (none) - TIMESLIP.FRM:568 */\nexport const KP22_BV = 0;\n\n/** KV_BV: Velocity tolerance for Bonneville Pro - TIMESLIP.FRM:565 */\nexport const KV_BV = 0.05 / Z5;\n\n/** K7_BV: Steps per time print increment for Bonneville Pro - TIMESLIP.FRM:566 */\nexport const K7_BV = 5.5;\n\n/** Time tolerance (seconds) - TIMESLIP.FRM:554 */\nexport const TimeTol = 0.002;\n\n/** KV constant - TIMESLIP.FRM:555 */\nexport const KV = 0.02 / Z5;\n\n/** K7 constant (steps per time print increment) - TIMESLIP.FRM:556 */\nexport const K7 = 9.5;\n\n/** AMin: Minimum acceleration (ft/s²) - TIMESLIP.FRM:547-548 */\n// Reduced from 0.05 to 0.004 for Quarter Jr/Pro to implement Buell rev limit option\n// Note: was 0.004 for BVPro already\nexport const AMin = 0.004;\n\n/** JMin: Minimum jerk (g/s) - TIMESLIP.FRM:543 */\nexport const JMin = -4;\n\n/** JMax: Maximum jerk (g/s) - TIMESLIP.FRM:544 */\nexport const JMax = 2;\n\n/** K6: HP ratio lower bound for time interpolation - TIMESLIP.FRM:545 */\nexport const K6 = 0.92;\n\n/** K61: HP ratio upper bound for time interpolation - TIMESLIP.FRM:546 */\nexport const K61 = 1.08;\n\n/** KP21: Engine PMI deceleration factor for manual transmission - TIMESLIP.FRM:557 */\nexport const KP21 = 0.15;\n\n/** KP22: Engine PMI deceleration factor for automatic transmission - TIMESLIP.FRM:558 */\nexport const KP22 = 0.25;\n\n/** FRCT: Driveline friction coefficient - TIMESLIP.FRM:559 */\nexport const FRCT = 1.03;\n\n/** AX: Traction coefficient multiplier for Quarter Jr/Pro - TIMESLIP.FRM:551 */\nexport const AX = 10.8;\n\n// ===== Derived Constants =====\n\n/** Horsepower to foot-pounds per second conversion */\nexport const HP_TO_FTLBPS = 550;\n\n/** Feet per second to miles per hour conversion (3600/5280) */\nexport const FPS_TO_MPH = 3600 / 5280;\n\n/** Inches to feet conversion */\nexport const INCH_TO_FT = 1 / 12;\n\n/** Rankine temperature offset (°F to °R) */\nexport const RANKINE_OFFSET = 459.67;\n\n/** Gravitational acceleration (alias for gc) */\nexport const g = gc;\n","/**\n * VB6 Launch Bootstrap - Initial Ags0 calculation from engine torque.\n * \n * VB6 Source: TIMESLIP.FRM lines 1020-1027\n * \n * ```vb\n * TQ = Z6 * HP / EngRPM(L)\n * TQ = TQ * gc_TorqueMult.Value * TGR(iGear) * TGEff(iGear)\n * \n * DragForce = CMU * gc_Weight.Value + gc_DragCoef.Value * gc_RefArea.Value * q\n * force = TQ * gc_GearRatio.Value * gc_Efficiency.Value / (TireSlip * TireDia / 24) - DragForce\n * \n * 'estimate maximum acceleration from force and weight\n * If gc_TransType.Value Then\n *     Ags0 = 0.96 * force / gc_Weight.Value  'assume 4% misc losses on initial hit of tire\n * Else\n *     Ags0 = 0.88 * force / gc_Weight.Value  'assume 12% misc losses on initial hit of tire\n * End If\n * ```\n * \n * This gives the initial acceleration WITHOUT relying on ClutchSlip (which is 0 at launch).\n */\n\nimport { gc } from './constants';\n\nexport interface BootstrapInput {\n  /** Engine torque at slipRPM (from torque curve), in lb-ft */\n  engineTorque_lbft_atSlip: number;\n  \n  /** Transmission gear ratio for current gear (TGR) */\n  gearRatio: number;\n  \n  /** Transmission efficiency for current gear (TGEff), 0..1 */\n  transEff: number;\n  \n  /** Overall driveline efficiency (gc_Efficiency.Value), 0..1 */\n  drivelineEff: number;\n  \n  /** Final drive ratio (gc_GearRatio.Value) */\n  finalDrive: number;\n  \n  /** Tire diameter in inches */\n  tireDia_in: number;\n  \n  /** Tire slip factor (TireSlip), typically 1.02 */\n  tireSlip: number;\n  \n  /** Current drag force in lbf (from aero + rolling resistance) */\n  dragForce_lbf: number;\n  \n  /** Vehicle weight in lbf (gc_Weight.Value) */\n  vehicleWeight_lbf: number;\n  \n  /** Transmission type: true = auto (0.96 factor), false = manual (0.88 factor) */\n  isAutoTrans: boolean;\n  \n  /** Torque converter multiplication factor (gc_TorqueMult.Value), typically 1.0 for clutch, 1.5-2.5 for converter */\n  torqueMult?: number;\n}\n\nexport interface BootstrapOutput {\n  /** Initial acceleration in ft/s² */\n  Ags0_ftps2: number;\n  \n  /** Net launch thrust after losses (for diagnostics), in lbf */\n  netThrust_lbf: number;\n  \n  /** Wheel torque before thrust conversion (for diagnostics), in lb-ft */\n  wheelTorque_lbft: number;\n}\n\n/**\n * VB6 launch bootstrap: Calculate initial Ags0 from engine torque.\n * \n * This is the TORQUE-BASED path that VB6 uses at launch, before transitioning\n * to the HP-BASED path once velocity builds up.\n * \n * VB6 Order of Operations:\n * 1. Start with engine torque at slipRPM\n * 2. Apply gear ratio and transmission efficiency: TQ * TGR * TGEff\n * 3. Apply final drive and overall efficiency: TQ * FinalDrive * Efficiency\n * 4. Convert to thrust: Force = TQ / (TireSlip * TireDia / 24)\n * 5. Subtract drag: NetForce = Force - DragForce\n * 6. Convert to acceleration: a = NetForce / Weight\n * 7. Apply launch fudge factor: Ags0 = 0.88 * a (manual) or 0.96 * a (auto)\n * \n * @param input - Bootstrap inputs\n * @returns Initial acceleration (Ags0) and diagnostics\n */\nexport function computeAgs0(input: BootstrapInput): BootstrapOutput {\n  const {\n    engineTorque_lbft_atSlip,\n    gearRatio,\n    transEff,\n    drivelineEff,\n    finalDrive,\n    tireDia_in,\n    tireSlip,\n    dragForce_lbf,\n    vehicleWeight_lbf,\n    isAutoTrans,\n    torqueMult = 1.0,  // Default 1.0 for clutch, use actual value for converter\n  } = input;\n  \n  // VB6: TQ = TQ * gc_TorqueMult.Value * TGR(iGear) * TGEff(iGear)\n  // gc_TorqueMult is 1.0 for clutch, 1.5-2.5 for torque converter\n  const wheelTorque_lbft = engineTorque_lbft_atSlip * torqueMult * gearRatio * transEff;\n  \n  // VB6: force = TQ * gc_GearRatio.Value * gc_Efficiency.Value / (TireSlip * TireDia / 24) - DragForce\n  // Note: TireDia is in inches, so TireDia / 24 converts to feet (diameter / 2 / 12 = radius in ft)\n  const wheelRadius_ft = (tireDia_in / 24); // VB6 uses diameter/24, not diameter/12/2\n  const thrust_lbf = (wheelTorque_lbft * finalDrive * drivelineEff) / (tireSlip * wheelRadius_ft);\n  \n  // Subtract drag and rolling resistance\n  const netThrust_lbf = thrust_lbf - dragForce_lbf;\n  \n  // VB6: Ags0 = 0.96 * force / gc_Weight.Value (auto) or 0.88 * force / gc_Weight.Value (manual)\n  // IMPORTANT: VB6 stores Ags0 in g's, NOT ft/s²!\n  // VB6 multiplies by gc when integrating: Vel(L) = Vel0 + Ags0 * gc * TimeStep (TIMESLIP.FRM:1107)\n  // So we return acceleration in g's here\n  const launchFudge = isAutoTrans ? 0.96 : 0.88;\n  const Ags0_g = launchFudge * (netThrust_lbf / vehicleWeight_lbf);\n  const Ags0_ftps2 = Ags0_g * gc; // Convert to ft/s² for our integrator\n  \n  return {\n    Ags0_ftps2,\n    netThrust_lbf,\n    wheelTorque_lbft,\n  };\n}\n","/**\n * EXACT VB6 PORT – do not modify\n * \n * VB6 Source: QTRPERF.BAS - Weather() subroutine (lines 1290-1377)\n * \n * This module implements the exact VB6 air density and HP correction calculation:\n * 1. Saturation vapor pressure using 6th-order polynomial (QTRPERF.BAS:1317-1323)\n * 2. Water vapor pressure from relative humidity (QTRPERF.BAS:1325)\n * 3. Ambient pressure with elevation correction (QTRPERF.BAS:1326)\n * 4. Partial pressure of dry air (QTRPERF.BAS:1327)\n * 5. Water-to-air mass ratio (QTRPERF.BAS:1329)\n * 6. Gas constant for moist air (QTRPERF.BAS:1333)\n * 7. Air density via ideal gas law (QTRPERF.BAS:1335)\n * 8. HP correction factor (hpc) based on fuel/carburetion (QTRPERF.BAS:1341-1376)\n */\n\nimport { RANKINE_OFFSET, PSTD, BSTD, WTAIR, WTH20, RSTD, TSTD } from './constants';\n\n/** Fuel system types matching VB6 gc_FuelSystem.Value */\nexport type FuelSystemType = \n  | 1   // Gas + Carb\n  | 2   // Gas + Injector\n  | 3   // Methanol + Carb\n  | 4   // Methanol + Injector\n  | 5   // Nitro + Injector\n  | 6   // Gas + Supercharger\n  | 7   // Methanol + Supercharger\n  | 8   // Nitro + Supercharger\n  | 9;  // Electric (hpc = 1)\n\nexport type Vb6AirInputs = {\n  barometer_inHg: number;   // Barometric pressure (inHg), e.g. 29.92\n  temperature_F: number;    // Temperature (°F), e.g. 75\n  relHumidity_pct: number;  // Relative humidity (0..100)\n  elevation_ft?: number;    // Elevation (ft), default 0\n  fuelSystem?: FuelSystemType; // Fuel system type, default 1 (Gas + Carb)\n};\n\nexport type Vb6AirResult = {\n  rho_slug_per_ft3: number; // Air density (slugs/ft³)\n  pamb_psi: number;         // Ambient pressure (psi)\n  PWV_psi: number;          // Water vapor pressure (psi)\n  pair_psi: number;         // Dry air partial pressure (psi)\n  WAR: number;              // Water-to-air mass ratio\n  RGAS: number;             // Gas constant for moist air\n  temp_R: number;           // Temperature (°R)\n  hpc: number;              // HP correction factor (1.0 = standard conditions)\n  delta: number;            // Pressure ratio (pair / PSTD)\n  theta: number;            // Temperature ratio (temp_R / TSTD)\n  rgrs: number;             // Gas constant ratio\n};\n\n/**\n * Calculate air density and HP correction using exact VB6 algorithm.\n * \n * VB6 Source: QTRPERF.BAS, Weather() subroutine (lines 1290-1377)\n * \n * @param air - Air conditions (barometer, temperature, humidity, elevation, fuel system)\n * @returns Air density, HP correction factor, and intermediate values\n */\nexport function airDensityVB6(air: Vb6AirInputs): Vb6AirResult {\n  const elevation_ft = air.elevation_ft ?? 0;\n  const fuelSystem = air.fuelSystem ?? 1;\n  \n  // VB6 polynomial coefficients for saturation vapor pressure (QTRPERF.BAS:1317-1319)\n  const cps = [\n    0.0205558,           // cps(1)\n    0.00118163,          // cps(2)\n    0.0000154988,        // cps(3)\n    0.00000040245,       // cps(4)\n    0.000000000434856,   // cps(5)\n    0.00000000002096     // cps(6)\n  ];\n\n  // Step 1: Saturation vapor pressure (QTRPERF.BAS:1323)\n  const psdry = cps[0] + \n                cps[1] * air.temperature_F + \n                cps[2] * air.temperature_F ** 2 + \n                cps[3] * air.temperature_F ** 3 + \n                cps[4] * air.temperature_F ** 4 + \n                cps[5] * air.temperature_F ** 5;\n\n  // Step 2: Water vapor pressure from relative humidity (QTRPERF.BAS:1325)\n  const PWV = (air.relHumidity_pct / 100) * psdry;\n\n  // Step 3: Ambient pressure WITH elevation correction (QTRPERF.BAS:1326)\n  // VB6: pamb = (PSTD * gc_Barometer.Value / BSTD) * ((TSTD - 0.00356616 * gc_Elevation.Value) / TSTD) ^ 5.25588\n  const elevationFactor = Math.pow((TSTD - 0.00356616 * elevation_ft) / TSTD, 5.25588);\n  const pamb = (PSTD * air.barometer_inHg / BSTD) * elevationFactor;\n\n  // Step 4: Partial pressure of dry air (QTRPERF.BAS:1327-1328)\n  const pair = pamb - PWV;\n  const delta = pair / PSTD;\n\n  // Step 5: Water-to-air mass ratio (QTRPERF.BAS:1329)\n  const WAR = (PWV * WTH20) / (pair * WTAIR);\n\n  // Step 6: Gas constant for moist air (QTRPERF.BAS:1333-1334)\n  const RGAS = RSTD * ((1 / WTAIR) + (WAR / WTH20)) / (1 + WAR);\n  const rgrs = RGAS / (RSTD / WTAIR);\n\n  // Step 7: Temperature ratio and air density (QTRPERF.BAS:1332, 1335)\n  const temp_R = air.temperature_F + RANKINE_OFFSET;\n  const theta = temp_R / TSTD;\n  const rho_lbm_ft3 = 144 * pamb / (RGAS * temp_R);\n  const rho = rho_lbm_ft3 / 32.174; // Convert lbm/ft³ to slugs/ft³\n\n  // Step 8: HP correction factor (QTRPERF.BAS:1341-1376)\n  // Determine fuel and carburetion type\n  let ifuel: number;\n  let icarb: number;\n  \n  switch (fuelSystem) {\n    case 1:  ifuel = 1; icarb = 1; break; // Gas + Carb\n    case 2:  ifuel = 1; icarb = 2; break; // Gas + Injector\n    case 3:  ifuel = 2; icarb = 1; break; // Methanol + Carb\n    case 4:  ifuel = 2; icarb = 2; break; // Methanol + Injector\n    case 5:  ifuel = 3; icarb = 2; break; // Nitro + Injector\n    case 6:  ifuel = 1; icarb = 3; break; // Gas + Supercharger\n    case 7:\n    case 9:  ifuel = 2; icarb = 3; break; // Methanol + Supercharger (9 = Electric, but same calc)\n    case 8:  ifuel = 3; icarb = 3; break; // Nitro + Supercharger\n    default: ifuel = 1; icarb = 1; break;\n  }\n  \n  // VB6: kwar = 1 + 2.48 * WAR ^ 1.5 (QTRPERF.BAS:1354)\n  const kwar = 1 + 2.48 * Math.pow(WAR, 1.5);\n  \n  // Fuel-specific coefficients (QTRPERF.BAS:1356-1360)\n  let px: number;\n  let tx: number;\n  let mech: number;\n  \n  switch (ifuel) {\n    case 1: px = 1;    tx = 0.6;  mech = 0.15;  break; // Gas\n    case 2: px = 1;    tx = 0.3;  mech = 0.13;  break; // Methanol\n    case 3: px = 0.85; tx = 0.5;  mech = 0.055; break; // Nitro\n    default: px = 1;   tx = 0.6;  mech = 0.15;  break;\n  }\n  \n  // Injector adjustment (QTRPERF.BAS:1362)\n  if (icarb === 2) {\n    mech = mech - 0.005;\n  }\n  \n  // Supercharger adjustment (QTRPERF.BAS:1364-1371)\n  if (icarb === 3) {\n    const dtx = ((1.35 - 1) / 1.35) / 0.85;\n    px = 0.95 - dtx * tx;\n    tx = tx + dtx;\n    mech = 0.6 * mech;\n  }\n  \n  // Calculate hpc (QTRPERF.BAS:1373-1374)\n  // hpc = delta ^ px / (Sqr(rgrs) * theta ^ tx)\n  // hpc = (1 + mech) * kwar / hpc - mech\n  let hpc = Math.pow(delta, px) / (Math.sqrt(rgrs) * Math.pow(theta, tx));\n  hpc = (1 + mech) * kwar / hpc - mech;\n  \n  // Electric override (QTRPERF.BAS:1376)\n  if (fuelSystem === 9) {\n    hpc = 1;\n  }\n\n  return {\n    rho_slug_per_ft3: rho,\n    pamb_psi: pamb,\n    PWV_psi: PWV,\n    pair_psi: pair,\n    WAR: WAR,\n    RGAS: RGAS,\n    temp_R: temp_R,\n    hpc: hpc,\n    delta: delta,\n    theta: theta,\n    rgrs: rgrs,\n  };\n}\n","/**\n * VB6-ported force calculations.\n * Source: TIMESLIP.FRM lines 1016-1020, 1192-1193\n * \n * VB6 uses a complex drag model with:\n * - Rolling resistance (CMU coefficient)\n * - Speed-dependent rolling resistance (0.0001 * weight * speed)\n * - Aerodynamic drag (0.5 * rho * cd * area * v²)\n * - Distance-dependent CMU reduction (CMUK)\n */\n\nimport { gc } from './constants';\n// Z5 is documented in comments but not used in simplified implementation\n\n/**\n * Calculate VB6 rolling resistance force.\n * \n * VB6 Source: TIMESLIP.FRM lines 1019, 1192-1193\n * \n * VB6 Formula (initial):\n *   DragForce = CMU * gc_Weight.Value + gc_DragCoef.Value * gc_RefArea.Value * q\n * \n * VB6 Formula (during run):\n *   cmu1 = CMU - (Dist0 / 1320) * CMUK\n *   DragForce = cmu1 * DownForce + 0.0001 * DownForce * (Z5 * Vel(L)) + gc_DragCoef.Value * RefArea2 * q\n * \n * Where:\n * - CMU = 0.025 (Quarter Jr/Pro), 0.03 (Bonneville)\n * - CMUK = 0.01 (Quarter Jr/Pro), 0 (Bonneville)\n * - DownForce = Weight + LiftCoef * RefArea * q (includes lift/downforce)\n * - Z5 = 3600/5280 = 0.6818... (fps to mph conversion)\n * \n * @param downForce_lbf - Downforce on tires (weight + aero lift/downforce)\n * @param v_fps - Vehicle velocity (ft/s)\n * @param distance_ft - Distance traveled (ft) - affects cmu1\n * @param cmu - Base rolling resistance coefficient (0.025 for Quarter)\n * @param cmuk - Distance decay coefficient (0.01 for Quarter)\n * @returns Rolling resistance force (lb)\n */\nexport function vb6RollingResistanceForce(\n  downForce_lbf: number,\n  v_fps: number,\n  distance_ft: number,\n  cmu: number = 0.025,\n  cmuk: number = 0.01\n): number {\n  // VB6: cmu1 = CMU - (Dist0 / 1320) * CMUK\n  const cmu1 = cmu - (distance_ft / 1320) * cmuk;\n  \n  // VB6: Z5 = 3600 / 5280 (fps to mph conversion)\n  const Z5 = 3600 / 5280;\n  \n  // VB6: RollingForce = cmu1 * DownForce + 0.0001 * DownForce * (Z5 * Vel(L))\n  const F_rr_constant = cmu1 * downForce_lbf;\n  const F_rr_speed = 0.0001 * downForce_lbf * (Z5 * v_fps);\n  const F_rr = F_rr_constant + F_rr_speed;\n  \n  return F_rr;\n}\n\n/**\n * Calculate VB6 rolling resistance torque.\n * \n * @param downForce_lbf - Downforce on tires (weight + aero lift/downforce)\n * @param v_fps - Vehicle velocity (ft/s)\n * @param distance_ft - Distance traveled (ft) - affects cmu1\n * @param tireRadiusFt - Tire radius (ft)\n * @param cmu - Base rolling resistance coefficient (0.025 for Quarter)\n * @param cmuk - Distance decay coefficient (0.01 for Quarter)\n * @returns Rolling resistance torque (lb-ft)\n */\nexport function vb6RollingResistanceTorque(\n  downForce_lbf: number,\n  v_fps: number,\n  distance_ft: number,\n  tireRadiusFt: number,\n  cmu: number = 0.025,\n  cmuk: number = 0.01\n): number {\n  const F_rr = vb6RollingResistanceForce(downForce_lbf, v_fps, distance_ft, cmu, cmuk);\n  const T_rr = F_rr * tireRadiusFt;\n  return T_rr;\n}\n\n/**\n * Calculate VB6 aerodynamic drag force.\n * \n * VB6 Source: TIMESLIP.FRM lines 1016-1019, 1193\n * \n * VB6 Formula:\n *   WindFPS = Sqr(Vel(L)^2 + 2*Vel(L)*(WindSpeed/Z5)*Cos(PI*WindAngle/180) + (WindSpeed/Z5)^2)\n *   q = Sgn(WindFPS) * rho * Abs(WindFPS)^2 / (2 * gc)\n *   DragForce = ... + gc_DragCoef.Value * gc_RefArea.Value * q\n * \n * Where:\n * - q = dynamic pressure (psf)\n * - gc = gravitational constant (32.174 ft/s²)\n * - Z5 = 3600/5280 (conversion factor)\n * \n * For no wind: WindFPS = Vel(L), so q = rho * Vel(L)^2 / (2 * gc)\n * \n * Standard aero drag: F_d = 0.5 * rho * cd * area * v²\n * VB6 aero drag: F_d = cd * area * (rho * v² / (2 * gc))\n * \n * These are equivalent since gc = 32.174 and rho is in slugs/ft³.\n * \n * @param rho - Air density (slugs/ft³)\n * @param cd - Drag coefficient (dimensionless)\n * @param areaFt2 - Frontal area (ft²)\n * @param vFps - Velocity (ft/s)\n * @returns Aerodynamic drag force (lb)\n */\nexport function vb6AeroDragForce(\n  rho: number,\n  cd: number,\n  areaFt2: number,\n  vFps: number\n): number {\n  // VB6: TIMESLIP.FRM:1017, 1019\n  // q = rho * vFps^2 / (2 * gc)\n  // DragForce = cd * area * q\n  const q = rho * vFps * vFps / (2 * gc);\n  const F_d = cd * areaFt2 * q;\n  return F_d;\n}\n\n/**\n * Calculate VB6 aerodynamic drag torque.\n * \n * @param rho - Air density (slugs/ft³)\n * @param cd - Drag coefficient (dimensionless)\n * @param areaFt2 - Frontal area (ft²)\n * @param vFps - Velocity (ft/s)\n * @param tireRadiusFt - Tire radius (ft)\n * @returns Aerodynamic drag torque (lb-ft)\n */\nexport function vb6AeroTorque(\n  rho: number,\n  cd: number,\n  areaFt2: number,\n  vFps: number,\n  tireRadiusFt: number\n): number {\n  const F_d = vb6AeroDragForce(rho, cd, areaFt2, vFps);\n  const T_d = F_d * tireRadiusFt;\n  return T_d;\n}\n\n/**\n * Calculate aerodynamic lift force.\n * \n * VB6 Source: TIMESLIP.FRM:1191\n * DownForce = gc_Weight.Value + gc_LiftCoef.Value * RefArea2 * q\n * \n * Where q = rho * v² / (2 * gc) (dynamic pressure)\n * \n * So lift force = cl * area * q = cl * area * rho * v² / (2 * gc)\n * \n * Note: VB6 uses positive lift coefficient for upward lift (reduces downforce).\n * The result is added to weight to get DownForce.\n * \n * @param rho - Air density (slugs/ft³)\n * @param cl - Lift coefficient (dimensionless, positive = upward lift)\n * @param areaFt2 - Reference area (ft²)\n * @param vFps - Velocity (ft/s)\n * @returns Lift force (lb, positive = upward lift)\n */\nexport function vb6AeroLift(\n  rho: number,\n  cl: number,\n  areaFt2: number,\n  vFps: number\n): number {\n  // VB6: q = rho * v² / (2 * gc)\n  // VB6: LiftForce = cl * area * q\n  const q = rho * vFps * vFps / (2 * gc);\n  const F_lift = cl * areaFt2 * q;\n  return F_lift;\n}\n","/**\n * VB6-ported driveline (converter/clutch) calculations.\n * Source: TIMESLIP.FRM lines 1144-1178\n * \n * VB6 uses complex converter/clutch models with:\n * - Stall RPM clamping\n * - Speed ratio dependent torque multiplication\n * - Slippage factors\n * - Lock-up behavior\n */\n\n/**\n * VB6 torque converter model.\n * \n * VB6 Source: TIMESLIP.FRM lines 1154-1172\n * \n * VB6 Algorithm:\n * 1. Calculate lock RPM: LockRPM = wheelRPM * gearRatio * finalDrive\n * 2. Calculate slip ratio: SlipRatio = slippage * LockRPM / stallRPM\n * 3. Adjust stall RPM if slip ratio > 0.6 (dynamic stall)\n * 4. Clamp engine RPM to stall RPM minimum\n * 5. Calculate torque multiplication based on slip ratio\n * 6. Calculate clutch slip (coupling factor)\n * \n * @param engineTorque - Engine torque (lb-ft)\n * @param engineRPM - Engine RPM (from wheel speed)\n * @param wheelRPM - Wheel RPM (output shaft)\n * @param gearRatio - Current gear ratio\n * @param finalDrive - Final drive ratio\n * @param stallRPM - Converter stall RPM\n * @param torqueMult - Static torque multiplication factor (typically 1.5-2.5)\n * @param slippage - Converter slippage factor (typically 1.0-1.1)\n * @param gear - Current gear (1-based, for lock-up logic)\n * @param lockup - Whether converter locks up after 1st gear\n * @returns Wheel torque and effective engine RPM\n */\nexport function vb6Converter(\n  engineTorque: number,\n  _engineRPM: number,\n  wheelRPM: number,\n  gearRatio: number,\n  finalDrive: number,\n  stallRPM: number,\n  torqueMult: number,\n  slippage: number = 1.05,\n  gear: number = 1,\n  lockup: boolean = false\n): { Twheel: number; engineRPM_out: number } {\n  // VB6: TIMESLIP.FRM:1145-1146\n  // LockRPM = DSRPM * gc_GearRatio.Value * TGR(iGear)\n  // EngRPM(L) = gc_Slippage.Value * LockRPM\n  const LockRPM = wheelRPM * gearRatio * finalDrive;\n  let EngRPM_out = slippage * LockRPM;\n  let ClutchSlip = 1.0;\n  \n  // VB6: TIMESLIP.FRM:1154-1172 (converter)\n  if (gear === 1 || !lockup) {\n    // Non lock-up converter (1st gear or no lock-up)\n    let zStall = stallRPM;\n    let SlipRatio = slippage * LockRPM / zStall;\n    \n    // VB6: TIMESLIP.FRM:1159-1161\n    // Dynamic stall adjustment when slip ratio > 0.6\n    if (SlipRatio > 0.6) {\n      zStall = zStall * (1 + (slippage - 1) * (SlipRatio - 0.6) / ((1 / slippage) - 0.6));\n      SlipRatio = slippage * LockRPM / zStall;\n    }\n    \n    // VB6: TIMESLIP.FRM:1162\n    ClutchSlip = 1 / slippage;\n    \n    // VB6: TIMESLIP.FRM:1164-1168\n    // Clamp engine RPM to stall minimum\n    if (EngRPM_out < zStall) {\n      EngRPM_out = zStall;\n      // Torque multiplication decreases linearly with slip ratio\n      const Work = torqueMult - (torqueMult - 1) * SlipRatio;\n      ClutchSlip = Work * LockRPM / zStall;\n    }\n  } else {\n    // VB6: TIMESLIP.FRM:1170-1171\n    // Lock-up converter (2nd gear and above with lock-up)\n    EngRPM_out = 1.005 * LockRPM; // 0.5% slippage\n    ClutchSlip = LockRPM / EngRPM_out;\n  }\n  \n  // VB6: TIMESLIP.FRM:1174\n  if (ClutchSlip > 1) ClutchSlip = 1;\n  \n  // VB6: TIMESLIP.FRM:1178\n  // HP = HP * ClutchSlip\n  // Torque is proportional to HP at same RPM, so:\n  const Twheel = engineTorque * ClutchSlip * gearRatio * finalDrive;\n  \n  return { Twheel, engineRPM_out: EngRPM_out };\n}\n\n/**\n * VB6 clutch model (HP-based).\n * \n * VB6 Source: TIMESLIP.FRM lines 1148-1152, 1176-1178\n * \n * VB6 Algorithm:\n * 1. Calculate lock RPM: LockRPM = wheelRPM * gearRatio * finalDrive\n * 2. Calculate engine RPM with slippage: EngRPM = slippage * LockRPM\n * 3. Clamp engine RPM to slip/stall RPM minimum (1st gear or no lock-up)\n * 4. Calculate clutch slip: ClutchSlip = LockRPM / EngRPM\n * 5. Get HP from engine curve at EngRPM\n * 6. Scale HP by ClutchSlip: HP_eff = HP * ClutchSlip\n * 7. Convert back to torque: T_eff = (HP_eff * 5252) / EngRPM\n * 8. Apply gear ratios: Twheel = T_eff * gearRatio * finalDrive\n * \n * @param engineHP - Engine HP at current RPM\n * @param engineRPM - Engine RPM (from wheel speed, unused - recalculated)\n * @param wheelRPM - Wheel RPM (output shaft)\n * @param gearRatio - Current gear ratio\n * @param finalDrive - Final drive ratio\n * @param slipRPM - Clutch slip/stall RPM\n * @param slippage - Clutch slippage factor (typically 1.0025)\n * @param gear - Current gear (1-based, for lock-up logic)\n * @param lockup - Whether clutch locks up after 1st gear\n * @returns Wheel torque, effective engine RPM, and coupling factor\n */\nexport function vb6Clutch(\n  engineHP: number,\n  _engineRPM: number,\n  wheelRPM: number,\n  gearRatio: number,\n  finalDrive: number,\n  slipRPM: number,\n  slippage: number = 1.0025,\n  gear: number = 1,\n  lockup: boolean = false\n): { Twheel: number; engineRPM_out: number; coupling: number } {\n  // VB6: TIMESLIP.FRM:1145-1146\n  // LockRPM = DSRPM * gc_GearRatio.Value * TGR(iGear)\n  // EngRPM(L) = gc_Slippage.Value * LockRPM\n  const LockRPM = wheelRPM * gearRatio * finalDrive;\n  let EngRPM_out = slippage * LockRPM;\n  \n  // VB6: TIMESLIP.FRM:1148-1152 (clutch)\n  // If EngRPM(L) < Stall Then\n  //     If iGear = 1 Or gc_LockUp.Value = 0 Then EngRPM(L) = Stall\n  // End If\n  // ClutchSlip = LockRPM / EngRPM(L)\n  if (EngRPM_out < slipRPM) {\n    if (gear === 1 || !lockup) {\n      EngRPM_out = slipRPM;\n    }\n  }\n  \n  const ClutchSlip = LockRPM / EngRPM_out;\n  \n  // VB6: TIMESLIP.FRM:1176-1178\n  // Call TABY(xrpm(), yhp(), NHP, 1, EngRPM(L), HP)\n  // HP = gc_HPTQMult.Value * HP / hpc\n  // HP = HP * ClutchSlip\n  //\n  // VB6 scales HP by ClutchSlip, then converts to torque\n  // We receive HP at EngRPM_out, so scale it:\n  const HP_eff = engineHP * ClutchSlip;\n  \n  // Convert HP back to torque at EngRPM_out\n  // T = (HP * 5252) / RPM\n  const T_eff = EngRPM_out > 0 ? (HP_eff * 5252) / EngRPM_out : 0;\n  \n  // Apply gear ratios\n  const Twheel = T_eff * gearRatio * finalDrive;\n  \n  return { Twheel, engineRPM_out: EngRPM_out, coupling: ClutchSlip };\n}\n\n/**\n * VB6 converter coupling calculation (for HP-based path).\n * \n * VB6 Source: TIMESLIP.FRM:1156-1168\n * \n * Returns Work factor and ClutchSlip (coupling) for use in HP chain.\n * \n * @param lockRPM - Lock RPM (wheelRPM * gearRatio * finalDrive)\n * @param stallRPM - Converter stall RPM\n * @param torqueMult - Static torque multiplication factor\n * @param slippage - Converter slippage factor\n * @param stepCount - Current step count (for dynamic stall after step 2)\n * @returns Work factor, coupling, slip ratio, and effective stall RPM\n */\nexport function vb6ConverterCoupling(\n  lockRPM: number,\n  stallRPM: number,\n  torqueMult: number,\n  slippage: number,\n  stepCount: number = 1\n): { work: number; coupling: number; slipRatio: number; zStall: number; engRPM: number } {\n  // VB6: TIMESLIP.FRM:1155-1156\n  // zStall = Stall\n  // SlipRatio = gc_Slippage.Value * LockRPM / zStall\n  let zStall = stallRPM;\n  let SlipRatio = slippage * lockRPM / zStall;\n  \n  // VB6: TIMESLIP.FRM:1158-1161\n  // If L > 2 Then\n  //     If SlipRatio > 0.6 Then zStall = zStall * (1 + (gc_Slippage.Value - 1) * (SlipRatio - 0.6) / ((1 / gc_Slippage.Value) - 0.6))\n  //     SlipRatio = gc_Slippage.Value * LockRPM / zStall\n  // End If\n  if (stepCount > 2 && SlipRatio > 0.6) {\n    zStall = zStall * (1 + (slippage - 1) * (SlipRatio - 0.6) / ((1 / slippage) - 0.6));\n    SlipRatio = slippage * lockRPM / zStall;\n  }\n  \n  // VB6: TIMESLIP.FRM:1162\n  // ClutchSlip = 1 / gc_Slippage.Value   <-- DEFAULT value\n  let ClutchSlip = 1 / slippage;\n  \n  // VB6: TIMESLIP.FRM:1146\n  // EngRPM(L) = gc_Slippage.Value * LockRPM\n  let engRPM = slippage * lockRPM;\n  \n  // VB6: TIMESLIP.FRM:1164-1168\n  // If EngRPM(L) < zStall Then\n  //     EngRPM(L) = zStall\n  //     Work = gc_TorqueMult.Value - (gc_TorqueMult.Value - 1) * SlipRatio\n  //     ClutchSlip = Work * LockRPM / zStall\n  // End If\n  let Work = 1.0; // Default when not stalling\n  if (engRPM < zStall) {\n    engRPM = zStall;\n    Work = torqueMult - (torqueMult - 1) * SlipRatio;\n    ClutchSlip = Work * lockRPM / zStall;\n  }\n  \n  // VB6: TIMESLIP.FRM:1174\n  // If ClutchSlip > 1 Then ClutchSlip = 1\n  if (ClutchSlip > 1) ClutchSlip = 1;\n  \n  return {\n    work: Work,\n    coupling: ClutchSlip,\n    slipRatio: SlipRatio,\n    zStall: zStall,\n    engRPM: engRPM\n  };\n}\n\n/**\n * VB6 direct drive (no converter or clutch).\n * \n * @param engineTorque - Engine torque (lb-ft)\n * @param gearRatio - Current gear ratio\n * @param finalDrive - Final drive ratio\n * @returns Wheel torque\n */\nexport function vb6DirectDrive(\n  engineTorque: number,\n  gearRatio: number,\n  finalDrive: number\n): number {\n  // Direct mechanical connection\n  return engineTorque * gearRatio * finalDrive;\n}\n","/**\n * VB6 Traction and Acceleration Clamping\n * \n * Exact port of VB6 traction force (CRTF) and acceleration limits (AMin/AMax).\n * \n * Sources:\n * - TIMESLIP.FRM lines 1020-1027 (initial Ags0)\n * - TIMESLIP.FRM lines 1213-1216 (CRTF calculation)\n * - TIMESLIP.FRM lines 1224-1228 (AMax/AMin clamps)\n * - TIMESLIP.FRM lines 1262-1266 (AMax/AMin clamps in HP path)\n * - VB6-LAUNCH-BLOCK-NOTES.md\n */\n\nimport { AMin as AMin_CONSTANT, gc } from './constants';\n\n/**\n * VB6 Base Traction Coefficient\n * \n * TIMESLIP.FRM lines 550-570:\n * ```vb\n * #If Not ISBVPRO Then        'QUARTER jr and QUARTER Pro\n *     Const AX = 10.8         'reduced from 11.2 - 07/23/01\n * #Else                       'Bonneville Pro\n *     Const AX = 9.7          'reduced from 10.0 - 07/23/01\n * #End If\n * ```\n */\nexport const VB6_AX = 10.8; // Quarter Jr/Pro (default)\nexport const VB6_AX_BONN = 9.7; // Bonneville Pro\n\nexport interface TractionParams {\n  /** Vehicle weight in lbf (gc_Weight.Value) */\n  weight_lbf: number;\n  \n  /** Tire diameter in inches (TireDia) */\n  tireDia_in: number;\n  \n  /** Tire width in inches (gc_TireWidth.Value) */\n  tireWidth_in: number;\n  \n  /** Dynamic rear weight transfer in lbf (DynamicRWT) */\n  dynamicRWT_lbf: number;\n  \n  /** Traction index adjustment (CAXI) */\n  tractionIndexAdj: number;\n  \n  /** Tire growth factor (TireGrowth) - typically 1.0 at launch */\n  tireGrowth: number;\n  \n  /** Drag force in lbf (DragForce) */\n  dragForce_lbf: number;\n  \n  /** Body style (gc_BodyStyle.Value) - 8 = motorcycle (halves CRTF) */\n  bodyStyle?: number;\n}\n\n/**\n * VB6 Traction Force Calculation\n * \n * TIMESLIP.FRM lines 1213-1214:\n * ```vb\n * CRTF = CAXI * AX * TireDia * (gc_TireWidth.Value + 1) * (0.92 + 0.08 * (DynamicRWT / 1900) ^ 2.15)\n * If gc_BodyStyle.Value = 8 Then CRTF = 0.5 * CRTF\n * ```\n * \n * Where AX = 10.8 for Quarter Jr/Pro (TIMESLIP.FRM line 551)\n * \n * @param params - Traction parameters\n * @returns CRTF (tire traction force) in lbf\n */\nexport function computeCRTF(params: TractionParams): number {\n  const {\n    tireDia_in,\n    tireWidth_in,\n    dynamicRWT_lbf,\n    tractionIndexAdj,\n    bodyStyle,\n  } = params;\n  \n  // VB6: CRTF = CAXI * AX * TireDia * (gc_TireWidth.Value + 1) * (0.92 + 0.08 * (DynamicRWT / 1900) ^ 2.15)\n  // Use VB6_AX = 10.8 (Quarter Jr/Pro constant)\n  const weightFactor = 0.92 + 0.08 * Math.pow(dynamicRWT_lbf / 1900, 2.15);\n  let CRTF = tractionIndexAdj * VB6_AX * tireDia_in * (tireWidth_in + 1) * weightFactor;\n  \n  // VB6: If gc_BodyStyle.Value = 8 Then CRTF = 0.5 * CRTF\n  if (bodyStyle === 8) {\n    CRTF = 0.5 * CRTF;\n  }\n  \n  return CRTF;\n}\n\n/**\n * VB6 Maximum Acceleration Calculation\n * \n * TIMESLIP.FRM line 1216:\n * ```vb\n * AMAX = ((CRTF / TireGrowth) - DragForce) / gc_Weight.Value\n * ```\n * \n * Also line 1054:\n * ```vb\n * AMAX = (CRTF - DragForce) / gc_Weight.Value\n * ```\n * (No tire growth at initial calculation)\n * \n * IMPORTANT: VB6 stores AMAX in g's, NOT ft/s²!\n * VB6 multiplies by gc when integrating velocity.\n * We convert to ft/s² for consistency with our integrator.\n * \n * @param params - Traction parameters\n * @returns AMax in ft/s²\n */\nexport function computeAMaxVB6(params: TractionParams): number {\n  const { weight_lbf, tireGrowth, dragForce_lbf } = params;\n  \n  const CRTF = computeCRTF(params);\n  \n  // VB6: AMAX = ((CRTF / TireGrowth) - DragForce) / gc_Weight.Value\n  // This gives AMax in g's\n  const AMax_g = ((CRTF / tireGrowth) - dragForce_lbf) / weight_lbf;\n  \n  // Convert to ft/s² for our integrator\n  const AMax_ftps2 = AMax_g * gc;\n  \n  return AMax_ftps2;\n}\n\n/**\n * VB6 Minimum Acceleration\n * \n * VB6-LAUNCH-BLOCK-NOTES.md line 14:\n * ```vb\n * Const AMin = 0.004  'reduced from .05 to .004 for Qjr and QPro\n * ```\n * \n * IMPORTANT: VB6 stores AMin in g's, NOT ft/s²!\n * The constant 0.004 is in g's (0.004g = 0.129 ft/s²).\n * We convert to ft/s² for consistency with our integrator.\n * \n * @returns AMin in ft/s²\n */\nexport function computeAMinVB6(): number {\n  // VB6 AMin = 0.004 g's\n  const AMin_g = AMin_CONSTANT;\n  // Convert to ft/s²\n  const AMin_ftps2 = AMin_g * gc;\n  return AMin_ftps2;\n}\n\n/**\n * VB6 Acceleration Clamping with Proportional PQWT Rescaling\n * \n * TIMESLIP.FRM lines 1224-1228:\n * ```vb\n * If AGS(L) > AMAX Then\n *     SLIP(L) = 1\n *     PQWT = PQWT * (AMAX - (AGS(L) - AMAX)) / AGS(L):    AGS(L) = AMAX - (AGS(L) - AMAX)\n * End If\n * If AGS(L) < AMin Then PQWT = PQWT * AMin / AGS(L):          AGS(L) = AMin\n * ```\n * \n * Also lines 1262-1266 (same logic in HP path).\n * \n * **AMax Clamp:**\n * - If AGS > AMax: `PQWT_new = PQWT * (2*AMax - AGS) / AGS`, `AGS_new = 2*AMax - AGS`\n * \n * **AMin Clamp:**\n * - If AGS < AMin: `PQWT_new = PQWT * AMin / AGS`, `AGS_new = AMin`\n * \n * @param AGS_candidate - Candidate acceleration before clamping (ft/s²)\n * @param PQWT_candidate - Candidate thrust before clamping (ft/s²)\n * @param AMin - Minimum acceleration (ft/s²)\n * @param AMax - Maximum acceleration (ft/s²)\n * @returns { AGS: clamped acceleration, PQWT: rescaled thrust, SLIP: 1 if slipping, 0 otherwise }\n */\nexport function clampAGSVB6(\n  AGS_candidate: number,\n  PQWT_candidate: number,\n  AMin: number,\n  AMax: number\n): { AGS: number; PQWT: number; SLIP: number } {\n  let AGS = AGS_candidate;\n  let PQWT = PQWT_candidate;\n  let SLIP = 0;\n  \n  // VB6: If AGS(L) > AMAX Then\n  if (AGS > AMax) {\n    SLIP = 1;\n    // VB6: PQWT = PQWT * (AMAX - (AGS(L) - AMAX)) / AGS(L)\n    // Simplifies to: PQWT = PQWT * (2*AMAX - AGS) / AGS\n    PQWT = PQWT * (AMax - (AGS - AMax)) / AGS;\n    // VB6: AGS(L) = AMAX - (AGS(L) - AMAX)\n    // Simplifies to: AGS = 2*AMAX - AGS\n    AGS = AMax - (AGS - AMax);\n  }\n  \n  // VB6: If AGS(L) < AMin Then PQWT = PQWT * AMin / AGS(L):  AGS(L) = AMin\n  if (AGS < AMin) {\n    PQWT = PQWT * AMin / AGS;\n    AGS = AMin;\n  }\n  \n  return { AGS, PQWT, SLIP };\n}\n\n/**\n * VB6 Traction Index Adjustment (CAXI)\n * \n * TIMESLIP.FRM line 1037:\n * ```vb\n * CAXI = (1 - (gc_TractionIndex.Value - 1) * 0.01) / (TrackTempEffect ^ 0.25)\n * ```\n * \n * Where TrackTempEffect is calculated from track temperature.\n * \n * @param tractionIndex - VB6 traction index (1-10, typically 3)\n * @param trackTempEffect - Track temperature effect (typically 1.0)\n * @returns CAXI (traction index adjustment factor)\n */\nexport function computeCAXI(tractionIndex: number, trackTempEffect: number): number {\n  // VB6: CAXI = (1 - (gc_TractionIndex.Value - 1) * 0.01) / (TrackTempEffect ^ 0.25)\n  const CAXI = (1 - (tractionIndex - 1) * 0.01) / Math.pow(trackTempEffect, 0.25);\n  return CAXI;\n}\n\n","/**\n * VB6 PMI (Polar Moment of Inertia) HP Calculations\n * \n * EXACT port from TIMESLIP.FRM lines 1231-1248\n * \n * VB6 calculates the horsepower required to accelerate rotating masses:\n * - Engine PMI: Crankshaft, flywheel, clutch/converter\n * - Chassis PMI: Transmission gears, driveshaft, wheels/tires\n * \n * These HP losses are subtracted from available engine HP before computing vehicle acceleration.\n * \n * Key VB6 formulas:\n * - EngAccHP = gc_EnginePMI.Value * EngRPM(L) * (EngRPM(L) - RPM0)\n * - ChasAccHP = ChassisPMI * DSRPM * (DSRPM - DSRPM0)\n * - Work = (2 * PI / 60) ^ 2 / (12 * 550 * dtk1)\n * - HPEngPMI = EngAccHP * Work\n * - HPChasPMI = ChasAccHP * Work\n */\n\nimport { PI, KP21, KP22 } from './constants';\n\n/**\n * Compute engine PMI horsepower loss\n * \n * VB6: TIMESLIP.FRM:1231-1238\n * EngAccHP = gc_EnginePMI.Value * EngRPM(L) * (EngRPM(L) - RPM0)\n * If EngAccHP < 0 Then\n *     If Not gc_TransType.Value Then\n *         EngAccHP = KP21 * EngAccHP  ' Clutch\n *     Else\n *         EngAccHP = KP22 * EngAccHP  ' Converter\n *     End If\n * End If\n * \n * Then: HPEngPMI = EngAccHP * Work\n * Where: Work = (2 * PI / 60) ^ 2 / (12 * 550 * dtk1)\n * \n * Units:\n * - EnginePMI: slug-ft² (moment of inertia)\n * - EngRPM: rev/min\n * - dt: seconds\n * - Result: horsepower\n * \n * @param enginePMI Engine moment of inertia (slug-ft²)\n * @param engRPM Current engine RPM\n * @param rpm0 Previous engine RPM\n * @param dt Time step (seconds)\n * @param isClutch True for clutch, false for converter\n * @returns HP loss due to engine acceleration\n */\nexport function computeHPEngPMI(\n  enginePMI: number,\n  engRPM: number,\n  rpm0: number,\n  dt: number,\n  isClutch: boolean\n): number {\n  // VB6: EngAccHP = gc_EnginePMI.Value * EngRPM(L) * (EngRPM(L) - RPM0)\n  let engAccHP = enginePMI * engRPM * (engRPM - rpm0);\n  \n  // VB6: If EngAccHP < 0 Then apply deceleration factor\n  if (engAccHP < 0) {\n    engAccHP = isClutch ? KP21 * engAccHP : KP22 * engAccHP;\n  }\n  \n  // VB6: Work = (2 * PI / 60) ^ 2 / (12 * 550 * dtk1)\n  // This converts from (slug-ft² * rpm²) to horsepower\n  const work = Math.pow(2 * PI / 60, 2) / (12 * 550 * dt);\n  \n  // VB6: HPEngPMI = EngAccHP * Work\n  const hpEngPMI = engAccHP * work;\n  \n  return hpEngPMI;\n}\n\n/**\n * Compute chassis PMI horsepower loss\n * \n * VB6: TIMESLIP.FRM:1240, 1248\n * ChasAccHP = ChassisPMI * DSRPM * (DSRPM - DSRPM0)\n * If ChasAccHP < 0 Then ChasAccHP = 0\n * \n * Then: HPChasPMI = ChasAccHP * Work\n * \n * Where:\n * - ChassisPMI = gc_TiresPMI.Value + gc_TransPMI.Value * gc_GearRatio.Value ^ 2 * TGR(iGear) ^ 2\n * - DSRPM = TireSlip * Vel(L) * 60 / TireCirFt  (driveshaft RPM)\n * \n * Units:\n * - ChassisPMI: slug-ft² (moment of inertia)\n * - DSRPM: rev/min (driveshaft RPM)\n * - dt: seconds\n * - Result: horsepower\n * \n * @param chassisPMI Chassis moment of inertia (slug-ft²)\n * @param dsRPM Current driveshaft RPM\n * @param dsRPM0 Previous driveshaft RPM\n * @param dt Time step (seconds)\n * @returns HP loss due to chassis acceleration\n */\nexport function computeHPChasPMI(\n  chassisPMI: number,\n  dsRPM: number,\n  dsRPM0: number,\n  dt: number\n): number {\n  // VB6: ChasAccHP = ChassisPMI * DSRPM * (DSRPM - DSRPM0)\n  let chasAccHP = chassisPMI * dsRPM * (dsRPM - dsRPM0);\n  \n  // VB6: If ChasAccHP < 0 Then ChasAccHP = 0\n  if (chasAccHP < 0) {\n    chasAccHP = 0;\n  }\n  \n  // VB6: Work = (2 * PI / 60) ^ 2 / (12 * 550 * dtk1)\n  const work = Math.pow(2 * PI / 60, 2) / (12 * 550 * dt);\n  \n  // VB6: HPChasPMI = ChasAccHP * Work\n  const hpChasPMI = chasAccHP * work;\n  \n  return hpChasPMI;\n}\n\n/**\n * Calculate total chassis PMI (transmission + tires)\n * \n * VB6: TIMESLIP.FRM:1075\n * ChassisPMI = gc_TiresPMI.Value + gc_TransPMI.Value * gc_GearRatio.Value ^ 2 * TGR(iGear) ^ 2\n * \n * @param tiresPMI Tires moment of inertia (slug-ft²)\n * @param transPMI Transmission moment of inertia (slug-ft²)\n * @param finalDrive Final drive ratio\n * @param gearRatio Current gear ratio\n * @returns Total chassis PMI (slug-ft²)\n */\nexport function computeChassisPMI(\n  tiresPMI: number,\n  transPMI: number,\n  finalDrive: number,\n  gearRatio: number\n): number {\n  // VB6: ChassisPMI = gc_TiresPMI.Value + gc_TransPMI.Value * gc_GearRatio.Value ^ 2 * TGR(iGear) ^ 2\n  const chassisPMI = tiresPMI + transPMI * Math.pow(finalDrive * gearRatio, 2);\n  return chassisPMI;\n}\n\n/**\n * Calculate driveshaft RPM\n * \n * VB6: TIMESLIP.FRM:1140\n * DSRPM = TireSlip * Vel(L) * 60 / TireCirFt\n * \n * @param tireSlip Tire slip factor (typically 1.0-1.02)\n * @param v_fps Vehicle velocity (ft/s)\n * @param tireCircumference_ft Tire circumference (ft)\n * @returns Driveshaft RPM\n */\nexport function computeDSRPM(\n  tireSlip: number,\n  v_fps: number,\n  tireCircumference_ft: number\n): number {\n  // VB6: DSRPM = TireSlip * Vel(L) * 60 / TireCirFt\n  const dsRPM = tireSlip * v_fps * 60 / tireCircumference_ft;\n  return dsRPM;\n}\n\n/**\n * EXACT VB6 port: Calculate engine PMI HP loss\n * \n * VB6: TIMESLIP.FRM:1231-1238, 1247-1248\n * \n * Formula:\n * 1. EngAccHP = gc_EnginePMI.Value * EngRPM(L) * (EngRPM(L) - RPM0)\n * 2. If EngAccHP < 0 Then EngAccHP = KP2x * EngAccHP  (deceleration factor)\n * 3. Work = (2 * PI / 60) ^ 2 / (12 * 550 * dt)\n * 4. HPEngPMI = EngAccHP * Work\n * \n * @param prevRPM Previous engine RPM (RPM0)\n * @param rpm Current engine RPM (EngRPM(L))\n * @param dt_s Time step in seconds (dtk1)\n * @param PMI_engine_slugft2 Engine PMI in slug-ft² (gc_EnginePMI.Value)\n * @param isClutch True for clutch (KP21), false for converter (KP22)\n * @returns HPEngPMI - HP loss due to engine acceleration\n */\nexport function hpEngPMI(\n  prevRPM: number,\n  rpm: number,\n  dt_s: number,\n  PMI_engine_slugft2: number,\n  isClutch: boolean = true\n): number {\n  // VB6: TIMESLIP.FRM:1231\n  // EngAccHP = gc_EnginePMI.Value * EngRPM(L) * (EngRPM(L) - RPM0)\n  let engAccHP = PMI_engine_slugft2 * rpm * (rpm - prevRPM);\n  \n  // VB6: TIMESLIP.FRM:1232-1238\n  // If EngAccHP < 0 Then\n  //     If Not gc_TransType.Value Then\n  //         EngAccHP = KP21 * EngAccHP\n  //     Else\n  //         EngAccHP = KP22 * EngAccHP\n  //     End If\n  // End If\n  if (engAccHP < 0) {\n    engAccHP = isClutch ? KP21 * engAccHP : KP22 * engAccHP;\n  }\n  \n  // VB6: TIMESLIP.FRM:1247\n  // Work = (2 * PI / 60) ^ 2 / (12 * 550 * dtk1)\n  const work = Math.pow(2 * PI / 60, 2) / (12 * 550 * dt_s);\n  \n  // VB6: TIMESLIP.FRM:1248\n  // HPEngPMI = EngAccHP * Work\n  const HPEngPMI = engAccHP * work;\n  \n  return HPEngPMI;\n}\n\n/**\n * EXACT VB6 port: Calculate chassis PMI HP loss\n * \n * VB6: TIMESLIP.FRM:1240, 1247-1248\n * \n * Formula:\n * 1. ChasAccHP = ChassisPMI * DSRPM * (DSRPM - DSRPM0)\n * 2. If ChasAccHP < 0 Then ChasAccHP = 0\n * 3. Work = (2 * PI / 60) ^ 2 / (12 * 550 * dt)\n * 4. HPChasPMI = ChasAccHP * Work\n * \n * @param prevWheelRPM Previous driveshaft RPM (DSRPM0)\n * @param wheelRPM Current driveshaft RPM (DSRPM)\n * @param dt_s Time step in seconds (dtk1)\n * @param PMI_chassis_slugft2 Chassis PMI in slug-ft² (ChassisPMI)\n * @returns HPChasPMI - HP loss due to chassis acceleration\n */\nexport function hpChasPMI(\n  prevWheelRPM: number,\n  wheelRPM: number,\n  dt_s: number,\n  PMI_chassis_slugft2: number\n): number {\n  // VB6: TIMESLIP.FRM:1240\n  // ChasAccHP = ChassisPMI * DSRPM * (DSRPM - DSRPM0)\n  let chasAccHP = PMI_chassis_slugft2 * wheelRPM * (wheelRPM - prevWheelRPM);\n  \n  // VB6: TIMESLIP.FRM:1240\n  // If ChasAccHP < 0 Then ChasAccHP = 0\n  if (chasAccHP < 0) {\n    chasAccHP = 0;\n  }\n  \n  // VB6: TIMESLIP.FRM:1247\n  // Work = (2 * PI / 60) ^ 2 / (12 * 550 * dtk1)\n  const work = Math.pow(2 * PI / 60, 2) / (12 * 550 * dt_s);\n  \n  // VB6: TIMESLIP.FRM:1248\n  // HPChasPMI = ChasAccHP * Work\n  const HPChasPMI = chasAccHP * work;\n  \n  return HPChasPMI;\n}\n","/**\n * VB6 Tire Growth Model\n * \n * VB6 Source: TIMESLIP.FRM:1585-1607 (Tire subroutine)\n * \n * Tire diameter increases with speed due to centrifugal force.\n * This affects:\n * - Effective gear ratio (higher speed = larger tire = lower effective ratio)\n * - Frontal area for drag (larger tire = more drag)\n * - Traction (CRTF / TireGrowth in AMax calculation)\n * \n * VB6 also applies \"tire squat\" under load (reduces effective diameter).\n */\n\n/**\n * Compute effective tire diameter and circumference with growth and squat\n * \n * VB6: TIMESLIP.FRM:1585-1607\n * \n * Quarter Jr/Pro formula:\n *   TGK = (TireWidth^1.4 + TireDia - 16) / (0.171 * TireDia^1.7)\n *   TireGrowth = 1 + TGK * 0.0000135 * Vel^1.6\n *   TGLinear = 1 + TGK * 0.00035 * Vel\n *   If TGLinear < TireGrowth Then TireGrowth = TGLinear\n *   TireSQ = TireGrowth - 0.035 * Abs(Ags0)  ' tire squat under load\n *   TireCirFt = TireSQ * TireDia * PI / 12\n * \n * Units:\n * - tireDia_in: Tire diameter (inches)\n * - tireWidth_in: Tire width (inches)\n * - v_fps: Vehicle velocity (ft/s)\n * - ags_ftps2: Current acceleration (ft/s²) - used for squat\n * \n * @param tireDia_in Static tire diameter (inches)\n * @param tireWidth_in Tire width (inches)\n * @param v_fps Vehicle velocity (ft/s)\n * @param ags_ftps2 Current acceleration (ft/s²) for squat calculation\n * @returns Effective tire dimensions with growth and squat\n */\nexport function computeTireGrowth(\n  tireDia_in: number,\n  tireWidth_in: number,\n  v_fps: number,\n  ags_ftps2: number\n): {\n  /** Tire growth factor (1.0 = no growth, 1.05 = 5% growth) */\n  growth: number;\n  /** Tire squat factor (growth - squat under load) */\n  squat: number;\n  /** Effective tire diameter with growth and squat (inches) */\n  dia_eff_in: number;\n  /** Effective tire radius with growth and squat (feet) */\n  radius_eff_ft: number;\n  /** Effective tire circumference with growth and squat (feet) */\n  circumference_eff_ft: number;\n} {\n  const PI = Math.PI;\n  \n  // VB6: TGK = (gc_TireWidth.Value ^ 1.4 + TireDia - 16) / (0.171 * TireDia ^ 1.7)\n  const TGK = (Math.pow(tireWidth_in, 1.4) + tireDia_in - 16) / (0.171 * Math.pow(tireDia_in, 1.7));\n  \n  // VB6: TireGrowth = 1 + TGK * 0.0000135 * Vel(L) ^ 1.6\n  let tireGrowth = 1 + TGK * 0.0000135 * Math.pow(v_fps, 1.6);\n  \n  // VB6: TGLinear = 1 + TGK * 0.00035 * Vel(L)\n  // '0.00035 works better based on Motown Missile\n  const TGLinear = 1 + TGK * 0.00035 * v_fps;\n  \n  // VB6: If TGLinear < TireGrowth Then TireGrowth = TGLinear\n  if (TGLinear < tireGrowth) {\n    tireGrowth = TGLinear;\n  }\n  \n  // VB6: TireSQ = TireGrowth - 0.035 * Abs(Ags0)  'tire squat under load\n  // Convert ags_ftps2 to g's for squat calculation (VB6 Ags0 is in g's)\n  const ags_g = ags_ftps2 / 32.174;\n  const tireSQ = tireGrowth - 0.035 * Math.abs(ags_g);\n  \n  // VB6: TireCirFt = TireSQ * TireDia * PI / 12\n  const tireCirFt = tireSQ * tireDia_in * PI / 12;\n  \n  // Calculate effective diameter and radius\n  // VB6: TireRadIn = 12 * TireCirFt / (2 * PI)\n  const tireRadIn = 12 * tireCirFt / (2 * PI);\n  const dia_eff_in = 2 * tireRadIn;\n  const radius_eff_ft = tireRadIn / 12;\n  \n  return {\n    growth: tireGrowth,\n    squat: tireSQ,\n    dia_eff_in,\n    radius_eff_ft,\n    circumference_eff_ft: tireCirFt,\n  };\n}\n\n/**\n * Compute increased frontal area due to tire growth\n * \n * VB6: TIMESLIP.FRM:1184-1189\n * \n * If gc_BodyStyle.Value = 8 Then  ' Motorcycle\n *     RefArea2 = gc_RefArea.Value + ((TireGrowth - 1) * TireDia / 2) * gc_TireWidth.Value / 144\n * Else  ' Car (2 tires visible)\n *     RefArea2 = gc_RefArea.Value + ((TireGrowth - 1) * TireDia / 2) * (2 * gc_TireWidth.Value) / 144\n * End If\n * \n * @param baseRefArea_ft2 Base frontal area (ft²)\n * @param tireGrowth Tire growth factor (from computeTireGrowth)\n * @param tireDia_in Static tire diameter (inches)\n * @param tireWidth_in Tire width (inches)\n * @param isMotorcycle True for motorcycle (1 tire), false for car (2 tires)\n * @returns Effective frontal area with tire growth (ft²)\n */\nexport function computeRefAreaWithTireGrowth(\n  baseRefArea_ft2: number,\n  tireGrowth: number,\n  tireDia_in: number,\n  tireWidth_in: number,\n  isMotorcycle: boolean\n): number {\n  // VB6: ((TireGrowth - 1) * TireDia / 2) * gc_TireWidth.Value / 144\n  const tireGrowthArea_in2 = ((tireGrowth - 1) * tireDia_in / 2) * tireWidth_in;\n  \n  // Multiply by 2 for cars (both rear tires visible), 1 for motorcycles\n  const numTires = isMotorcycle ? 1 : 2;\n  const totalGrowthArea_in2 = tireGrowthArea_in2 * numTires;\n  \n  // Convert to ft² (divide by 144)\n  const totalGrowthArea_ft2 = totalGrowthArea_in2 / 144;\n  \n  // VB6: RefArea2 = gc_RefArea.Value + ...\n  return baseRefArea_ft2 + totalGrowthArea_ft2;\n}\n","/**\n * VB6 Gear Shift Logic\n * \n * VB6 Source: TIMESLIP.FRM:1355, 1433, 702-703, 722, 732, 1071-1072\n * \n * VB6 uses a two-step shift process:\n * 1. ShiftFlag = 1: Shift is triggered when EngRPM is within tolerance of ShiftRPM\n * 2. ShiftFlag = 2: Shift is executed on next iteration, then cleared\n * \n * During the shift, VB6 applies a \"dwell\" period (DTShift) where the vehicle coasts\n * with zero power. This simulates the time it takes to change gears.\n * \n * VB6 Shift Dwell Times (TIMESLIP.FRM:702-703, 722, 732):\n * - Clutch: DTShift = 0.2 seconds (200 ms)\n * - Converter: DTShift = 0.25 seconds (250 ms)\n */\n\nimport { F, f32 } from './exactMath';\n\n/**\n * Check if vehicle should shift to next gear\n * \n * VB6: TIMESLIP.FRM:860, 1355\n * ShiftRPMTol = 10: If ShiftRPM(1) > 8000 Then ShiftRPMTol = 20\n * If iGear < NGR And Abs(ShiftRPM(iGear) - EngRPM(L)) < ShiftRPMTol Then ShiftFlag = 1\n * \n * @param currentGear Current gear index (0-based, 0 = first gear)\n * @param numGears Total number of gears\n * @param engRPM Current engine RPM\n * @param shiftRPM Array of shift RPM thresholds (0-based, shiftRPM[0] = shift from 1st to 2nd)\n * @returns True if should shift to next gear\n */\nexport function shouldShift(\n  currentGear: number,\n  numGears: number,\n  engRPM: number,\n  shiftRPM: number[]\n): boolean {\n  // VB6: If iGear < NGR (can't shift from highest gear)\n  if (currentGear >= numGears - 1) {\n    return false;\n  }\n  \n  // Get shift RPM for current gear (0-based indexing)\n  const targetShiftRPM = shiftRPM[currentGear];\n  \n  // If no shift RPM defined for this gear, don't shift\n  if (!targetShiftRPM || targetShiftRPM <= 0) {\n    return false;\n  }\n  \n  // VB6: ShiftRPMTol = 10: If ShiftRPM(1) > 8000 Then ShiftRPMTol = 20\n  // Use first gear's shift RPM to determine tolerance\n  const firstGearShiftRPM = shiftRPM[0] ?? 0;\n  const shiftRPMTol = firstGearShiftRPM > 8000 ? 20 : 10;\n  \n  // VB6: Abs(ShiftRPM(iGear) - EngRPM(L)) < ShiftRPMTol\n  const rpmDiff = Math.abs(targetShiftRPM - engRPM);\n  \n  return rpmDiff < shiftRPMTol;\n}\n\n/**\n * VB6 shift state machine\n * \n * VB6 uses ShiftFlag to manage shift timing:\n * - ShiftFlag = 0: Normal operation\n * - ShiftFlag = 1: Shift triggered, will execute next step\n * - ShiftFlag = 2: Shift executing, will clear next step\n * \n * This ensures shifts happen at step boundaries.\n */\nexport enum ShiftState {\n  NORMAL = 0,\n  TRIGGERED = 1,\n  EXECUTING = 2,\n}\n\n/**\n * Update shift state machine\n * \n * VB6: TIMESLIP.FRM:1433-1434\n * If ShiftFlag = 1 Then ShiftFlag = 2: iGear = iGear + 1: LAdd = 1: GoTo 230\n * If ShiftFlag = 2 Then ShiftFlag = 0: LAdd = 1\n * \n * @param currentState Current shift state\n * @param shouldTrigger True if shift conditions are met\n * @returns New shift state and whether to execute shift\n */\nexport function updateShiftState(\n  currentState: ShiftState,\n  shouldTrigger: boolean\n): { newState: ShiftState; executeShift: boolean } {\n  switch (currentState) {\n    case ShiftState.NORMAL:\n      // If shift conditions met, trigger shift\n      if (shouldTrigger) {\n        return { newState: ShiftState.TRIGGERED, executeShift: false };\n      }\n      return { newState: ShiftState.NORMAL, executeShift: false };\n      \n    case ShiftState.TRIGGERED:\n      // Execute shift and move to executing state\n      return { newState: ShiftState.EXECUTING, executeShift: true };\n      \n    case ShiftState.EXECUTING:\n      // Clear shift state\n      return { newState: ShiftState.NORMAL, executeShift: false };\n      \n    default:\n      return { newState: ShiftState.NORMAL, executeShift: false };\n  }\n}\n\n/**\n * Get VB6 shift dwell time (no power window)\n * \n * VB6: TIMESLIP.FRM:702-703, 722, 732\n * DTShift = 0.2                                'Clutch shift time\n * If gc_TransType.Value Then DTShift = 0.25    'Converter shift time\n * \n * During this time, the vehicle coasts with zero engine power.\n * Only drag and rolling resistance act on the vehicle.\n * \n * @param isClutch True for clutch transmission, false for converter\n * @returns Shift dwell time in seconds\n */\nexport function vb6ShiftDwell_s(isClutch: boolean): number {\n  // VB6: DTShift = 0.2 for clutch, 0.25 for converter\n  return isClutch ? 0.2 : 0.25;\n}\n\n/**\n * VB6-STRICT: Check if should shift using >= operator.\n * \n * VB6 typically uses >= for the actual shift trigger:\n * If EngRPM >= ShiftRPM(iGear) Then shift\n * \n * This is different from the tolerance-based check which uses Abs().\n * For STRICT mode, we use the simpler >= check.\n * \n * @param engRPM Current engine RPM (Float32)\n * @param shiftRPM Shift RPM threshold for current gear\n * @param currentGear Current gear index (0-based)\n * @param maxGear Maximum gear index (numGears - 1)\n * @returns True if should shift\n */\nexport function shouldShift_f32(\n  engRPM: number,\n  shiftRPM: number,\n  currentGear: number,\n  maxGear: number\n): boolean {\n  // Can't shift from highest gear\n  if (currentGear >= maxGear) return false;\n  \n  // No shift point defined\n  if (!shiftRPM || shiftRPM <= 0) return false;\n  \n  // VB6-STRICT: Use >= operator (not tolerance-based)\n  // F.sub returns Float32, compare to 0\n  return F.sub(f32(engRPM), f32(shiftRPM)) >= 0;\n}\n","/**\n * VB6 Tire Slip Factor\n * \n * VB6 Source: TIMESLIP.FRM:872, 1100-1101\n * \n * Tire slip represents the difference between tire surface speed and vehicle speed.\n * It starts high at launch (tire deformation/spin) and decreases with distance.\n * \n * VB6 Formula (Quarter Jr/Pro):\n *   Initial: TireSlip = 1.02 + (TractionIndex - 1) * 0.005 + (TrackTempEffect - 1) * 3\n *   During run: Work = 0.005 * (TractionIndex - 1) + 3 * (TrackTempEffect - 1)\n *               TireSlip = 1.02 + Work * (1 - (Dist / 1320)^2)\n * \n * Where:\n * - TractionIndex: 1-5 (1=poor, 3=average, 5=excellent)\n * - TrackTempEffect: 1.0-1.04 based on track temperature\n * - Dist: Distance traveled (ft)\n * - TireSlip ≥ 1.0 (1.0 = no slip, >1.0 = tire spinning faster than vehicle)\n */\n\n/**\n * Calculate VB6 tire slip factor\n * \n * VB6: TIMESLIP.FRM:1100-1101\n * Work = 0.005 * (gc_TractionIndex.Value - 1) + 3 * (TrackTempEffect - 1)\n * TireSlip = 1.02 + Work * (1 - (Dist0 / 1320) ^ 2)\n * \n * @param distance_ft - Distance traveled (ft)\n * @param tractionIndex - Traction index (1-5, typically 3)\n * @param trackTempEffect - Track temperature effect (1.0-1.04, typically 1.0)\n * @returns Tire slip factor (≥1.0)\n */\nexport function tireSlipFactor(\n  distance_ft: number,\n  tractionIndex: number = 3,\n  trackTempEffect: number = 1.0\n): number {\n  // VB6: Work = 0.005 * (gc_TractionIndex.Value - 1) + 3 * (TrackTempEffect - 1)\n  const Work = 0.005 * (tractionIndex - 1) + 3 * (trackTempEffect - 1);\n  \n  // VB6: TireSlip = 1.02 + Work * (1 - (Dist0 / 1320) ^ 2)\n  const distRatio = distance_ft / 1320;\n  const TireSlip = 1.02 + Work * (1 - Math.pow(distRatio, 2));\n  \n  return TireSlip;\n}\n\n/**\n * Calculate initial tire slip at launch\n * \n * VB6: TIMESLIP.FRM:872\n * TireSlip = 1.02 + (gc_TractionIndex.Value - 1) * 0.005 + (TrackTempEffect - 1) * 3\n * \n * This is the same as tireSlipFactor(0, ...) but kept for clarity.\n * \n * @param tractionIndex - Traction index (1-5, typically 3)\n * @param trackTempEffect - Track temperature effect (1.0-1.04, typically 1.0)\n * @returns Initial tire slip factor at launch\n */\nexport function initialTireSlip(\n  tractionIndex: number = 3,\n  trackTempEffect: number = 1.0\n): number {\n  // VB6: TireSlip = 1.02 + (gc_TractionIndex.Value - 1) * 0.005 + (TrackTempEffect - 1) * 3\n  const TireSlip = 1.02 + (tractionIndex - 1) * 0.005 + (trackTempEffect - 1) * 3;\n  return TireSlip;\n}\n","/**\n * VB6 Longitudinal Weight Transfer\n * \n * VB6 Source: TIMESLIP.FRM:1037-1043, 1196-1211\n * \n * Weight transfer affects traction by changing the load on the rear tires.\n * VB6 calculates dynamic front weight based on:\n * - Acceleration (AGS in g's)\n * - CG height (YCG)\n * - Wheelbase\n * - Tire radius\n * - Driveline friction (FRCT)\n * - Drag force\n * \n * Dynamic rear weight = Total weight - Dynamic front weight - Wheelie bar weight\n */\n\n/**\n * Calculate dynamic weight transfer to front axle\n * \n * VB6: TIMESLIP.FRM:1037, 1199\n * deltaFWT = (Ags0 * gc_Weight.Value * ((gc_YCG.Value - TireRadIn) + (FRCT / gc_Efficiency.Value) * TireRadIn) + DragForce * gc_YCG.Value) / gc_Wheelbase.Value\n * \n * @param AGS_g - Acceleration in g's (VB6 stores AGS in g's, not ft/s²)\n * @param weight_lbf - Total vehicle weight (lb)\n * @param cg_height_in - CG height above ground (inches)\n * @param tire_radius_in - Tire radius (inches)\n * @param wheelbase_in - Wheelbase (inches)\n * @param drag_force_lbf - Drag force (lb)\n * @param frct - Driveline friction coefficient (typically 0.03-0.05)\n * @param driveline_eff - Overall driveline efficiency (typically 0.9-0.97)\n * @returns Weight transfer to front axle (lb)\n */\nexport function vb6WeightTransferToFront(\n  AGS_g: number,\n  weight_lbf: number,\n  cg_height_in: number,\n  tire_radius_in: number,\n  wheelbase_in: number,\n  drag_force_lbf: number,\n  frct: number = 0.04,\n  driveline_eff: number = 0.9\n): number {\n  // VB6: deltaFWT = (Ags0 * gc_Weight.Value * ((gc_YCG.Value - TireRadIn) + (FRCT / gc_Efficiency.Value) * TireRadIn) + DragForce * gc_YCG.Value) / gc_Wheelbase.Value\n  const accel_term = AGS_g * weight_lbf * ((cg_height_in - tire_radius_in) + (frct / driveline_eff) * tire_radius_in);\n  const drag_term = drag_force_lbf * cg_height_in;\n  const deltaFWT = (accel_term + drag_term) / wheelbase_in;\n  \n  return deltaFWT;\n}\n\n/**\n * Calculate dynamic rear weight with weight transfer\n * \n * VB6: TIMESLIP.FRM:1047, 1200-1211\n * \n * Static rear weight:\n *   StaticRWT = DownForce - gc_StaticFWt.Value\n *   If StaticRWT < 0 Then StaticRWT = gc_Weight.Value\n * \n * Dynamic calculation:\n *   DynamicFWT = gc_StaticFWt.Value - deltaFWT\n *   WheelBarWT = 0\n *   If DynamicFWT < 0 Then\n *       WheelBarWT = -DynamicFWT * gc_Wheelbase.Value / 64\n *       DynamicFWT = 0\n *   End If\n *   DynamicRWT = DownForce - DynamicFWT - WheelBarWT\n *   If DynamicRWT < 0 Then DynamicRWT = gc_Weight.Value\n * \n * @param weight_lbf - Total vehicle weight (lb)\n * @param static_front_weight_lbf - Static front weight (lb)\n * @param AGS_g - Acceleration in g's\n * @param cg_height_in - CG height above ground (inches)\n * @param tire_radius_in - Tire radius (inches)\n * @param wheelbase_in - Wheelbase (inches)\n * @param drag_force_lbf - Drag force (lb)\n * @param downforce_lbf - Total downforce (weight + aero, lb)\n * @param frct - Driveline friction coefficient\n * @param driveline_eff - Overall driveline efficiency\n * @returns Dynamic rear weight (lb)\n */\nexport function vb6RearWeightDynamic(\n  weight_lbf: number,\n  static_front_weight_lbf: number,\n  AGS_g: number,\n  cg_height_in: number,\n  tire_radius_in: number,\n  wheelbase_in: number,\n  drag_force_lbf: number,\n  downforce_lbf: number,\n  frct: number = 0.04,\n  driveline_eff: number = 0.9\n): { rear_weight_lbf: number; front_weight_lbf: number; wheelie_bar_weight_lbf: number } {\n  // VB6: TIMESLIP.FRM:1199\n  const deltaFWT = vb6WeightTransferToFront(\n    AGS_g,\n    weight_lbf,\n    cg_height_in,\n    tire_radius_in,\n    wheelbase_in,\n    drag_force_lbf,\n    frct,\n    driveline_eff\n  );\n  \n  // VB6: TIMESLIP.FRM:1200\n  let DynamicFWT = static_front_weight_lbf - deltaFWT;\n  \n  // VB6: TIMESLIP.FRM:1203-1208\n  // Wheelie bar calculation (assumes 64\" wheelie bar)\n  let WheelBarWT = 0;\n  if (DynamicFWT < 0) {\n    WheelBarWT = -DynamicFWT * wheelbase_in / 64;\n    DynamicFWT = 0;\n  }\n  \n  // VB6: TIMESLIP.FRM:1211\n  let DynamicRWT = downforce_lbf - DynamicFWT - WheelBarWT;\n  if (DynamicRWT < 0) {\n    DynamicRWT = weight_lbf;\n  }\n  \n  return {\n    rear_weight_lbf: DynamicRWT,\n    front_weight_lbf: DynamicFWT,\n    wheelie_bar_weight_lbf: WheelBarWT\n  };\n}\n\n/**\n * Calculate static rear weight (for initial conditions)\n * \n * VB6: TIMESLIP.FRM:1047\n * StaticRWT = DownForce - gc_StaticFWt.Value\n * If StaticRWT < 0 Then StaticRWT = gc_Weight.Value\n * \n * @param weight_lbf - Total vehicle weight (lb)\n * @param static_front_weight_lbf - Static front weight (lb)\n * @param downforce_lbf - Total downforce (weight + aero, lb)\n * @returns Static rear weight (lb)\n */\nexport function vb6StaticRearWeight(\n  weight_lbf: number,\n  static_front_weight_lbf: number,\n  downforce_lbf: number\n): number {\n  // VB6: StaticRWT = DownForce - gc_StaticFWt.Value\n  let StaticRWT = downforce_lbf - static_front_weight_lbf;\n  \n  // VB6: If StaticRWT < 0 Then StaticRWT = gc_Weight.Value\n  if (StaticRWT < 0) {\n    StaticRWT = weight_lbf;\n  }\n  \n  return StaticRWT;\n}\n","/**\n * VB6 EXACT Integrator Functions\n * \n * EXACT port from TIMESLIP.FRM lines 1040-1360\n * \n * VB6 uses a sophisticated integrator with:\n * - Adaptive timestep selection\n * - PMI iteration convergence (up to 12 iterations)\n * - Jerk limiting (±2 g/s)\n * - AMin/AMax clamping with PQWT rescaling\n * - Distance integration: Dist(L) = ((2*PQWT*(t-t0) + v0²)^1.5 - v0³) / (3*PQWT) + Dist0\n * \n * Key formulas:\n * - time(L) = VelSqrd / (2 * PQWT) + Time0\n * - AGS(L) = PQWT / (Vel(L) * gc)\n * - Jerk = (AGS(L) - Ags0) / dt\n * - Dist(L) = ((2*PQWT*dt + v0²)^1.5 - v0³) / (3*PQWT) + Dist0\n */\n\nimport { gc, JMin, JMax, K6, K61 } from './constants';\n\n/**\n * VB6 simulation state.\n */\nexport interface VB6State {\n  /** Time (seconds) */\n  t_s: number;\n  /** Distance (feet) */\n  s_ft: number;\n  /** Velocity (feet/second) */\n  v_fps: number;\n  /** Engine RPM */\n  engineRPM: number;\n  /** Current gear index (0-based) */\n  gearIndex: number;\n  /** Alias for engineRPM (for compatibility) */\n  rpm: number;\n  /** Alias for gearIndex (for compatibility) */\n  gearIdx: number;\n}\n\n/**\n * VB6 simulation parameters.\n */\nexport interface VB6Params {\n  /** \n   * Time step (seconds) - VB6 uses adaptive timestep\n   * Initial: TSMax = rollout * 0.11 * (HP * TorqueMult / Weight)^(-1/3) / 15\n   * Min: 0.005s (TIMESLIP.FRM:1064)\n   * Max: 0.05s (TIMESLIP.FRM:1120)\n   * Adaptive: TimeStep = TSMax * (AgsMax / Ags0)^4 (TIMESLIP.FRM:1082)\n   * \n   * For our fixed-timestep implementation, use 0.002s as a reasonable compromise\n   * that matches VB6's TimeTol = 0.002 (TIMESLIP.FRM:554)\n   */\n  dt_s: number;\n  /** Rollout distance (feet) */\n  rolloutFt: number;\n  /** Tire radius (feet) */\n  tireRadiusFt: number;\n  /** Final drive ratio */\n  finalDrive: number;\n  /** Gear ratios (array, 0-based) */\n  gearRatios: number[];\n  /** Transmission efficiency per gear (optional, default 0.92-0.96) */\n  transEffPerGear?: number[];\n  /** Shift RPM for each gear (array, 0-based) */\n  shiftRpm: number[];\n  /** Shift delay (seconds, optional, default 0) */\n  shiftDelay_s?: number;\n  /** Traction cap (lbf, optional, undefined = no cap) */\n  tractionCapLbf?: number;\n  /** Vehicle mass (slugs) */\n  massSlug: number;\n}\n\n/**\n * VB6 integration step (forward Euler).\n * \n * TODO: Replace with exact VB6 integration method once QTRPERF.BAS is ported.\n * Current implementation uses simple forward Euler: dv = a*dt, ds = v*dt\n * \n * @param state - Current simulation state\n * @param params - Simulation parameters\n * @param wheelTorqueLbFt - Wheel torque (lb-ft)\n * @param dragTorqueLbFt - Drag torque (lb-ft)\n * @param rrTorqueLbFt - Rolling resistance torque (lb-ft)\n * @returns Updated state\n */\nexport function vb6Step(\n  state: VB6State,\n  params: VB6Params,\n  wheelTorqueLbFt: number,\n  dragTorqueLbFt: number,\n  rrTorqueLbFt: number\n): VB6State {\n  const { dt_s, tireRadiusFt, massSlug, tractionCapLbf } = params;\n\n  // Net torque at wheel\n  const T_net = wheelTorqueLbFt - dragTorqueLbFt - rrTorqueLbFt;\n\n  // Convert torque to force at wheel\n  const F_wheel = T_net / tireRadiusFt;\n\n  // Apply traction cap if specified\n  const F_trac = tractionCapLbf !== undefined \n    ? Math.min(Math.max(0, F_wheel), tractionCapLbf)\n    : Math.max(0, F_wheel);\n\n  // TODO: Verify VB6 uses F = ma or includes rotational inertia\n  // Acceleration: a = F / m\n  const a_fps2 = F_trac / massSlug;\n\n  // TODO: Verify VB6 integration method (Euler vs RK2 vs RK4)\n  // Forward Euler integration\n  const v_new = state.v_fps + a_fps2 * dt_s;\n  \n  // TODO: Check if VB6 uses ds = v*dt or ds = v*dt + 0.5*a*dt^2\n  // Position update (simple Euler)\n  const s_new = state.s_ft + state.v_fps * dt_s;\n  \n  // Time update\n  const t_new = state.t_s + dt_s;\n\n  // TODO: Verify VB6 RPM calculation from wheel speed\n  // Calculate engine RPM from wheel speed\n  const gearRatio = params.gearRatios[state.gearIndex];\n  const wheelRPM = (v_new * 60) / (2 * Math.PI * tireRadiusFt);\n  const engineRPM = wheelRPM * gearRatio * params.finalDrive;\n\n  return {\n    t_s: t_new,\n    s_ft: s_new,\n    v_fps: v_new,\n    engineRPM: engineRPM,\n    gearIndex: state.gearIndex, // Gear shifts handled externally\n    rpm: engineRPM, // Alias\n    gearIdx: state.gearIndex, // Alias\n  };\n}\n\n/**\n * Check if gear shift should occur.\n * \n * VB6 Source: TIMESLIP.FRM lines 1336-1340, 1355, 1433\n * \n * VB6 Algorithm:\n * 1. Check if within tolerance of shift RPM: Abs(ShiftRPM - EngRPM) < ShiftRPMTol\n * 2. ShiftRPMTol = 10 (or 20 if ShiftRPM > 8000)\n * 3. Set ShiftFlag = 1 when within tolerance\n * 4. Execute shift: iGear = iGear + 1\n * \n * @param state - Current simulation state\n * @param params - Simulation parameters\n * @returns New gear index (same if no shift)\n */\nexport function vb6CheckShift(\n  state: VB6State,\n  params: VB6Params\n): number {\n  const { gearIndex, engineRPM } = state;\n  const { shiftRpm, gearRatios } = params;\n\n  // Don't shift if already in top gear\n  if (gearIndex >= gearRatios.length - 1) {\n    return gearIndex;\n  }\n\n  // VB6: TIMESLIP.FRM:860\n  // ShiftRPMTol = 10: If ShiftRPM(1) > 8000 Then ShiftRPMTol = 20\n  const ShiftRPMTol = shiftRpm[0] > 8000 ? 20 : 10;\n\n  // VB6: TIMESLIP.FRM:1336-1340, 1355\n  // If Abs(ShiftRPM(iGear) - EngRPM(L)) < ShiftRPMTol Then ShiftFlag = 1\n  const targetShiftRPM = shiftRpm[gearIndex];\n  if (targetShiftRPM !== undefined && Math.abs(targetShiftRPM - engineRPM) < ShiftRPMTol) {\n    // VB6: TIMESLIP.FRM:1433\n    // If ShiftFlag = 1 Then ShiftFlag = 2: iGear = iGear + 1\n    return gearIndex + 1;\n  }\n\n  return gearIndex;\n}\n\n/**\n * Create initial VB6 state.\n * \n * @param initialRPM - Initial engine RPM (e.g., launch RPM)\n * @returns Initial state\n */\nexport function vb6InitialState(initialRPM: number = 0): VB6State {\n  return {\n    t_s: 0,\n    s_ft: 0,\n    v_fps: 0,\n    engineRPM: initialRPM,\n    gearIndex: 0,\n    rpm: initialRPM, // Alias\n    gearIdx: 0, // Alias\n  };\n}\n\n// ===== EXACT VB6 INTEGRATOR FUNCTIONS =====\n\n/**\n * EXACT VB6 Distance Integration\n * \n * VB6: TIMESLIP.FRM:1280\n * Dist(L) = ((2 * PQWT * (time(L) - Time0) + Vel0 ^ 2) ^ 1.5 - Vel0 ^ 3) / (3 * PQWT) + Dist0\n * \n * This is the exact VB6 distance formula derived from constant acceleration:\n * - Assumes PQWT (power-to-weight-time) is constant over the timestep\n * - Integrates velocity: v = sqrt(v0² + 2*a*s) where a = PQWT/v\n * - Result: distance as function of time under power constraint\n * \n * @param Vel0_ftps Previous velocity (ft/s)\n * @param Dist0_ft Previous distance (ft)\n * @param dt_s Time step (s)\n * @param PQWT_ftps2 Power-to-weight-time parameter (ft/s²)\n * @returns Updated velocity and distance\n */\nexport function vb6StepDistance(\n  Vel0_ftps: number,\n  Dist0_ft: number,\n  dt_s: number,\n  PQWT_ftps2: number\n): { Vel_ftps: number; Dist_ft: number } {\n  // VB6: TIMESLIP.FRM:1139\n  // VelSqrd = Vel(L) ^ 2 - Vel0 ^ 2\n  // But we need to compute Vel(L) first from time\n  \n  // VB6: TIMESLIP.FRM:1268 (or 1229 first pass)\n  // time(L) = VelSqrd / (2 * PQWT) + Time0\n  // Rearranging: VelSqrd = 2 * PQWT * dt\n  // Therefore: Vel(L) = sqrt(Vel0² + 2 * PQWT * dt)\n  const VelSqrd = 2 * PQWT_ftps2 * dt_s;\n  const Vel_ftps = Math.sqrt(Vel0_ftps * Vel0_ftps + VelSqrd);\n  \n  // VB6: TIMESLIP.FRM:1280\n  // Dist(L) = ((2 * PQWT * (time(L) - Time0) + Vel0 ^ 2) ^ 1.5 - Vel0 ^ 3) / (3 * PQWT) + Dist0\n  const term1 = 2 * PQWT_ftps2 * dt_s + Vel0_ftps * Vel0_ftps;\n  const term2 = Math.pow(term1, 1.5);\n  const term3 = Math.pow(Vel0_ftps, 3);\n  const Dist_ft = (term2 - term3) / (3 * PQWT_ftps2) + Dist0_ft;\n  \n  return { Vel_ftps, Dist_ft };\n}\n\n/**\n * EXACT VB6 Timestep Selection\n * \n * VB6: TIMESLIP.FRM:1082, 1112-1120\n * \n * Adaptive timestep based on acceleration:\n * TimeStep = TSMax * (AgsMax / Ags0) ^ 4\n * \n * With bounds:\n * - Min: 0.005s (TIMESLIP.FRM:1064)\n * - Max: 0.05s (TIMESLIP.FRM:1120)\n * - Also limited by K7 steps per print interval\n * - Also limited by 4.5 steps to distance print\n * \n * @param proposed_dt_s Proposed timestep (s)\n * @returns Clamped timestep (s)\n */\nexport function vb6SelectTimeStep(\n  proposed_dt_s: number\n): number {\n  // VB6: TIMESLIP.FRM:1120\n  // If TimeStep > 0.05 Then TimeStep = 0.05\n  let dt = proposed_dt_s;\n  if (dt > 0.05) {\n    dt = 0.05;\n  }\n  \n  // VB6: TIMESLIP.FRM:1064\n  // TSMax = TSMax / 15: If TSMax < 0.005 Then TSMax = 0.005\n  if (dt < 0.005) {\n    dt = 0.005;\n  }\n  \n  return dt;\n}\n\n/**\n * EXACT VB6 Acceleration Clamp with PQWT Rescaling\n * \n * VB6: TIMESLIP.FRM:1224-1228, 1262-1266\n * \n * VB6 applies AMin/AMax clamps AND rescales PQWT to maintain consistency:\n * \n * If AGS > AMAX:\n *   SLIP = 1\n *   PQWT = PQWT * (AMAX - (AGS - AMAX)) / AGS\n *   AGS = AMAX - (AGS - AMAX)\n * \n * If AGS < AMin:\n *   PQWT = PQWT * AMin / AGS\n *   AGS = AMin\n * \n * Note: The AMAX formula is unusual - it's not just AGS = AMAX, but includes\n * a correction term that accounts for how far over AMAX we went.\n * \n * @param AGS_candidate_ftps2 Candidate acceleration (ft/s²)\n * @param AMin_ftps2 Minimum acceleration (ft/s²)\n * @param AMax_ftps2 Maximum acceleration (ft/s²)\n * @returns Clamped acceleration and slip flag\n */\nexport function vb6ApplyAccelClamp(\n  AGS_candidate_ftps2: number,\n  AMin_ftps2: number,\n  AMax_ftps2: number\n): { AGS_ftps2: number; PQWT_scale: number; slip: 0 | 1 } {\n  let AGS = AGS_candidate_ftps2;\n  let PQWT_scale = 1.0;\n  let slip: 0 | 1 = 0;\n  \n  // VB6: TIMESLIP.FRM:1224-1227 (or 1262-1264)\n  // If AGS(L) > AMAX Then\n  //     SLIP(L) = 1\n  //     PQWT = PQWT * (AMAX - (AGS(L) - AMAX)) / AGS(L):    AGS(L) = AMAX - (AGS(L) - AMAX)\n  // End If\n  if (AGS > AMax_ftps2) {\n    slip = 1;\n    const overshoot = AGS - AMax_ftps2;\n    const corrected_AMAX = AMax_ftps2 - overshoot;\n    PQWT_scale = corrected_AMAX / AGS;\n    AGS = corrected_AMAX;\n  }\n  \n  // VB6: TIMESLIP.FRM:1228 (or 1266)\n  // If AGS(L) < AMin Then PQWT = PQWT * AMin / AGS(L):          AGS(L) = AMin\n  if (AGS < AMin_ftps2) {\n    PQWT_scale = AMin_ftps2 / AGS;\n    AGS = AMin_ftps2;\n  }\n  \n  return { AGS_ftps2: AGS, PQWT_scale, slip };\n}\n\n/**\n * EXACT VB6 AGS from PQWT\n * \n * VB6: TIMESLIP.FRM:1221, 1253\n * AGS(L) = PQWT / (Vel(L) * gc)\n * \n * @param PQWT_ftps2 Power-to-weight-time parameter (ft/s²)\n * @param Vel_ftps Velocity (ft/s)\n * @returns Acceleration (ft/s²)\n */\nexport function vb6AGSFromPQWT(\n  PQWT_ftps2: number,\n  Vel_ftps: number\n): number {\n  // VB6: TIMESLIP.FRM:1221, 1253\n  // AGS(L) = PQWT / (Vel(L) * gc)\n  return PQWT_ftps2 / (Vel_ftps * gc);\n}\n\n/**\n * EXACT VB6 PQWT from HP\n * \n * VB6: TIMESLIP.FRM:1221, 1252\n * PQWT = 550 * gc * HP / gc_Weight.Value\n * \n * @param HP Horsepower\n * @param Weight_lbf Vehicle weight (lbf)\n * @returns PQWT (ft/s²)\n */\nexport function vb6PQWTFromHP(\n  HP: number,\n  Weight_lbf: number\n): number {\n  // VB6: TIMESLIP.FRM:1221, 1252\n  // PQWT = 550 * gc * HP / gc_Weight.Value\n  return 550 * gc * HP / Weight_lbf;\n}\n\n/**\n * EXACT VB6 Jerk Calculation\n * \n * VB6: TIMESLIP.FRM:1256\n * Jerk = (AGS(L) - Ags0) / dtk1\n * \n * Units: g/s (where g = 32.174 ft/s²)\n * \n * @param AGS_current_ftps2 Current acceleration (ft/s²)\n * @param AGS_prev_ftps2 Previous acceleration (ft/s²)\n * @param dt_s Time step (s)\n * @returns Jerk (g/s)\n */\nexport function vb6Jerk(\n  AGS_current_ftps2: number,\n  AGS_prev_ftps2: number,\n  dt_s: number\n): number {\n  // VB6: TIMESLIP.FRM:1256\n  // Jerk = 0:   If dtk1 <> 0 Then Jerk = (AGS(L) - Ags0) / dtk1\n  if (dt_s === 0) {\n    return 0;\n  }\n  \n  // Jerk in g/s\n  return (AGS_current_ftps2 - AGS_prev_ftps2) / (dt_s * gc);\n}\n\n/**\n * VB6 Adaptive Timestep Calculation\n * \n * VB6: TIMESLIP.FRM:1082\n * TimeStep = TSMax * (AgsMax / Ags0) ^ 4\n * \n * With bounds (TIMESLIP.FRM:1064, 1120):\n * - Min: 0.005s\n * - Max: 0.05s\n * \n * @param TSMax Base timestep (from rollout calculation)\n * @param AgsMax Maximum acceleration seen (g's)\n * @param Ags0 Current acceleration (g's)\n * @returns Adaptive timestep (s)\n */\nexport function vb6AdaptiveTimestep(\n  TSMax: number,\n  AgsMax_g: number,\n  Ags0_g: number\n): number {\n  // VB6: TimeStep = TSMax * (AgsMax / Ags0) ^ 4\n  // Guard against division by zero or negative\n  if (Ags0_g <= 0) {\n    return Math.max(0.005, Math.min(0.05, TSMax));\n  }\n  \n  let TimeStep = TSMax * Math.pow(AgsMax_g / Ags0_g, 4);\n  \n  // VB6: TIMESLIP.FRM:1120\n  // If TimeStep > 0.05 Then TimeStep = 0.05\n  if (TimeStep > 0.05) {\n    TimeStep = 0.05;\n  }\n  \n  // VB6: TIMESLIP.FRM:1064\n  // If TSMax < 0.005 Then TSMax = 0.005\n  if (TimeStep < 0.005) {\n    TimeStep = 0.005;\n  }\n  \n  return TimeStep;\n}\n\n/**\n * VB6 Initial TSMax Calculation\n * \n * VB6: TIMESLIP.FRM:1063-1064\n * TSMax = DistToPrint(1) * 0.11 * (HP * gc_TorqueMult.Value / gc_Weight.Value) ^ (-1 / 3)\n * TSMax = TSMax / 15: If TSMax < 0.005 Then TSMax = 0.005\n * \n * @param rollout_ft Rollout distance (ft)\n * @param HP Engine HP\n * @param torqueMult Torque multiplier (1.0 for clutch, 1.5-2.5 for converter)\n * @param weight_lbf Vehicle weight (lbf)\n * @returns TSMax (s)\n */\nexport function vb6CalcTSMax(\n  rollout_ft: number,\n  HP: number,\n  torqueMult: number,\n  weight_lbf: number\n): number {\n  // VB6: TSMax = DistToPrint(1) * 0.11 * (HP * gc_TorqueMult.Value / gc_Weight.Value) ^ (-1 / 3)\n  const powerToWeight = HP * torqueMult / weight_lbf;\n  let TSMax = rollout_ft * 0.11 * Math.pow(powerToWeight, -1/3);\n  \n  // VB6: TSMax = TSMax / 15\n  TSMax = TSMax / 15;\n  \n  // VB6: If TSMax < 0.005 Then TSMax = 0.005\n  if (TSMax < 0.005) {\n    TSMax = 0.005;\n  }\n  \n  return TSMax;\n}\n\n/**\n * VB6 Iterative Convergence Loop\n * \n * VB6: TIMESLIP.FRM:1244-1276 (label 280)\n * \n * This is the core VB6 iteration that converges PMI and time calculations.\n * It iterates up to 12 times or until time converges within 0.01%.\n * \n * @param params Iteration parameters\n * @returns Converged values\n */\nexport interface VB6IterationParams {\n  // Previous step values\n  Vel0_ftps: number;      // Previous velocity (ft/s)\n  Ags0_g: number;         // Previous acceleration (g's)\n  Time0_s: number;        // Previous time (s)\n  \n  // Current step values\n  Vel_ftps: number;       // Current velocity (ft/s)\n  VelSqrd: number;        // Vel² - Vel0² (ft²/s²)\n  \n  // Engine/PMI values (pre-computed, don't change during iteration)\n  HPSave: number;         // Engine HP before PMI\n  ClutchSlip: number;     // Clutch/converter coupling\n  TGEff: number;          // Transmission efficiency\n  Efficiency: number;     // Overall driveline efficiency\n  TireSlip: number;       // Tire slip factor\n  DragHP: number;         // Drag HP\n  EngAccHP: number;       // Engine acceleration HP (before Work factor)\n  ChasAccHP: number;      // Chassis acceleration HP (before Work factor)\n  \n  // Limits\n  AMin_g: number;         // Minimum acceleration (g's)\n  AMax_g: number;         // Maximum acceleration (g's)\n  \n  // Vehicle\n  Weight_lbf: number;     // Vehicle weight (lbf)\n}\n\nexport interface VB6IterationResult {\n  HP: number;             // Final HP after losses\n  PQWT_ftps2: number;     // Power-to-weight-time (ft/s²)\n  AGS_g: number;          // Acceleration (g's)\n  time_s: number;         // Converged time (s)\n  dt_s: number;           // Converged timestep (s)\n  HPEngPMI: number;       // Engine PMI HP loss\n  HPChasPMI: number;      // Chassis PMI HP loss\n  slip: boolean;          // True if traction limited\n  iterations: number;     // Number of iterations used\n}\n\nexport function vb6IterateConvergence(params: VB6IterationParams): VB6IterationResult {\n  const {\n    Ags0_g, Time0_s,\n    Vel_ftps, VelSqrd,\n    HPSave, ClutchSlip, TGEff, Efficiency, TireSlip, DragHP,\n    EngAccHP, ChasAccHP,\n    AMin_g, AMax_g,\n    Weight_lbf\n  } = params;\n  // Note: Vel0_ftps is in params but not used directly - VelSqrd already computed\n  \n  const PI = Math.PI;\n  \n  // Initial time estimate (from velocity step)\n  // VB6: time(L) = VelSqrd / (2 * PQWT) + Time0\n  // But we need initial PQWT estimate - use simple forward Euler\n  let time_s = Time0_s + 0.002; // Initial guess\n  let dtk1 = time_s - Time0_s;\n  \n  let HP = 0;\n  let PQWT = 0;\n  let AGS_g = Ags0_g;\n  let HPEngPMI = 0;\n  let HPChasPMI = 0;\n  let slip = false;\n  let k = 0;\n  \n  // VB6: TIMESLIP.FRM:1244-1276 (iteration loop)\n  for (k = 1; k <= 12; k++) {\n    // VB6: TIMESLIP.FRM:1247\n    // Work = (2 * PI / 60) ^ 2 / (12 * 550 * dtk1)\n    const Work = Math.pow(2 * PI / 60, 2) / (12 * 550 * dtk1);\n    \n    // VB6: TIMESLIP.FRM:1248\n    // HPEngPMI = EngAccHP * Work:    HPChasPMI = ChasAccHP * Work\n    HPEngPMI = EngAccHP * Work;\n    HPChasPMI = ChasAccHP * Work;\n    \n    // VB6: TIMESLIP.FRM:1250-1251\n    // HP = (HPSave - HPEngPMI) * ClutchSlip\n    // HP = ((HP * TGEff(iGear) * gc_Efficiency.Value - HPChasPMI) / TireSlip) - DragHP\n    HP = (HPSave - HPEngPMI) * ClutchSlip;\n    HP = ((HP * TGEff * Efficiency - HPChasPMI) / TireSlip) - DragHP;\n    \n    // VB6: TIMESLIP.FRM:1252-1253\n    // PQWT = 550 * gc * HP / gc_Weight.Value\n    // AGS(L) = PQWT / (Vel(L) * gc)\n    PQWT = 550 * gc * HP / Weight_lbf;\n    AGS_g = PQWT / (Vel_ftps * gc);\n    \n    // VB6: TIMESLIP.FRM:1255-1258\n    // Apply jerk limits\n    let Jerk = 0;\n    if (dtk1 !== 0) {\n      Jerk = (AGS_g - Ags0_g) / dtk1;\n    }\n    if (Jerk < JMin) {\n      Jerk = JMin;\n      AGS_g = Ags0_g + Jerk * dtk1;\n      PQWT = AGS_g * gc * Vel_ftps;\n    }\n    if (Jerk > JMax) {\n      Jerk = JMax;\n      AGS_g = Ags0_g + Jerk * dtk1;\n      PQWT = AGS_g * gc * Vel_ftps;\n    }\n    \n    // VB6: TIMESLIP.FRM:1260-1266\n    // Apply AMin/AMax clamps\n    slip = false;\n    if (AGS_g > AMax_g) {\n      slip = true;\n      PQWT = PQWT * (AMax_g - (AGS_g - AMax_g)) / AGS_g;\n      AGS_g = AMax_g - (AGS_g - AMax_g);\n    }\n    if (AGS_g < AMin_g) {\n      PQWT = PQWT * AMin_g / AGS_g;\n      AGS_g = AMin_g;\n    }\n    \n    // VB6: TIMESLIP.FRM:1268-1270\n    // time(L) = VelSqrd / (2 * PQWT) + Time0\n    // dtk2 = time(L) - Time0\n    // If k = 12 Or Abs(100 * (dtk2 - dtk1) / dtk2) <= 0.01 Then GoTo 300\n    const newTime = VelSqrd / (2 * PQWT) + Time0_s;\n    const dtk2 = newTime - Time0_s;\n    \n    // Check convergence\n    if (k === 12 || Math.abs(100 * (dtk2 - dtk1) / dtk2) <= 0.01) {\n      time_s = newTime;\n      break;\n    }\n    \n    // VB6: TIMESLIP.FRM:1272-1275\n    // z = HP / HPSave\n    // If z < K6 Then z = K6\n    // If z > K61 Then z = K61\n    // time(L) = Time0 + dtk1 + z * (dtk2 - dtk1)\n    let z = HP / HPSave;\n    if (z < K6) z = K6;\n    if (z > K61) z = K61;\n    time_s = Time0_s + dtk1 + z * (dtk2 - dtk1);\n    dtk1 = time_s - Time0_s;\n  }\n  \n  return {\n    HP,\n    PQWT_ftps2: PQWT,\n    AGS_g,\n    time_s,\n    dt_s: time_s - Time0_s,\n    HPEngPMI,\n    HPChasPMI,\n    slip,\n    iterations: k\n  };\n}\n","/**\n * RSACLASSIC physics model implementation.\n * Fixed-step forward integration with traction cap, shifts, and timeslip outputs.\n */\n\nimport type { PhysicsModel, PhysicsModelId, SimInputs, SimResult } from '../index';\nimport { wheelTorque_lbft, power_hp_atRPM } from '../engine/engine';\nimport { rpmFromSpeed } from '../drivetrain/drivetrain';\n// import { drag_lb } from '../aero/drag'; // Replaced with direct calculation\n// import { rolling_lb } from '../aero/rolling'; // Replaced with direct calculation\n// import { maxTractive_lb, type TireParams } from '../tire/traction'; // Replaced with VB6 traction\nimport { createInitialState } from '../core/integrator';\nimport { lbToSlug } from '../core/units';\nimport { g, FPS_TO_MPH, CMU, gc, AMin, JMin, JMax } from '../vb6/constants';\nimport { computeAgs0 } from '../vb6/bootstrap';\n// import { hpToTorqueLbFt } from '../vb6/convert'; // No longer needed - using hpPts directly\nimport { airDensityVB6, type FuelSystemType } from '../vb6/air';\nimport { vb6RollingResistanceTorque } from '../vb6/forces';\nimport { vb6DirectDrive, vb6ConverterCoupling } from '../vb6/driveline';\nimport { computeAMaxVB6, computeAMinVB6, computeCAXI, clampAGSVB6, computeCRTF } from '../vb6/traction';\nimport { hpEngPMI, hpChasPMI, computeChassisPMI, computeDSRPM } from '../vb6/pmi';\nimport { computeTireGrowth, computeRefAreaWithTireGrowth } from '../vb6/tire';\nimport { shouldShift, shouldShift_f32, updateShiftState, ShiftState, vb6ShiftDwell_s } from '../vb6/shift';\nimport { tireSlipFactor } from '../vb6/tireslip';\nimport { vb6RearWeightDynamic } from '../vb6/weight_transfer';\nimport { \n  vb6StepDistance, \n  vb6ApplyAccelClamp, \n  vb6AGSFromPQWT,\n  vb6AdaptiveTimestep,\n  vb6CalcTSMax\n} from '../vb6/integrator';\n// VB6-STRICT: Float32 math helpers for exact parity\nimport { F, f32, vb6Round, tableLookupF32 } from '../vb6/exactMath';\n\n// === Engine params normalization (resolve once) ===\ntype PowerPt = { rpm: number; hp: number };\n\n/**\n * Map fuel string to VB6 fuel system type.\n * VB6 gc_FuelSystem.Value: 1-9\n */\nfunction getFuelSystemType(fuel: string | undefined): FuelSystemType {\n  if (!fuel) return 1; // Default: Gas + Carb\n  \n  const f = fuel.toUpperCase();\n  \n  // Check for supercharger first\n  if (f.includes('SUPERCHARG') || f.includes('BLOWN')) {\n    if (f.includes('NITRO')) return 8;      // Nitro + Supercharger\n    if (f.includes('METHANOL') || f.includes('ALCOHOL')) return 7; // Methanol + Supercharger\n    return 6; // Gas + Supercharger\n  }\n  \n  // Check for injector\n  if (f.includes('INJECT') || f.includes('EFI') || f.includes('FUEL INJECT')) {\n    if (f.includes('NITRO')) return 5;      // Nitro + Injector\n    if (f.includes('METHANOL') || f.includes('ALCOHOL')) return 4; // Methanol + Injector\n    return 2; // Gas + Injector\n  }\n  \n  // Carbureted (default)\n  if (f.includes('NITRO')) return 5;        // Nitro + Injector (nitro usually injected)\n  if (f.includes('METHANOL') || f.includes('ALCOHOL')) return 3; // Methanol + Carb\n  \n  // Electric\n  if (f.includes('ELECTRIC')) return 9;\n  \n  return 1; // Gas + Carb (default)\n}\n\n/**\n * Convert torque curve point to HP.\n * If point has hp, use it directly. If point has torque, compute hp = torque * rpm / 5252.\n */\nfunction torquePtToHP(pt: any, mult: number): PowerPt | null {\n  const rpm = Number(pt?.rpm);\n  if (!Number.isFinite(rpm)) return null;\n  \n  // If hp is present, use it directly\n  if (Number.isFinite(pt?.hp)) {\n    return { rpm, hp: Number(pt.hp) * mult };\n  }\n  // If torque is present, convert: hp = torque * rpm / 5252\n  if (Number.isFinite(pt?.torque)) {\n    const hp = (Number(pt.torque) * rpm / 5252) * mult;\n    return { rpm, hp };\n  }\n  // Also check tq_lbft alias\n  if (Number.isFinite(pt?.tq_lbft)) {\n    const hp = (Number(pt.tq_lbft) * rpm / 5252) * mult;\n    return { rpm, hp };\n  }\n  return null;\n}\n\nfunction asPowerPtsFromTuple(arr: any[], mult = 1): PowerPt[] {\n  return arr\n    .map((pt) => {\n      if (Array.isArray(pt)) {\n        // [rpm, hp] tuple format\n        return { rpm: Number(pt[0]), hp: Number(pt[1]) * mult };\n      }\n      // Object format - try hp first, then torque conversion\n      return torquePtToHP(pt, mult);\n    })\n    .filter((p): p is PowerPt => p !== null && Number.isFinite(p.rpm) && Number.isFinite(p.hp))\n    .sort((a, b) => a.rpm - b.rpm);\n}\n\nfunction resolveEngineParams(input: any): { powerHP: PowerPt[] } {\n  // Fuel multiplier applies to all sources\n  const mult = input?.fuel?.hpTorqueMultiplier ?? 1;\n  \n  // Track what we found for error message\n  const sources: string[] = [];\n  \n  // 1) Already normalized in engineParams.powerHP?\n  const hpA = input?.engineParams?.powerHP;\n  if (Array.isArray(hpA)) {\n    sources.push(`engineParams.powerHP(${hpA.length})`);\n    if (hpA.length >= 2) {\n      const powerHP = asPowerPtsFromTuple(hpA, mult);\n      if (powerHP.length >= 2) return { powerHP };\n    }\n  }\n  \n  // 2) VB6 tuple/object source (engineHP)?\n  const vb6 = input?.engineHP;\n  if (Array.isArray(vb6)) {\n    sources.push(`engineHP(${vb6.length})`);\n    if (vb6.length >= 2) {\n      const powerHP = asPowerPtsFromTuple(vb6, mult);\n      if (powerHP.length >= 2) return { powerHP };\n    }\n  }\n  \n  // 3) engineParams.torqueCurve (hp or torque points)?\n  const epTc = input?.engineParams?.torqueCurve;\n  if (Array.isArray(epTc)) {\n    sources.push(`engineParams.torqueCurve(${epTc.length})`);\n    if (epTc.length >= 2) {\n      const powerHP = asPowerPtsFromTuple(epTc, mult);\n      if (powerHP.length >= 2) return { powerHP };\n    }\n  }\n  \n  // 4) vehicle.torqueCurve (hp or torque points)?\n  const tc = input?.vehicle?.torqueCurve;\n  if (Array.isArray(tc)) {\n    sources.push(`vehicle.torqueCurve(${tc.length})`);\n    if (tc.length >= 2) {\n      const powerHP = asPowerPtsFromTuple(tc, mult);\n      if (powerHP.length >= 2) return { powerHP };\n    }\n  }\n  \n  // 5) vehicle.hpCurve (UI schema format - array of {rpm, hp})\n  const hpc = input?.vehicle?.hpCurve;\n  if (Array.isArray(hpc)) {\n    sources.push(`vehicle.hpCurve(${hpc.length})`);\n    if (hpc.length >= 2) {\n      const powerHP = asPowerPtsFromTuple(hpc, mult);\n      if (powerHP.length >= 2) return { powerHP };\n    }\n  }\n  \n  // Fail with context showing all sources found\n  throw new Error(\n    `RSACLASSIC: missing power curve. Sources found: [${sources.join(', ') || 'none'}]. ` +\n    `Keys(engineParams)=${JSON.stringify(Object.keys(input?.engineParams || {}))} ` +\n    `Keys(vehicle)=${JSON.stringify(Object.keys(input?.vehicle || {}))}`\n  );\n}\n\n/**\n * Guard against NaN: return fallback if x is not finite.\n */\nfunction finite(x: any, fallback = 0): number {\n  return Number.isFinite(x) ? Number(x) : fallback;\n}\n\n/**\n * VB6-STRICT HP interpolation using Float32.\n * Converts PowerPt[] to [rpm, hp][] table and uses tableLookupF32.\n */\nfunction hpAtRPM_f32(rpm: number, hpPts: PowerPt[]): number {\n  const table: [number, number][] = hpPts.map(p => [p.rpm, p.hp]);\n  return tableLookupF32(rpm, table);\n}\n\n/**\n * VB6-STRICT wheel torque using Float32.\n * torque = hp * 5252 / rpm, then apply gear efficiency\n */\nfunction wheelTorque_f32(rpm: number, hpPts: PowerPt[], gearEff: number): number {\n  const hp = hpAtRPM_f32(rpm, hpPts);\n  if (rpm <= 0) return f32(0);\n  // VB6: TQ = Z6 * HP / EngRPM where Z6 = 5252\n  const tq = F.div(F.mul(f32(5252), hp), f32(rpm));\n  return F.mul(tq, f32(gearEff));\n}\n\n/**\n * Clamp value to range [lo, hi], return fallback if not finite.\n */\nfunction clampFinite(x: any, lo: number, hi: number, fallback = lo): number {\n  const v = Number(x);\n  if (!Number.isFinite(v)) return fallback;\n  return Math.min(hi, Math.max(lo, v));\n}\n\n/**\n * Clamp efficiency to valid range [0.85, 1.0].\n */\nfunction clamp01(x: number): number {\n  return Math.max(0.85, Math.min(1.0, x));\n}\n\n/**\n * Optional tuning parameters for parity adjustment.\n */\ntype Tuning = {\n  aeroCdScale?: number;         // multiplies effective Cd (default 1)\n  drivelineEffOffset?: number;  // additive to overallEff before clamping [0.85, 1.0]\n};\n\n/**\n * RSACLASSIC physics model.\n * Advanced physics simulation for Quarter Jr/Pro parity.\n */\nclass RSACLASSICModel implements PhysicsModel {\n  id: PhysicsModelId = 'RSACLASSIC';\n\n  simulate(input: SimInputs): SimResult {\n    // === VB6-STRICT MODE ===\n    // When enabled, use Float32 precision and VB6-identical math path\n    // for bit-for-bit parity with Quarter Pro VB6 outputs\n    const STRICT = !!((input as any)?.flags?.vb6Strict);\n    if (STRICT) {\n      console.log('[RSACLASSIC] VB6-STRICT mode enabled - using Float32 math');\n    }\n    \n    // --- watchdogs & helpers (DEV safety) ---\n    const WATCH_START_MS = Date.now();\n    const WATCH_WALL_MS  = 90_000;         // 90s wall limit\n    const WATCH_STEP_CAP = 2_000_000;      // absolute step cap\n    const WATCH_HEARTBEAT = 50_000;        // log heartbeat\n    let watchLastDist = 0;\n\n    function watchdog(step: number, dist_ft: number) {\n      const now = Date.now();\n      if ((now - WATCH_START_MS) > WATCH_WALL_MS) throw new Error('simulation wall-time exceeded');\n      if (step >= WATCH_STEP_CAP) throw new Error('simulation step cap hit');\n      if (step % WATCH_HEARTBEAT === 0) {\n        const gained = dist_ft - watchLastDist;\n        console.log('[RSACLASSIC] heartbeat', { step, dist_ft, gained_ft: gained });\n        if (step > 0 && gained < 1e-3) throw new Error('simulation stalled');\n        watchLastDist = dist_ft;\n      }\n    }\n\n    const raceLenFt = Number((input as any)?.raceLengthFt ?? 1320);\n    if (!Number.isFinite(raceLenFt) || raceLenFt <= 0) {\n      throw new Error(`invalid raceLengthFt: ${(input as any)?.raceLengthFt}`);\n    }\n    const dt = Number((input as any)?.timeStep ?? 0.002);\n    if (!Number.isFinite(dt) || dt <= 0) {\n      throw new Error(`invalid timeStep ${dt}`);\n    }\n    \n    // Resolve once and reuse\n    const engineResolved = resolveEngineParams(input);\n    const hpPts: PowerPt[] = engineResolved.powerHP;\n    console.log('[RSACLASSIC] start', { raceLenFt, hpPts: hpPts.length });\n\n    // Guard: minimum 2 points\n    if (!Array.isArray(hpPts) || hpPts.length < 2) {\n      throw new Error(`RSACLASSIC: powerHP invalid (len=${hpPts?.length ?? 0})`);\n    }\n    \n    // === Drivetrain: resolve clutch / converter once ===\n    // Tolerate multiple locations: drivetrain.clutch, input.clutch, vehicle.clutch\n    const drivetrain = (input as any)?.drivetrain ?? {};\n    const vehicleBlock = (input as any)?.vehicle ?? {};\n    const clutch = drivetrain.clutch ?? (input as any)?.clutch ?? vehicleBlock.clutch;\n    const converter = drivetrain.converter ?? (input as any)?.converter ?? vehicleBlock.converter;\n\n    const isClutch = !!clutch;\n    const isConverter = !!converter;\n\n    // Pull slip/launch/stall RPMs with tolerant casing\n    const slipRPM = isClutch ? Number((clutch as any).slipRPM ?? (clutch as any).slipRpm) : NaN;\n    const launchRPM = isClutch ? Number((clutch as any).launchRPM ?? (clutch as any).launchRpm) : NaN;\n    const stallRPM = isConverter ? Number((converter as any).stallRPM ?? (converter as any).stallRpm) : NaN;\n    \n    // VB6 slippage factor (gc_Slippage.Value) - multiplier for LockRPM to get EngRPM\n    // Clutch default: 1.0025, Converter default: 1.05\n    const clutchSlippage = isClutch \n      ? Number((clutch as any).slippageFactor ?? (clutch as any).slipRatio ?? 1.0025) \n      : 1.0;\n    const converterSlippage = isConverter \n      ? Number((converter as any).slippageFactor ?? (converter as any).slipRatio ?? 1.05) \n      : 1.0;\n\n    // Validate: one and only one device must be present\n    if (!isClutch && !isConverter) {\n      throw new Error('RSACLASSIC: drivetrain must specify clutch or converter');\n    }\n    if (isClutch && !Number.isFinite(slipRPM)) {\n      throw new Error('RSACLASSIC: clutch.slipRPM missing/invalid');\n    }\n    if (isConverter && !Number.isFinite(stallRPM)) {\n      throw new Error('RSACLASSIC: converter.stallRPM missing/invalid');\n    }\n\n    // Canonical launch/lock RPM to use in bootstrap\n    const rpmPin = isClutch ? (Number.isFinite(launchRPM) ? launchRPM : slipRPM)\n                            : stallRPM;\n\n    // Debug\n    console.log('[RPM-RESOLVED]', {\n      isClutch, isConverter, slipRPM, launchRPM, stallRPM, rpmPin\n    });\n    \n    // === Optional tuning parameters ===\n    const tuning: Tuning = (input as any)?.tuning ?? {};\n    const cdScale = Number.isFinite(tuning.aeroCdScale) ? tuning.aeroCdScale! : 1;\n    const effOffset = Number.isFinite(tuning.drivelineEffOffset) ? tuning.drivelineEffOffset! : 0;\n    \n    const { vehicle, env, raceLength } = input;\n    \n    // Initialize warnings array early\n    const warnings: string[] = [];\n    \n    // Determine finish distance\n    const finishDistance_ft = raceLength === 'EIGHTH' ? 660 : 1320;\n    \n    // Resolve parameters (VB6 parity mode: NO DEFAULTS for critical parameters)\n    const cd = vehicle.cd;\n    const frontalArea_ft2 = vehicle.frontalArea_ft2;\n    const transEff = vehicle.transEff;\n    const finalDrive = vehicle.finalDrive ?? vehicle.rearGear;\n    const gearRatios = vehicle.gearRatios;\n    const gearEff = vehicle.gearEff; // Per-gear efficiency, optional\n    const shiftRPM = vehicle.shiftRPM;\n    \n    // Validate required vehicle parameters\n    if (!cd) {\n      warnings.push('Missing vehicle.cd (drag coefficient) - required for VB6 parity');\n    }\n    if (!frontalArea_ft2) {\n      warnings.push('Missing vehicle.frontalArea_ft2 - required for VB6 parity');\n    }\n    if (!gearRatios || gearRatios.length === 0) {\n      warnings.push('Missing vehicle.gearRatios[] - required for VB6 parity');\n    }\n    if (!shiftRPM || shiftRPM.length === 0) {\n      warnings.push('Missing vehicle.shiftRPM[] - required for VB6 parity');\n    }\n    if (!finalDrive) {\n      warnings.push('Missing vehicle.finalDrive or vehicle.rearGear - required for VB6 parity');\n    }\n    \n    // Validate required environment parameters\n    if (env.barometerInHg === undefined) {\n      warnings.push('Missing env.barometerInHg - required for VB6 air density');\n    }\n    if (env.temperatureF === undefined) {\n      warnings.push('Missing env.temperatureF - required for VB6 air density');\n    }\n    if (env.humidityPct === undefined) {\n      warnings.push('Missing env.humidityPct - required for VB6 air density');\n    }\n    if (env.elevation === undefined) {\n      warnings.push('Missing env.elevation - required for VB6 air density');\n    }\n    \n    // --- Tire geometry normalization (single source of truth) ---\n    // VB6 uses either tire diameter or rollout (circumference)\n    // TIMESLIP.FRM:683-687, 1036, 1197\n    const tireRolloutIn = vehicle.tireRolloutIn ?? null;\n    const tireDiaInRaw = vehicle.tireDiaIn ?? null;\n    \n    // If rollout is present, derive diameter from circumference.\n    // Diameter = Rollout / π\n    const PI = Math.PI;\n    const tireDiaFromRollout =\n      (typeof tireRolloutIn === 'number' && tireRolloutIn > 0)\n        ? (tireRolloutIn / PI)\n        : null;\n    \n    // Use rollout-derived diameter if available, otherwise use raw diameter\n    let tireDiaIn = (tireDiaFromRollout ?? tireDiaInRaw) ?? 0;\n    if (!tireDiaIn || tireDiaIn <= 0) {\n      warnings.push('Tire diameter is undefined/invalid. Provide tireRolloutIn or tireDiaIn.');\n      tireDiaIn = 28; // Emergency fallback (inches)\n    }\n    \n    // Static tire radius (will be replaced by effective radius with growth in loop)\n    // const tireRadius_ft = (tireDiaIn / 12) / 2;\n    \n    const rolloutIn = vehicle.rolloutIn;\n    if (!rolloutIn) {\n      warnings.push('Missing vehicle.rolloutIn - required for VB6 parity');\n    }\n    \n    // Precompute atmospheric conditions\n    // VB6 exact air density and HP correction (constant for entire run)\n    // Determine fuel system type from fuel string (use input directly since fuel var defined later)\n    const fuelString = (input as any).fuel as string | undefined;\n    const fuelSystemType = getFuelSystemType(fuelString);\n    const airResult = airDensityVB6({\n      barometer_inHg: env.barometerInHg ?? 29.92,\n      temperature_F: env.temperatureF ?? 59,\n      relHumidity_pct: env.humidityPct ?? 50,\n      elevation_ft: env.elevation ?? 0, // Note: env uses 'elevation' not 'elevationFt'\n      fuelSystem: fuelSystemType,\n    });\n    const rho_slug_ft3 = airResult.rho_slug_per_ft3;\n    // hpc is available but not applied - see note in HP chain section\n    void airResult.hpc;\n    \n    // Precompute mass\n    const mass_slugs = lbToSlug(vehicle.weightLb);\n    \n    // Rollout distance\n    const rolloutFt = (rolloutIn ?? 12) / 12;\n    \n    // Note: drivetrain, clutch, converter already resolved at top of function\n    // Note: hpPts is now used directly in wheelTorque_lbft calls\n    \n    // Tire parameters (replaced with VB6 traction)\n    // const tireParams: TireParams = {\n    //   weightLb: vehicle.weightLb,\n    //   tireWidthIn: vehicle.tireWidthIn,\n    //   tractionIndex: env.tractionIndex,\n    // };\n    \n    // Termination tracking\n    type TerminationReason = 'DISTANCE' | 'TIME_CAP' | 'STEP_CAP' | 'SAFETY';\n    let terminationReason: TerminationReason | null = null;\n    let stepCount = 0;\n    \n    // Integration parameters\n    // VB6 uses adaptive timestep (TIMESLIP.FRM:1082): TimeStep = TSMax * (AgsMax / Ags0)^4\n    // Min: 0.005s (TIMESLIP.FRM:1064), Max: 0.05s (TIMESLIP.FRM:1120)\n    const MAX_TIME_S = 30; // Generous cap to avoid false stops while diagnosing\n    const traceInterval_s = 0.01; // Collect traces every 10ms\n    \n    // VB6 adaptive timestep parameters (TIMESLIP.FRM:1063-1064, 1082)\n    // Get peak HP for TSMax calculation\n    const peakHP = hpPts.reduce((max, pt) => Math.max(max, pt.hp), 0);\n    const torqueMult = converter ? ((converter as any).torqueMult ?? 1.7) : 1.0;\n    const rollout_ft = (vehicle.rolloutIn ?? 12) / 12; // Convert inches to feet\n    const TSMax = vb6CalcTSMax(rollout_ft > 0 ? rollout_ft : 1, peakHP, torqueMult, vehicle.weightLb);\n    let AgsMax_g = 0; // Track maximum acceleration seen (in g's)\n    let dt_s = TSMax; // Start with TSMax, will adapt\n    \n    // Initialize state\n    let state = createInitialState();\n    let nextTraceTime = 0;\n    \n    // Storage for traces and timeslip\n    const traces: Array<{\n      t_s: number;\n      v_mph: number;\n      a_g: number;\n      s_ft: number;\n      rpm: number;\n      gear: number;\n      hp?: number;      // Wheel HP (after all losses)\n      engineHp?: number; // Engine HP (before losses)\n      dragHp?: number;   // Drag HP loss\n    }> = [];\n    \n    // Track HP values for trace collection\n    let lastHPSave = 0;      // Engine HP\n    let lastHP_wheel = 0;    // Wheel HP (after losses)\n    let lastDragHP = 0;      // Drag HP\n    \n    const timeslip: Array<{ d_ft: number; t_s: number; v_mph: number }> = [];\n    \n    // VB6 rollout and timing (TIMESLIP.FRM:815-817, 1380)\n    // DistToPrint(1) = gc_Rollout.Value / 12\n    // If gc_Rollout.Value > 0 Then time(L) = 0  (reset clock at rollout)\n    let rolloutCompleted = false;\n    let t_at_rollout = 0;\n    \n    // VB6 timeslip points (TIMESLIP.FRM:816-817)\n    // DistToPrint(2) = 30, (3) = 60, (4) = 330, (5) = 594, (6) = 660, (7) = 1000, (8) = 1254, (9) = 1320\n    const timeslipPoints = [60, 330, 660, 1000, finishDistance_ft];\n    let nextTimeslipIdx = 0;\n    \n    // VB6 trap speed windows (TIMESLIP.FRM:1619-1627)\n    // Eighth:  594-660 ft (66 ft window)\n    // Quarter: 1254-1320 ft (66 ft window)\n    // TIMESLIP(4) = Z5 * 66 / (TIMESLIP(3) - SaveTime)  [time-averaged speed]\n    let t_at_594 = 0;\n    let t_at_1254 = 0;\n    \n    // Previous state for acceleration calculation\n    let prevV_fps = 0;\n    \n    // Converter tracking (converter already resolved at top)\n    let sumTR = 0;\n    let sumETA = 0;\n    let sumSR = 0;\n    let converterSteps = 0;\n    \n    // Clutch tracking (clutch already resolved at top)\n    let minC = 1.0;\n    let lockupAt_ft: number | undefined = undefined;\n    \n    // VB6 launch conditions (TIMESLIP.FRM:1006)\n    // VB6: EngRPM(L) = gc_LaunchRPM.Value\n    // Initialize engine RPM to launch RPM before first timestep (use resolved rpmPin)\n    state.rpm = rpmPin;\n    \n    // Fuel tracking\n    const fuel = (input as any).fuel as 'GAS' | 'METHANOL' | 'NITRO' | undefined;\n    let minFuelScale = 1.0;\n    let maxFuelScale = 1.0;\n    \n    // Energy accounting (DEV only - for debugging VB6 parity)\n    let E_engine_total = 0;      // Total energy from engine (ft-lb)\n    let E_drag_total = 0;         // Total energy lost to aero drag (ft-lb)\n    let E_rr_total = 0;           // Total energy lost to rolling resistance (ft-lb)\n    let E_driveline_loss = 0;     // Total driveline losses (ft-lb)\n    let E_pmi_engine = 0;         // Total energy lost to engine PMI (ft-lb)\n    let E_pmi_chassis = 0;        // Total energy lost to chassis PMI (ft-lb)\n    let E_kinetic_trans = 0;      // Final translational kinetic energy (ft-lb)\n    let E_kinetic_rot = 0;        // Final rotational kinetic energy (ft-lb) - if VB6 used it\n    \n    // VB6 integration state (TIMESLIP.FRM:1090)\n    // Ags0 = previous acceleration (ft/s²), used for velocity integration\n    // \n    // VB6 calculates initial Ags0 from TORQUE-based force (TIMESLIP.FRM:1020-1027)\n    \n    // Track AGS in g's for weight transfer calculation\n    let prevAGS_g_stored = 0;\n    // This provides initial acceleration without relying on ClutchSlip\n    let Ags0 = 0;\n    \n    // Calculate initial Ags0 at t=0 (VB6: TIMESLIP.FRM:1010-1027)\n    if (clutch || converter) {\n      // Use resolved rpmPin for launch\n      // Get HP at launch RPM\n      const launchTorque = wheelTorque_lbft(rpmPin, hpPts, transEff ?? 0.9);\n      const launchHP = rpmPin > 0 ? (launchTorque * rpmPin) / 5252 : 0;\n      \n      // VB6: TQ = Z6 * HP / EngRPM\n      // Z6 = 5252 (HP to torque conversion)\n      const TQ = launchHP > 0 && rpmPin > 0 ? (5252 * launchHP) / rpmPin : 0;\n      \n      // VB6: TQ = TQ * gc_TorqueMult.Value * TGR(iGear) * TGEff(iGear)\n      const gearRatio = (gearRatios ?? [1.0])[0] ?? 1.0; // First gear\n      const TQ_geared = TQ * gearRatio * (transEff ?? 0.9);\n      \n      // VB6: force = TQ * gc_GearRatio.Value * gc_Efficiency.Value / (TireSlip * TireDia / 24) - DragForce\n      const tireSlip = 1.02; // VB6 default\n      const force = (TQ_geared * (finalDrive ?? 3.73) * (transEff ?? 0.9)) / (tireSlip * tireDiaIn / 24);\n      \n      // VB6: Ags0 = 0.88 * force / gc_Weight.Value (12% losses for clutch)\n      // VB6: Ags0 = 0.96 * force / gc_Weight.Value (4% losses for converter)\n      const lossMultiplier = converter ? 0.96 : 0.88;\n      Ags0 = lossMultiplier * force / vehicle.weightLb;\n      \n      // VB6: If Ags0 < AMin Then Ags0 = AMin\n      if (Ags0 < AMin) {\n        Ags0 = AMin;\n      }\n      \n      // Note: VB6 also calculates AMAX and clamps here, but we'll do that in the loop\n    }\n    \n    // Bootstrap thresholds (for torque-based launch before HP path)\n    const BOOT_MAX_STEPS = 6;        // up to ~12ms with dt=0.002\n    const LOCKRPM_MIN = 5;           // rpm threshold at which clutchSlip becomes meaningful\n    \n    // PMI state tracking (VB6: TIMESLIP.FRM:1092, 1104, 1231, 1240)\n    // Initialize RPM0 to launch/stall RPM to avoid massive PMI spike on first step\n    // VB6 starts with engine already at stall/slip RPM, not from 0\n    let RPM0 = rpmPin;      // Previous engine RPM (start at launch/stall RPM)\n    let DSRPM0 = 0;    // Previous driveshaft RPM\n    \n    // Shift state tracking (VB6: TIMESLIP.FRM:1355, 1433, 1071-1072)\n    let shiftState = ShiftState.NORMAL;\n    let shiftDwellRemaining_s = 0; // Time remaining in shift dwell (no power window)\n    let totalShiftDwell_s = 0; // Total dwell time accumulated\n    \n    // Shared loss calculation helpers (single source of truth for both bootstrap and HP paths)\n    const getTransEff = (gearIdx: number): number => {\n      return gearEff && gearEff[gearIdx] !== undefined\n        ? Math.max(0.9, Math.min(1.0, gearEff[gearIdx]))\n        : (transEff ?? 0.9);\n    };\n    \n    const getDrivelineEff = (): number => {\n      // Base efficiency from drivetrain or vehicle config\n      const baseEff = drivetrain.overallEff ?? drivetrain.overallEfficiency ?? transEff ?? 0.97;\n      // Apply tuning offset and clamp to valid range [0.85, 1.0]\n      return clamp01(baseEff + effOffset);\n    };\n    \n    const getTireSlip = (distance_ft: number): number => {\n      // VB6: TIMESLIP.FRM:1100-1102\n      // Work = 0.005 * (gc_TractionIndex.Value - 1) + 3 * (TrackTempEffect - 1)\n      // TireSlip = 1.02 + Work * (1 - (Dist0 / 1320)^2)\n      const tractionIndex = env.tractionIndex ?? 3;\n      const trackTempEffect = 1.0; // TODO: Calculate from track temp\n      return tireSlipFactor(distance_ft, tractionIndex, trackTempEffect);\n    };\n    \n    // Integration loop\n    while (true) {\n      stepCount++;\n      watchdog(stepCount, state.s_ft);\n      \n      // VB6 tire growth (TIMESLIP.FRM:1091, 1585-1607)\n      // Compute effective tire dimensions with growth and squat\n      const tireGrowthResult = computeTireGrowth(\n        tireDiaIn,\n        vehicle.tireWidthIn ?? 17.0,\n        state.v_fps,\n        Ags0 // Previous acceleration for squat calculation\n      );\n      const tireRadius_ft = tireGrowthResult.radius_eff_ft;\n      const tireCircumference_ft = tireGrowthResult.circumference_eff_ft;\n      const tireDia_eff_in = tireGrowthResult.dia_eff_in;\n      \n      // Calculate RPM from current speed (using effective tire radius)\n      let rpm = rpmFromSpeed(state.v_fps, state.gearIdx, drivetrain);\n      \n      // VB6 driveline: converter, clutch, or direct drive\n      let drivelineTorqueLbFt = 0;\n      let effectiveRPM = rpm;\n      let clutchCoupling = 1.0;\n      let converterWork = 0;\n      let converterSlipRatio = 0;\n      let converterZStall = 0;\n      \n      // Calculate engine torque first (needed for driveline)\n      const currentGearEff = getTransEff(state.gearIdx);\n      // VB6-STRICT: Use Float32 torque calculation\n      let tq_lbft = STRICT\n        ? wheelTorque_f32(rpm, hpPts, currentGearEff)\n        : wheelTorque_lbft(rpm, hpPts, currentGearEff);\n      \n      // Apply fuel delivery factor\n      let M_fuel = 1.0;\n      if (fuel === 'METHANOL') {\n        const trackTempF = env.trackTempF;\n        if (trackTempF !== undefined && trackTempF < 80) {\n          if (state.t_s < 0.8) {\n            M_fuel = 1.025 - (0.025 * state.t_s / 0.8);\n          }\n        }\n      } else if (fuel === 'NITRO') {\n        if (state.t_s < 0.4) {\n          M_fuel = 0.90;\n        } else if (state.t_s < 1.0) {\n          const rampProgress = (state.t_s - 0.4) / (1.0 - 0.4);\n          M_fuel = 0.90 + (1.0 - 0.90) * rampProgress;\n        }\n      }\n      minFuelScale = Math.min(minFuelScale, M_fuel);\n      maxFuelScale = Math.max(maxFuelScale, M_fuel);\n      tq_lbft = tq_lbft * M_fuel;\n      \n      // VB6 driveline: converter, clutch, or direct drive\n      const gearRatio = (gearRatios ?? [1.0])[state.gearIdx] ?? 1.0;\n      \n      // VB6: TIMESLIP.FRM:1140\n      // DSRPM = TireSlip * Vel(L) * 60 / TireCirFt\n      // Note: VB6 uses DSRPM (driveshaft RPM) which includes tire slip factor\n      const currentTireSlip = getTireSlip(state.s_ft);\n      const wheelRPM = currentTireSlip * state.v_fps * 60 / tireCircumference_ft;\n      \n      // --- VB6 RPM hold logic (clutch/converter) ---\n      // VB6 holds EngRPM at slip/stall RPM until wheels catch up\n      // Use resolved values from top of function\n      \n      // DEBUG: Check what we're getting\n      if (stepCount === 1 && typeof console !== 'undefined' && console.debug) {\n        console.debug('[RPM-DEBUG]', {\n          isClutch,\n          isConverter,\n          slipRPM,\n          launchRPM,\n          stallRPM,\n          calculated_slipRPM: slipRPM,\n          rpm_from_speed: rpm,\n        });\n      }\n      \n      // VB6: TIMESLIP.FRM:1145-1146\n      // LockRPM = DSRPM * gc_GearRatio.Value * TGR(iGear)\n      // EngRPM(L) = gc_Slippage.Value * LockRPM\n      const LockRPM = wheelRPM * gearRatio * (finalDrive ?? 3.73);\n      \n      // VB6: TIMESLIP.FRM:1149-1151 (clutch) or 1164-1165 (converter)\n      // If EngRPM(L) < Stall Then\n      //     If iGear = 1 Or gc_LockUp.Value = 0 Then EngRPM(L) = Stall\n      // End If\n      // Use slippage factor from config (clutchSlippage or converterSlippage)\n      const slippage = isClutch ? clutchSlippage : converterSlippage;\n      let EngRPM = slippage * LockRPM; // gc_Slippage.Value * LockRPM\n      \n      // Hold engine RPM at slip/stall in 1st gear or no lockup\n      // VB6: TIMESLIP.FRM:1149-1151 (clutch uses slipRPM) or 1164-1165 (converter uses stallRPM)\n      const inFirstGear = state.gearIdx === 0;\n      const noLockup = true; // Most configs don't have lockup\n      const deviceStallRPM = isClutch ? slipRPM : stallRPM; // Use appropriate stall/slip RPM\n      if ((isClutch || isConverter) && (inFirstGear || noLockup)) {\n        if (EngRPM < deviceStallRPM) {\n          EngRPM = deviceStallRPM;\n        }\n      }\n      \n      // Track if engine is pinned at slip/stall RPM\n      const rpmIsPinned = EngRPM === deviceStallRPM && LockRPM < deviceStallRPM;\n      const lockThreshold = deviceStallRPM; // For diagnostics\n      \n      // Update effectiveRPM to use the calculated value\n      effectiveRPM = EngRPM;\n      \n      // Recalculate torque at the correct EngRPM\n      // VB6-STRICT: Use Float32 torque calculation\n      tq_lbft = STRICT\n        ? wheelTorque_f32(EngRPM, hpPts, currentGearEff)\n        : wheelTorque_lbft(EngRPM, hpPts, currentGearEff);\n      tq_lbft = STRICT ? F.mul(f32(tq_lbft), f32(M_fuel)) : tq_lbft * M_fuel; // Reapply fuel factor\n      \n      if (clutch) {\n        // VB6 clutch model: ClutchSlip = LockRPM / EngRPM\n        // Guard divide-by-zero and clamp to [0, 1]\n        clutchCoupling = EngRPM > 1 ? Math.max(0, Math.min(1, LockRPM / EngRPM)) : 0;\n        \n        // When rpmIsPinned=true and LockRPM is still low, clutchSlip may be ~0\n        // Bootstrap Ags0 already carries motion, HP slice will gradually pick up as LockRPM rises\n        \n        minC = Math.min(minC, clutchCoupling);\n        \n      } else if (converter) {\n        // VB6 converter model (TIMESLIP.FRM:1154-1172)\n        // Use resolved stallRPM from top\n        const torqueMult = (converter as any).torqueMult ?? 2.0;\n        // Use converterSlippage extracted at top (from slippageFactor or slipRatio)\n        \n        // Use VB6 converter coupling for HP path\n        const converterResult = vb6ConverterCoupling(\n          LockRPM,\n          stallRPM,\n          torqueMult,\n          converterSlippage,  // Use the extracted value, not local lookup\n          stepCount\n        );\n        \n        clutchCoupling = converterResult.coupling;\n        converterWork = converterResult.work;\n        converterSlipRatio = converterResult.slipRatio;\n        converterZStall = converterResult.zStall;\n        \n        // Track converter usage for diagnostics\n        sumTR += converterResult.work;\n        sumETA += converterResult.coupling;\n        sumSR += converterResult.slipRatio;\n        converterSteps++;\n        \n        minC = Math.min(minC, clutchCoupling);\n      } else {\n        // Direct drive (no converter/clutch, or converter in higher gears)\n        drivelineTorqueLbFt = vb6DirectDrive(tq_lbft, gearRatio, finalDrive ?? 3.73);\n        effectiveRPM = rpm;\n      }\n      \n      // Note: drivelineTorqueLbFt calculated but not currently used (was for F_wheel)\n      void drivelineTorqueLbFt;\n      \n      state.rpm = effectiveRPM;\n      \n      // === VB6 ATMOSPHERE PIPELINE (EXACT PORT) ===\n      // Guard all inputs against NaN propagation\n      const v = finite(state.v_fps, 0);\n      \n      // VB6: TIMESLIP.FRM:1181\n      // WindFPS = Sqr(Vel(L)^2 + 2*Vel(L)*(WindSpeed/Z5)*Cos(WindAngle*PI/180) + (WindSpeed/Z5)^2)\n      // Z5 = 3600/5280 (fps to mph conversion, so WindSpeed/Z5 converts mph to fps)\n      const windMph = env.windMph ?? 0;\n      const windAngleDeg = env.windAngleDeg ?? 0; // 0 = headwind, 180 = tailwind\n      const windFps = windMph / FPS_TO_MPH; // Convert mph to fps\n      const windAngleRad = (windAngleDeg * Math.PI) / 180;\n      // Law of cosines: combine vehicle velocity with wind velocity\n      const windEffectiveFps = Math.sqrt(\n        v * v + \n        2 * v * windFps * Math.cos(windAngleRad) + \n        windFps * windFps\n      );\n      \n      // VB6: TIMESLIP.FRM:1185-1189\n      // Increase frontal area based on tire growth\n      // RefArea2 = gc_RefArea.Value + ((TireGrowth - 1) * TireDia / 2) * (2 * gc_TireWidth.Value) / 144\n      const isMotorcycle = (vehicle as any).bodyStyle === 8;\n      const effectiveFrontalArea_ft2 = computeRefAreaWithTireGrowth(\n        frontalArea_ft2 ?? 0,\n        tireGrowthResult.growth,\n        tireDiaIn,\n        vehicle.tireWidthIn ?? 17.0,\n        isMotorcycle\n      );\n      \n      // VB6-STRICT: Use Float32 for aero calculations\n      // VB6: TIMESLIP.FRM:1182\n      // q = Sgn(WindFPS) * rho * Abs(WindFPS) ^ 2 / (2 * gc)\n      // Note: VB6 uses rho in lbm/ft³, we use slugs/ft³, so we don't divide by gc\n      let v2: number;\n      let q_psf: number;\n      let F_drag_lbf: number;\n      let F_lift_up_lbf: number;\n      \n      // Use wind-effective velocity for aero calculations\n      const v_aero = windMph !== 0 ? windEffectiveFps : v;\n      \n      if (STRICT) {\n        const v_f32 = f32(v_aero);\n        v2 = F.mul(v_f32, v_f32);\n        q_psf = F.mul(F.mul(f32(0.5), f32(rho_slug_ft3)), v2);\n        // F_drag = q * Cd * cdScale * A (using effective area with tire growth)\n        F_drag_lbf = F.mul(F.mul(F.mul(q_psf, f32(cd ?? 0)), f32(cdScale)), f32(effectiveFrontalArea_ft2));\n        F_lift_up_lbf = F.mul(F.mul(q_psf, f32(vehicle.liftCoeff ?? 0)), f32(effectiveFrontalArea_ft2));\n      } else {\n        v2 = v_aero * v_aero; // Use wind-effective velocity\n        q_psf = finite(0.5 * rho_slug_ft3 * v2, 0);\n        // All forces must be finite numbers\n        // Apply cdScale tuning to effective drag coefficient (using effective area with tire growth)\n        F_drag_lbf = finite(q_psf * (cd ?? 0) * cdScale * effectiveFrontalArea_ft2, 0);\n        F_lift_up_lbf = finite(q_psf * (vehicle.liftCoeff ?? 0) * effectiveFrontalArea_ft2, 0);\n      }\n      \n      // Normal force for rolling/traction (VB6 applies lift by reducing normal load)\n      const normal_lbf = finite(vehicle.weightLb - F_lift_up_lbf, vehicle.weightLb);\n      \n      // Aliases for compatibility with existing code\n      const F_drag = F_drag_lbf;\n      const normalForce_lbf = normal_lbf;\n      \n      // VB6 rolling resistance torque (TIMESLIP.FRM:1019, 1192-1193)\n      // Uses CMU coefficient (0.025 for Quarter Jr/Pro) with distance and speed dependence\n      const cmu = vehicle.rrCoeff ?? CMU; // Allow override, default to VB6 CMU\n      const cmuk = 0.01; // VB6 CMUK constant for Quarter Jr/Pro\n      const T_rr = vb6RollingResistanceTorque(normalForce_lbf, v, state.s_ft, tireRadius_ft, cmu, cmuk);\n      \n      // Convert rolling resistance torque to force at contact patch\n      const F_roll = finite(T_rr / tireRadius_ft, 0);\n      \n      // VB6 maximum traction (TIMESLIP.FRM:1054, 1216)\n      // AMAX = ((CRTF / TireGrowth) - DragForce) / Weight\n      // Calculate CAXI (traction index adjustment)\n      const trackTempEffect = 1.0; // TODO: Calculate from track temp\n      const tractionIndex = env.tractionIndex ?? 3;\n      const CAXI = computeCAXI(tractionIndex, trackTempEffect);\n      \n      // VB6 weight transfer (TIMESLIP.FRM:1037-1043, 1196-1211)\n      // Calculate dynamic rear weight based on acceleration\n      // Use previous step's AGS for weight transfer (VB6 iterates this way)\n      // Track AGS from previous step (stored outside the loop)\n      const prevAGS_g = stepCount === 1 ? 0 : prevAGS_g_stored;\n      \n      // VB6 vehicle parameters\n      const wheelbase_in = vehicle.wheelbaseIn ?? 108; // Default 108\" (typical drag car)\n      // VB6: TIMESLIP.FRM:1032 - gc_YCG.Value = (TireDia / 2) + 3.75\n      // CG height is tire radius + 3.75\" (assumes CG is 3.75\" above rear axle centerline)\n      const cg_height_in = (tireDiaIn / 2) + 3.75;\n      const static_front_weight_lbf = (vehicle as any).staticFrontWeightLb ?? (vehicle.weightLb * 0.38); // Default 38% front\n      // VB6: TIMESLIP.FRM:559 - FRCT = 1.03 (not 0.04!)\n      const frct = 1.03; // VB6 driveline friction coefficient\n      \n      // Calculate dynamic rear weight with weight transfer\n      // VB6 uses normal force (weight - lift) for downforce calculation\n      const weightTransfer = vb6RearWeightDynamic(\n        vehicle.weightLb,\n        static_front_weight_lbf,\n        prevAGS_g,\n        cg_height_in,\n        tireRadius_ft * 12, // Convert to inches\n        wheelbase_in,\n        F_drag + F_roll,\n        normal_lbf,  // VB6: downforce = weight - lift\n        frct,\n        getDrivelineEff()\n      );\n      \n      const dynamicRWT_lbf = weightTransfer.rear_weight_lbf;\n      \n      // VB6: TIMESLIP.FRM:1213-1216\n      // CRTF = CAXI * AX * TireDia * (TireWidth + 1) * (0.92 + 0.08 * (DynamicRWT / 1900) ^ 2.15)\n      // AMAX = ((CRTF / TireGrowth) - DragForce) / Weight\n      const AMax = computeAMaxVB6({\n        weight_lbf: vehicle.weightLb,\n        tireDia_in: tireDiaIn,\n        tireWidth_in: vehicle.tireWidthIn ?? 17.0,\n        dynamicRWT_lbf,\n        tractionIndexAdj: CAXI,\n        tireGrowth: tireGrowthResult.growth, // VB6 tire growth factor\n        dragForce_lbf: F_drag + F_roll,\n        bodyStyle: undefined, // Not a motorcycle\n      });\n      \n      const AMin = computeAMinVB6();\n      \n      // DEV: Traction diagnostics for first 12 steps\n      if (stepCount <= 12 && typeof console !== 'undefined' && console.log) {\n        // Compute CRTF for logging\n        const CRTF = computeCRTF({\n          weight_lbf: vehicle.weightLb,\n          tireDia_in: tireDiaIn,\n          tireWidth_in: vehicle.tireWidthIn ?? 17.0,\n          dynamicRWT_lbf,\n          tractionIndexAdj: CAXI,\n          tireGrowth: tireGrowthResult.growth,\n          dragForce_lbf: F_drag + F_roll,\n          bodyStyle: undefined,\n        });\n        \n        console.log('[TRACTION]', {\n          step: stepCount,\n          CAXI: +CAXI.toFixed(4),\n          AX: 10.8,\n          tireDia_in: +tireDiaIn.toFixed(2),\n          tireWidth_in: +(vehicle.tireWidthIn ?? 17.0).toFixed(1),\n          dynamicRWT_lbf: +dynamicRWT_lbf.toFixed(1),\n          weightFactor: +(0.92 + 0.08 * Math.pow(dynamicRWT_lbf / 1900, 2.15)).toFixed(4),\n          CRTF: +CRTF.toFixed(1),\n          tireGrowth: +tireGrowthResult.growth.toFixed(4),\n          dragForce_lbf: +(F_drag + F_roll).toFixed(2),\n          AMin_ftps2: +AMin.toFixed(3),\n          AMax_ftps2: +AMax.toFixed(3),\n          AMin_g: +(AMin / gc).toFixed(4),\n          AMax_g: +(AMax / gc).toFixed(4),\n        });\n      }\n      \n      // BOOTSTRAP PATH: Use torque-based Ags0 for first few steps when LockRPM is tiny\n      // (LockRPM already calculated above in RPM hold logic)\n      // This avoids ClutchSlip = 0 problem at launch\n      let AGS: number;\n      let PQWT_ftps2: number; // VB6: Power-to-weight-time parameter for integration\n      \n      if (stepCount <= BOOT_MAX_STEPS && LockRPM < LOCKRPM_MIN) {\n        // Torque-based bootstrap (VB6 lines 1020-1027)\n        // Get engine torque at rpmPin (resolved at top)\n        const tq_at_slip = wheelTorque_lbft(rpmPin, hpPts, currentGearEff);\n        \n        // Get torque multiplier for converter (1.0 for clutch)\n        const bootTorqueMult = isConverter ? ((converter as any).torqueMult ?? 2.0) : 1.0;\n        \n        const bootstrapResult = computeAgs0({\n          engineTorque_lbft_atSlip: tq_at_slip,\n          gearRatio,\n          transEff: currentGearEff,\n          drivelineEff: getDrivelineEff(),\n          finalDrive: finalDrive ?? 3.73,\n          tireDia_in: tireDiaIn, // Use calculated value, not vehicle.tireDiaIn\n          tireSlip: getTireSlip(state.s_ft),\n          dragForce_lbf: F_drag + F_roll,\n          vehicleWeight_lbf: vehicle.weightLb,\n          isAutoTrans: !!converter,\n          torqueMult: bootTorqueMult,  // Apply converter torque multiplication\n        });\n        \n        // Apply VB6 AMin/AMax clamps with PQWT rescaling\n        // For bootstrap, PQWT = thrust / weight * gc (approximation)\n        PQWT_ftps2 = bootstrapResult.netThrust_lbf / vehicle.weightLb * gc;\n        const clamped = clampAGSVB6(bootstrapResult.Ags0_ftps2, PQWT_ftps2, AMin, AMax);\n        AGS = clamped.AGS;\n        PQWT_ftps2 = clamped.PQWT; // Use rescaled PQWT\n        \n        // DEV: Bootstrap diagnostics\n        if (stepCount <= 10 && typeof console !== 'undefined' && console.debug) {\n          const AGS_g = bootstrapResult.Ags0_ftps2 / gc;\n          const overallRatio = gearRatio * (finalDrive ?? 3.73);\n          const phase = rpmIsPinned ? 'PINNED' : 'BOOTSTRAP';\n          console.debug('[STEP]', {\n            step: stepCount,\n            phase,\n            v_fps: state.v_fps.toFixed(6),\n            EngRPM: effectiveRPM.toFixed(0),\n            LockRPM: LockRPM.toFixed(2),\n            slipRPM: slipRPM.toFixed(0),\n            lockThreshold: lockThreshold.toFixed(0),\n            rpmIsPinned,\n            clutchSlip: clutchCoupling.toFixed(6),\n            gear: state.gearIdx + 1,\n            GRxFD: overallRatio.toFixed(3),\n            tireDia_eff_in: tireDia_eff_in.toFixed(2),\n            tireGrowth: tireGrowthResult.growth.toFixed(4),\n            tireSlip: getTireSlip(state.s_ft).toFixed(4),\n            RWTdyn_lbf: dynamicRWT_lbf.toFixed(1),\n            RWTfront_lbf: weightTransfer.front_weight_lbf.toFixed(1),\n            wheelieBar_lbf: weightTransfer.wheelie_bar_weight_lbf.toFixed(1),\n            AGS_g: AGS_g.toFixed(4),\n            AGS_ftps2: AGS.toFixed(4),\n            AMin_ftps2: AMin.toFixed(4),\n            AMax_ftps2: AMax.toFixed(4),\n            SLIP: clamped.SLIP,\n          });\n        }\n      } else {\n        // HP-BASED PATH: Use VB6 launch slice (TIMESLIP.FRM:1218-1228, 1250-1266)\n        \n        // VB6 Shift Dwell: During shift, vehicle coasts with zero engine power\n        // VB6: TIMESLIP.FRM:1071-1072, 1283-1287\n        // During DTShift period, only drag and rolling resistance act on vehicle\n        // Get HP directly from power curve at EngRPM\n        // VB6-STRICT: Use Float32 HP interpolation\n        let hp_at_EngRPM = STRICT\n          ? hpAtRPM_f32(EngRPM, hpPts)\n          : power_hp_atRPM(EngRPM, hpPts);\n        \n        // Check if in shift dwell (no power window)\n        if (shiftDwellRemaining_s > 0) {\n          // Zero engine power during shift\n          hp_at_EngRPM = 0;\n          \n          // Decrement dwell timer\n          shiftDwellRemaining_s = Math.max(0, shiftDwellRemaining_s - dt_s);\n          \n          // Log dwell end\n          if (shiftDwellRemaining_s === 0 && typeof console !== 'undefined' && console.debug) {\n            console.debug('[SHIFT_DWELL_END]', {\n              step: stepCount,\n              t_s: state.t_s.toFixed(4),\n              v_fps: state.v_fps.toFixed(2),\n            });\n          }\n        }\n        \n        // === VB6 EXACT HP CHAIN (TIMESLIP.FRM:1176-1178, 1231-1253) ===\n        \n        // VB6: TIMESLIP.FRM:1176-1178\n        // Call TABY(xrpm(), yhp(), NHP, 1, EngRPM(L), HP)\n        // HP = gc_HPTQMult.Value * HP / hpc\n        // HPSave = HP:    HP = HP * ClutchSlip\n        // Note: gc_HPTQMult.Value is already applied in hpPts normalization\n        // Note: hpc correction is NOT applied here because our fixture HP curves\n        // are the same values VB6 uses, and VB6's target ETs already include hpc.\n        // The hpc value is available in airResult.hpc if needed for display.\n        const HPSave = hp_at_EngRPM; // Engine HP before PMI losses\n        \n        // VB6: TIMESLIP.FRM:1180-1194\n        // DragHP = DragForce * Vel(L) / 550\n        // VB6-STRICT: Use Float32 arithmetic\n        const dragHP = STRICT\n          ? F.div(F.mul(F.add(f32(F_drag), f32(F_roll)), f32(state.v_fps)), f32(550))\n          : (F_drag + F_roll) * state.v_fps / 550;\n        \n        // DEV: Pre-HP-chain diagnostics for first 12 steps\n        if (stepCount <= 12 && typeof console !== 'undefined' && console.log) {\n          console.log('[PRE_HP_CHAIN]', {\n            step: stepCount,\n            EngRPM_out: +EngRPM.toFixed(0),\n            wheelRPM: +wheelRPM.toFixed(2),\n            ClutchSlip: +clutchCoupling.toFixed(4),\n            ...(converter ? {\n              converterWork: +converterWork.toFixed(4),\n            } : {}),\n            HPSave: +HPSave.toFixed(1),\n            DragHP: +dragHP.toFixed(2),\n            F_drag_lbf: +F_drag_lbf.toFixed(2),\n            F_roll_lbf: +F_roll.toFixed(2),\n            v_fps: +state.v_fps.toFixed(2),\n            tireSlip: +getTireSlip(state.s_ft).toFixed(4),\n            currentGearEff: +currentGearEff.toFixed(4),\n            drivelineEff: +getDrivelineEff().toFixed(4),\n            dt_s: +dt_s.toFixed(4),\n            RPM0: +RPM0.toFixed(0),\n            DSRPM0: +DSRPM0.toFixed(2),\n          });\n        }\n        \n        // VB6: TIMESLIP.FRM:1231-1248\n        // Compute driveshaft RPM (using effective tire circumference with growth)\n        const DSRPM = computeDSRPM(getTireSlip(state.s_ft), state.v_fps, tireCircumference_ft);\n        \n        // Compute chassis PMI\n        // VB6 PMI values (TIMESLIP.FRM:788-805)\n        let enginePMI: number;\n        let transPMI: number;\n        let tiresPMI: number;\n        \n        if (vehicle.pmi?.engine_flywheel_clutch !== undefined) {\n          // Use exact VB6 printout values\n          enginePMI = vehicle.pmi.engine_flywheel_clutch;\n          transPMI = vehicle.pmi.transmission_driveshaft ?? 0;\n          tiresPMI = vehicle.pmi.tires_wheels_ringgear ?? 0;\n        } else {\n          // Estimate from vehicle parameters (VB6 defaults)\n          const engineCID = 500; // Estimate - should come from vehicle config\n          enginePMI = engineCID / 120; // Naturally aspirated default\n          const numGears = gearRatios?.length ?? 5;\n          transPMI = isClutch ? numGears * enginePMI / 50 : (numGears - 1) * enginePMI / 10;\n          tiresPMI = 2 * (1.15 * 0.8 * (0.08 * tireDiaIn * (vehicle.tireWidthIn ?? 17.0)) * Math.pow(tireDiaIn / 2, 2) / 386);\n        }\n        \n        const chassisPMI = computeChassisPMI(tiresPMI, transPMI, finalDrive ?? 3.73, gearRatio);\n        \n        // VB6: TIMESLIP.FRM:1231-1240, 1247-1248\n        // EngAccHP = gc_EnginePMI.Value * EngRPM(L) * (EngRPM(L) - RPM0)\n        // ChasAccHP = ChassisPMI * DSRPM * (DSRPM - DSRPM0)\n        // Work = (2 * PI / 60) ^ 2 / (12 * 550 * dtk1)\n        // HPEngPMI = EngAccHP * Work\n        // HPChasPMI = ChasAccHP * Work\n        const HPEngPMI = hpEngPMI(RPM0, EngRPM, dt_s, enginePMI, isClutch);\n        const HPChasPMI = hpChasPMI(DSRPM0, DSRPM, dt_s, chassisPMI);\n        \n        // DEV: PMI diagnostics for first 12 steps\n        if (stepCount <= 12 && typeof console !== 'undefined' && console.log) {\n          console.log('[PMI_CALC]', {\n            step: stepCount,\n            EngRPM: +EngRPM.toFixed(0),\n            RPM0: +RPM0.toFixed(0),\n            RPM_delta: +(EngRPM - RPM0).toFixed(0),\n            DSRPM: +DSRPM.toFixed(2),\n            DSRPM0: +DSRPM0.toFixed(2),\n            DSRPM_delta: +(DSRPM - DSRPM0).toFixed(2),\n            enginePMI: +enginePMI.toFixed(3),\n            chassisPMI: +chassisPMI.toFixed(3),\n            HPEngPMI: +HPEngPMI.toFixed(1),\n            HPChasPMI: +HPChasPMI.toFixed(1),\n          });\n        }\n        \n        // Update previous RPM values for next step\n        RPM0 = EngRPM;\n        DSRPM0 = DSRPM;\n        \n        // Track PMI energy losses\n        E_pmi_engine += HPEngPMI * 550 * dt_s; // Convert HP to ft-lb\n        E_pmi_chassis += HPChasPMI * 550 * dt_s;\n        \n        // VB6: TIMESLIP.FRM:1178, 1219-1220\n        // HPSave = HP:    HP = HP * ClutchSlip\n        // HP = HP * TGEff(iGear) * gc_Efficiency.Value / TireSlip\n        // HP = HP - DragHP\n        //\n        // Note: VB6's ClutchSlip for converters is:\n        // - Default: 1 / gc_Slippage.Value (~0.94 for slippage=1.06)\n        // - When EngRPM < zStall: Work * LockRPM / zStall\n        // The vb6ConverterCoupling function now correctly implements this logic.\n        \n        let HP_afterLine1: number;\n        let HP: number;\n        const tireSlip = getTireSlip(state.s_ft);\n        \n        if (STRICT) {\n          // VB6-STRICT: Float32 HP chain (TIMESLIP.FRM:1250-1251)\n          // VB6: HP = (HPSave - HPEngPMI) * ClutchSlip\n          HP_afterLine1 = F.mul(F.sub(f32(HPSave), f32(HPEngPMI)), f32(clutchCoupling));\n          HP = HP_afterLine1;\n          // VB6: HP = ((HP * TGEff(iGear) * gc_Efficiency.Value - HPChasPMI) / TireSlip) - DragHP\n          const hp_times_eff = F.mul(F.mul(f32(HP), f32(currentGearEff)), f32(getDrivelineEff()));\n          const hp_minus_pmi = F.sub(hp_times_eff, f32(HPChasPMI));\n          const hp_div_slip = F.div(hp_minus_pmi, f32(tireSlip));\n          HP = F.sub(hp_div_slip, f32(dragHP));\n        } else {\n          // VB6: HP = (HPSave - HPEngPMI) * ClutchSlip\n          HP_afterLine1 = (HPSave - HPEngPMI) * clutchCoupling;\n          HP = HP_afterLine1;\n          // VB6: HP = ((HP * TGEff(iGear) * gc_Efficiency.Value - HPChasPMI) / TireSlip) - DragHP\n          HP = ((HP * currentGearEff * getDrivelineEff() - HPChasPMI) / tireSlip) - dragHP;\n        }\n        const HP_afterLine2 = HP;\n        \n        // Store HP values for trace collection\n        lastHPSave = HPSave;\n        lastHP_wheel = HP_afterLine2;\n        lastDragHP = dragHP;\n        \n        // VB6: TIMESLIP.FRM:1252-1253\n        // PQWT = 550 * gc * HP / Weight\n        PQWT_ftps2 = STRICT\n          ? F.div(F.mul(F.mul(f32(550), f32(gc)), f32(HP)), f32(vehicle.weightLb))\n          : 550 * gc * HP / vehicle.weightLb;\n        \n        // VB6: TIMESLIP.FRM:1253\n        // AGS(L) = PQWT / (Vel(L) * gc)\n        let AGS_candidate_ftps2 = vb6AGSFromPQWT(PQWT_ftps2, state.v_fps);\n        \n        // VB6: TIMESLIP.FRM:1255-1258\n        // Apply jerk limits BEFORE AMin/AMax clamps\n        // Jerk = (AGS(L) - Ags0) / dtk1\n        // If Jerk < JMin Then Jerk = JMin: AGS(L) = Ags0 + Jerk * dtk1: PQWT = AGS(L) * gc * Vel(L)\n        // If Jerk > JMax Then Jerk = JMax: AGS(L) = Ags0 + Jerk * dtk1: PQWT = AGS(L) * gc * Vel(L)\n        // Note: VB6's AGS is in g's, Jerk is in g/s\n        // Note: VB6 uses jerk limiting as part of an iterative convergence loop.\n        // With adaptive timestep, we only apply jerk limiting when dt is small enough\n        // that jerk would otherwise be unreasonably high.\n        if (dt_s > 0 && dt_s <= 0.01 && stepCount > 1) {\n          const AGS_g = AGS_candidate_ftps2 / gc;\n          const Ags0_g_local = Ags0 / gc;\n          let Jerk = (AGS_g - Ags0_g_local) / dt_s; // g/s\n          \n          if (Jerk < JMin) {\n            Jerk = JMin;\n            const newAGS_g = Ags0_g_local + Jerk * dt_s;\n            AGS_candidate_ftps2 = newAGS_g * gc;\n            PQWT_ftps2 = newAGS_g * gc * state.v_fps; // VB6: PQWT = AGS(L) * gc * Vel(L)\n          }\n          if (Jerk > JMax) {\n            Jerk = JMax;\n            const newAGS_g = Ags0_g_local + Jerk * dt_s;\n            AGS_candidate_ftps2 = newAGS_g * gc;\n            PQWT_ftps2 = newAGS_g * gc * state.v_fps;\n          }\n        }\n        \n        // VB6: TIMESLIP.FRM:1260-1266\n        // Apply AMin/AMax clamps with PQWT rescaling\n        const clampResult = vb6ApplyAccelClamp(AGS_candidate_ftps2, AMin, AMax);\n        AGS = clampResult.AGS_ftps2;\n        PQWT_ftps2 = PQWT_ftps2 * clampResult.PQWT_scale; // Rescale PQWT per VB6\n        const slip = clampResult.slip;\n        \n        // Final guard: ensure AGS is finite and clamped\n        AGS = clampFinite(AGS, AMin, AMax, AMin);\n        \n        // VB6: Track maximum acceleration for adaptive timestep (TIMESLIP.FRM:1082)\n        const AGS_g = AGS / gc;\n        if (AGS_g > AgsMax_g) {\n          AgsMax_g = AGS_g;\n        }\n        \n        // VB6: Adaptive timestep (TIMESLIP.FRM:1082)\n        // TimeStep = TSMax * (AgsMax / Ags0) ^ 4\n        const Ags0_g = Ags0 / gc;\n        if (Ags0_g > 0 && stepCount > 1) {\n          dt_s = vb6AdaptiveTimestep(TSMax, AgsMax_g, Ags0_g);\n        }\n        \n        // DEV: Consolidated table for first 12 steps (before integration)\n        if (stepCount <= 12 && typeof console !== 'undefined' && console.log) {\n          console.log('[CONSOLIDATED_ROW]', {\n            step: stepCount,\n            v_ftps: +state.v_fps.toFixed(3),\n            EngRPM: +EngRPM.toFixed(0),\n            wheelRPM: +wheelRPM.toFixed(2),\n            ClutchSlip: +clutchCoupling.toFixed(4),\n            HPSave: +HPSave.toFixed(1),\n            HPEngPMI: +HPEngPMI.toFixed(1),\n            HPChasPMI: +HPChasPMI.toFixed(1),\n            DragHP: +dragHP.toFixed(2),\n            HP_afterL1: +HP_afterLine1.toFixed(1),\n            HP_afterL2: +HP_afterLine2.toFixed(1),\n            PQWT: +PQWT_ftps2.toFixed(1),\n            AMin: +AMin.toFixed(3),\n            AMax: +AMax.toFixed(3),\n            AGS_applied: +AGS.toFixed(3),\n          });\n        }\n        \n        // DEV: Aero/traction trace for first 20 steps\n        if (stepCount <= 20 && typeof console !== 'undefined' && console.log) {\n          console.log('[AERO_TRACE]', {\n            step: stepCount,\n            v_fps: +v.toFixed(6),\n            rho_slug_per_ft3: +rho_slug_ft3.toFixed(6),\n            q_psf: +q_psf.toFixed(3),\n            F_drag_lbf: +F_drag_lbf.toFixed(2),\n            F_lift_up_lbf: +F_lift_up_lbf.toFixed(2),\n            normal_lbf: +normal_lbf.toFixed(2),\n            F_roll_lbf: +F_roll.toFixed(2),\n            AMin_ftps2: +AMin.toFixed(3),\n            AMax_ftps2: +AMax.toFixed(3),\n            AGS_ftps2: +AGS.toFixed(3),\n          });\n        }\n        \n        // DEV: HP-based diagnostics for first 10 steps\n        if (stepCount <= 10 && typeof console !== 'undefined' && console.debug) {\n          const AGS_g = AGS / gc;\n          const overallRatio = gearRatio * (finalDrive ?? 3.73);\n          const phase = rpmIsPinned ? 'PINNED' : 'HP';\n          console.debug('[STEP]', {\n            step: stepCount,\n            phase,\n            v_fps: state.v_fps.toFixed(6),\n            EngRPM: effectiveRPM.toFixed(0),\n            LockRPM: LockRPM.toFixed(2),\n            slipRPM: slipRPM.toFixed(0),\n            lockThreshold: lockThreshold.toFixed(0),\n            rpmIsPinned,\n            clutchSlip: clutchCoupling.toFixed(6),\n            gear: state.gearIdx + 1,\n            GRxFD: overallRatio.toFixed(3),\n            tireDia_eff_in: tireDia_eff_in.toFixed(2),\n            tireGrowth: tireGrowthResult.growth.toFixed(4),\n            tireSlip: getTireSlip(state.s_ft).toFixed(4),\n            RWTdyn_lbf: dynamicRWT_lbf.toFixed(1),\n            RWTfront_lbf: weightTransfer.front_weight_lbf.toFixed(1),\n            wheelieBar_lbf: weightTransfer.wheelie_bar_weight_lbf.toFixed(1),\n            rho_slug_ft3: rho_slug_ft3.toFixed(6),\n            dragHP: dragHP.toFixed(2),\n            ...(converter ? {\n              converterWork: converterWork.toFixed(4),\n              converterSlipRatio: converterSlipRatio.toFixed(4),\n              converterZStall: converterZStall.toFixed(0),\n            } : {}),\n            HP_engine: HPSave.toFixed(1),\n            HPEngPMI: HPEngPMI.toFixed(1),\n            HPChasPMI: HPChasPMI.toFixed(1),\n            HP_afterLine1: HP_afterLine1.toFixed(1),\n            HP_afterLine2: HP_afterLine2.toFixed(1),\n            AGS_g: AGS_g.toFixed(4),\n            AGS_ftps2: AGS.toFixed(4),\n            AMin_ftps2: AMin.toFixed(4),\n            AMax_ftps2: AMax.toFixed(4),\n            SLIP: slip,\n          });\n        }\n      }\n      \n      // Update Ags0 for next step (VB6: TIMESLIP.FRM:1090)\n      Ags0 = AGS;\n      \n      // Energy accounting (DEV only)\n      // Engine energy = HP × time × 550 (convert HP to ft-lb/s)\n      // Get HP directly from power curve at EngRPM\n      const hp_at_EngRPM = power_hp_atRPM(EngRPM, hpPts);\n      E_engine_total += hp_at_EngRPM * 550 * dt_s; // ft-lb\n      \n      // Losses = Force × Distance\n      const distance_step = state.v_fps * dt_s; // ft\n      E_drag_total += F_drag * distance_step;\n      E_rr_total += F_roll * distance_step;\n      \n      // Driveline loss = efficiency losses only (gear friction, etc.)\n      // Loss = engine_power × (1 - efficiency)\n      const gearEffLoss = 1 - currentGearEff; // Typically ~0.01 (1%)\n      const overallEffLoss = 1 - getDrivelineEff(); // Typically ~0.03 (3%)\n      const totalEffLoss = gearEffLoss + overallEffLoss; // Combined ~4%\n      E_driveline_loss += hp_at_EngRPM * 550 * dt_s * totalEffLoss;\n      \n      // VB6 EXACT integration (TIMESLIP.FRM:1280)\n      // Dist(L) = ((2*PQWT*dt + v0²)^1.5 - v0³) / (3*PQWT) + Dist0\n      // Vel(L) = sqrt(v0² + 2*PQWT*dt)\n      \n      // Guard inputs before integration\n      const v_now = finite(state.v_fps, 0);\n      const dist_now = finite(state.s_ft, 0);\n      const a_now = finite(AGS, AMin);\n      const pqwt_now = finite(PQWT_ftps2, 0);\n      \n      const stepResult = vb6StepDistance(v_now, dist_now, dt_s, pqwt_now);\n      \n      // DEV: Log integrated values for first 12 steps\n      if (stepCount <= 12 && typeof console !== 'undefined' && console.log) {\n        console.log('[INTEGRATED]', {\n          step: stepCount,\n          Vel_next: +stepResult.Vel_ftps.toFixed(3),\n          Dist_next: +stepResult.Dist_ft.toFixed(6),\n        });\n      }\n      \n      // Check for NaN before updating state\n      if (!Number.isFinite(stepResult.Vel_ftps) || !Number.isFinite(stepResult.Dist_ft)) {\n        throw new Error(\n          `NaN in state @ step=${stepCount} v=${stepResult.Vel_ftps} dist=${stepResult.Dist_ft} AGS=${a_now} PQWT=${pqwt_now}`\n        );\n      }\n      \n      state.v_fps = stepResult.Vel_ftps;\n      state.s_ft = stepResult.Dist_ft;\n      state.t_s = state.t_s + dt_s;\n      \n      // Final NaN guard after state update\n      if (!Number.isFinite(state.v_fps) || !Number.isFinite(state.s_ft) || !Number.isFinite(AGS)) {\n        throw new Error(`NaN in state @ step=${stepCount} v=${state.v_fps} dist=${state.s_ft} AGS=${AGS}`);\n      }\n      \n      // Store AGS in g's for next step's weight transfer calculation\n      prevAGS_g_stored = AGS / gc;\n      \n      // Check termination conditions AFTER updating kinematics\n      // 1. FIRST: Check if we reached the finish line\n      if (state.s_ft >= finishDistance_ft) {\n        terminationReason = 'DISTANCE';\n        break;\n      }\n      \n      // 2. Safety caps (only if we haven't reached finish)\n      if (state.t_s >= MAX_TIME_S) {\n        terminationReason = 'TIME_CAP';\n        break;\n      }\n      \n      // VB6 shift logic (TIMESLIP.FRM:1355, 1433)\n      // Check if shift conditions are met\n      const numGears = gearRatios?.length ?? 1;\n      const currentShiftRPM = (shiftRPM ?? [])[state.gearIdx] ?? 0;\n      \n      // VB6-STRICT: Use >= operator directly, no tolerance\n      // Non-strict: Use tolerance-based check with state machine\n      const shiftTriggered = STRICT\n        ? shouldShift_f32(EngRPM, currentShiftRPM, state.gearIdx, numGears - 1)\n        : shouldShift(state.gearIdx, numGears, EngRPM, shiftRPM ?? []);\n      \n      // Update shift state machine (non-STRICT uses 2-step process)\n      // STRICT: Execute shift immediately when triggered\n      let executeShift = false;\n      if (STRICT) {\n        executeShift = shiftTriggered;\n      } else {\n        const shiftUpdate = updateShiftState(shiftState, shiftTriggered);\n        shiftState = shiftUpdate.newState;\n        executeShift = shiftUpdate.executeShift;\n      }\n      \n      // Execute shift\n      if (executeShift) {\n        const oldGear = state.gearIdx;\n        const oldEngRPM = EngRPM;\n        \n        // Increment gear\n        state.gearIdx++;\n        \n        // VB6: TIMESLIP.FRM:1071-1072\n        // Shift2PrintTime = time(L) + DTShift\n        // TimeStep = DTShift\n        // Start shift dwell (no power window)\n        const dwellTime = vb6ShiftDwell_s(isClutch);\n        shiftDwellRemaining_s = dwellTime;\n        totalShiftDwell_s += dwellTime;\n        \n        // Log shift event\n        if (typeof console !== 'undefined' && console.debug) {\n          console.debug('[SHIFT]', {\n            step: stepCount,\n            t_s: state.t_s.toFixed(4),\n            v_fps: state.v_fps.toFixed(2),\n            from_gear: oldGear + 1,\n            to_gear: state.gearIdx + 1,\n            EngRPM_before: oldEngRPM.toFixed(0),\n            LockRPM: LockRPM.toFixed(0),\n            dwell_s: dwellTime.toFixed(3),\n          });\n        }\n      }\n      \n      // VB6 rollout completion (TIMESLIP.FRM:1380)\n      // If gc_Rollout.Value > 0 Then time(L) = 0\n      if (!rolloutCompleted && state.s_ft >= rolloutFt) {\n        rolloutCompleted = true;\n        t_at_rollout = state.t_s;\n      }\n      \n      // VB6 trap speed window tracking (TIMESLIP.FRM:1619-1627)\n      // Case 5: SaveTime = time(L)  '594 ft\n      // Case 8: SaveTime = time(L)  '1254 ft\n      if (t_at_594 === 0 && state.s_ft >= 594) {\n        t_at_594 = state.t_s;\n      }\n      if (t_at_1254 === 0 && state.s_ft >= 1254) {\n        t_at_1254 = state.t_s;\n      }\n      \n      // VB6 timeslip points (TIMESLIP.FRM:1617-1626)\n      // Case 3: TIMESLIP(1) = time(L)  '60 ft\n      // Case 4: TIMESLIP(2) = time(L)  '330 ft\n      // Case 6: TIMESLIP(3) = time(L)  '660 ft\n      // Case 7: TIMESLIP(5) = time(L)  '1000 ft\n      // Case 9: TIMESLIP(6) = time(L)  '1320 ft\n      while (nextTimeslipIdx < timeslipPoints.length && \n             state.s_ft >= timeslipPoints[nextTimeslipIdx]) {\n        const distance = timeslipPoints[nextTimeslipIdx];\n        const measuredTime = rolloutCompleted ? state.t_s - t_at_rollout : 0;\n        const v_mph = state.v_fps * FPS_TO_MPH;\n        \n        timeslip.push({\n          d_ft: distance,\n          t_s: measuredTime,\n          v_mph: v_mph,\n        });\n        \n        nextTimeslipIdx++;\n      }\n      \n      // Collect traces at intervals\n      if (state.t_s >= nextTraceTime) {\n        const a_fps2 = (state.v_fps - prevV_fps) / dt_s;\n        const a_g = a_fps2 / g;\n        \n        traces.push({\n          t_s: state.t_s,\n          v_mph: state.v_fps * FPS_TO_MPH,\n          a_g: a_g,\n          s_ft: state.s_ft,\n          rpm: state.rpm,\n          gear: state.gearIdx + 1, // 1-based for display\n          hp: lastHP_wheel > 0 ? lastHP_wheel : undefined,         // Wheel HP (after losses)\n          engineHp: lastHPSave > 0 ? lastHPSave : undefined,       // Engine HP (before losses)\n          dragHp: lastDragHP > 0 ? lastDragHP : undefined,         // Drag HP loss\n        });\n        \n        nextTraceTime += traceInterval_s;\n        prevV_fps = state.v_fps;\n      }\n    }\n    \n    // Safety check\n    if (state.t_s >= MAX_TIME_S) {\n      warnings.push('max_time_exceeded');\n    }\n    \n    // VB6 final ET and trap speed calculation (TIMESLIP.FRM:1621, 1626-1627)\n    // TIMESLIP(4) = Z5 * 66 / (TIMESLIP(3) - SaveTime)  [eighth mile trap]\n    // TIMESLIP(7) = Z5 * 66 / (TIMESLIP(6) - SaveTime)  [quarter mile trap]\n    // Z5 = FPS_TO_MPH = 3600 / 5280 (converts fps to mph)\n    const measuredET = rolloutCompleted ? state.t_s - t_at_rollout : state.t_s;\n    const finalMPH = state.v_fps * FPS_TO_MPH;\n    \n    // VB6 trap speeds: time-averaged over 66 ft windows\n    let eighthMileTrapMPH: number | undefined;\n    let quarterMileTrapMPH: number | undefined;\n    \n    if (t_at_594 > 0 && state.t_s > t_at_594) {\n      // Eighth mile trap: 594-660 ft (66 ft window)\n      const t_at_660 = state.t_s; // Current time (should be at or past 660)\n      const deltaT = t_at_660 - t_at_594;\n      if (deltaT > 0) {\n        eighthMileTrapMPH = FPS_TO_MPH * 66 / deltaT;\n      }\n    }\n    \n    if (t_at_1254 > 0 && state.t_s > t_at_1254) {\n      // Quarter mile trap: 1254-1320 ft (66 ft window)\n      const t_at_1320 = state.t_s; // Current time (should be at or past 1320)\n      const deltaT = t_at_1320 - t_at_1254;\n      if (deltaT > 0) {\n        quarterMileTrapMPH = FPS_TO_MPH * 66 / deltaT;\n      }\n    }\n    \n    // Final kinetic energy (DEV only)\n    // Translational: KE = 0.5 × m × v²\n    E_kinetic_trans = 0.5 * mass_slugs * state.v_fps * state.v_fps;\n    \n    // Rotational: KE_rot = 0.5 × I × ω²\n    // I = moment of inertia (slug-ft²), ω = angular velocity (rad/s)\n    // For wheels: I ≈ m_wheel × r², ω = v / r\n    // If no explicit reason was set, mark as SAFETY\n    if (!terminationReason) {\n      terminationReason = 'SAFETY';\n    }\n    \n    // DEV: Log termination info\n    if (typeof console !== 'undefined' && console.debug) {\n      console.debug('[RSACLASSIC END]', {\n        reason: terminationReason,\n        t_s: state.t_s,\n        steps: stepCount,\n        d_ft: state.s_ft,\n        target_ft: finishDistance_ft,\n        totalShiftDwell_s: totalShiftDwell_s.toFixed(3),\n      });\n    }\n    \n    // DEV: Warn if we didn't reach the finish line\n    if (typeof console !== 'undefined' && console.warn && terminationReason !== 'DISTANCE') {\n      console.warn('Terminated without crossing finish:', {\n        reason: terminationReason,\n        t_s: state.t_s,\n        d_ft: state.s_ft,\n        target_ft: finishDistance_ft,\n      });\n    }\n    \n    // Ensure we have a timeslip entry at finish\n    if (timeslip.length === 0 || timeslip[timeslip.length - 1].d_ft !== finishDistance_ft) {\n      timeslip.push({\n        d_ft: finishDistance_ft,\n        t_s: measuredET,\n        v_mph: finalMPH,\n      });\n    }\n    \n    // VB6 trap speeds: time-averaged over 66 ft windows (TIMESLIP.FRM:1621, 1626-1627)\n    // TIMESLIP(4) = Z5 * 66 / (TIMESLIP(3) - SaveTime)  [eighth mile trap]\n    // TIMESLIP(7) = Z5 * 66 / (TIMESLIP(6) - SaveTime)  [quarter mile trap]\n    // Z5 = 3600 / 5280 (converts to mph)\n    const windowMPH: { e660_mph?: number; q1320_mph?: number } = {};\n    \n    if (eighthMileTrapMPH !== undefined) {\n      windowMPH.e660_mph = eighthMileTrapMPH;\n    }\n    \n    if (quarterMileTrapMPH !== undefined) {\n      windowMPH.q1320_mph = quarterMileTrapMPH;\n    }\n    \n    // Energy summary logging (DEV only)\n    // @ts-ignore - import.meta.env.DEV is available in Vite\n    const isDev = (typeof import.meta !== 'undefined' && import.meta.env?.DEV) || true; // Temporarily always on\n    if (isDev) {\n      const E_total_in = E_engine_total;\n      const E_total_out = E_drag_total + E_rr_total + E_driveline_loss + E_pmi_engine + E_pmi_chassis;\n      const E_total_kinetic = E_kinetic_trans + E_kinetic_rot;\n      const E_balance = E_total_in - E_total_out - E_total_kinetic;\n      \n      console.log(`\\n=== ENERGY SUMMARY: ${vehicle.name ?? 'Unknown'} ===`);\n      console.log(`ET: ${measuredET.toFixed(3)}s, Trap MPH: ${finalMPH.toFixed(1)}`);\n      console.log(`\\nEnergy In:`);\n      console.log(`  Engine:           ${(E_engine_total / 1000).toFixed(1)} k-ft-lb`);\n      console.log(`\\nEnergy Out:`);\n      console.log(`  Aero Drag:        ${(E_drag_total / 1000).toFixed(1)} k-ft-lb (${(100 * E_drag_total / E_total_in).toFixed(1)}%)`);\n      console.log(`  Rolling Resist:   ${(E_rr_total / 1000).toFixed(1)} k-ft-lb (${(100 * E_rr_total / E_total_in).toFixed(1)}%)`);\n      console.log(`  Driveline Loss:   ${(E_driveline_loss / 1000).toFixed(1)} k-ft-lb (${(100 * E_driveline_loss / E_total_in).toFixed(1)}%)`);\n      console.log(`  Engine PMI:       ${(E_pmi_engine / 1000).toFixed(1)} k-ft-lb (${(100 * E_pmi_engine / E_total_in).toFixed(1)}%)`);\n      console.log(`  Chassis PMI:      ${(E_pmi_chassis / 1000).toFixed(1)} k-ft-lb (${(100 * E_pmi_chassis / E_total_in).toFixed(1)}%)`);\n      console.log(`  Total Losses:     ${(E_total_out / 1000).toFixed(1)} k-ft-lb (${(100 * E_total_out / E_total_in).toFixed(1)}%)`);\n      console.log(`\\nFinal Kinetic Energy:`);\n      console.log(`  Translational:    ${(E_kinetic_trans / 1000).toFixed(1)} k-ft-lb (${(100 * E_kinetic_trans / E_total_in).toFixed(1)}%)`);\n      console.log(`  Rotational:       ${(E_kinetic_rot / 1000).toFixed(1)} k-ft-lb (${(100 * E_kinetic_rot / E_total_in).toFixed(1)}%)`);\n      console.log(`  Total Kinetic:    ${(E_total_kinetic / 1000).toFixed(1)} k-ft-lb (${(100 * E_total_kinetic / E_total_in).toFixed(1)}%)`);\n      console.log(`\\nEnergy Balance:     ${(E_balance / 1000).toFixed(1)} k-ft-lb (${(100 * E_balance / E_total_in).toFixed(1)}% error)`);\n      console.log(`===\\n`);\n    }\n    \n    // Build result\n    // VB6-STRICT: Apply banker's rounding to final outputs (VB6 UI behavior)\n    const result: SimResult = {\n      et_s: STRICT ? vb6Round(measuredET, 3) : measuredET,\n      mph: STRICT ? vb6Round(finalMPH, 2) : finalMPH,\n      timeslip: timeslip,\n      traces: traces.length > 0 ? traces : undefined,\n      meta: {\n        model: 'RSACLASSIC',\n        steps: Math.floor(state.t_s / dt_s),\n        warnings: warnings,\n        windowMPH: Object.keys(windowMPH).length > 0 ? windowMPH : undefined,\n        converter: converter && !clutch ? {\n          used: true,\n          avgTR: converterSteps > 0 ? sumTR / converterSteps : 1.0,\n          avgETA: converterSteps > 0 ? sumETA / converterSteps : 1.0,\n          avgSR: converterSteps > 0 ? sumSR / converterSteps : 1.0,\n          deRateMax: 0.30,\n          parasiticConst: 0.05,\n          parasiticQuad: 1e-6,\n        } : undefined,\n        clutch: clutch ? {\n          used: true,\n          minC: minC,\n          lockupAt_ft: lockupAt_ft,\n        } : undefined,\n        rollout: {\n          rolloutIn: rolloutIn ?? 12,\n          t_roll_s: t_at_rollout,\n        },\n        fuel: fuel ? {\n          type: fuel,\n          minScale: minFuelScale,\n          maxScale: maxFuelScale,\n        } : undefined,\n        vb6: {\n          dt_s: dt_s,\n          trapMode: 'time' as const,\n          windowsFt: {\n            eighth: { start: 594, end: 660, distance: 66 },\n            quarter: { start: 1254, end: 1320, distance: 66 },\n          },\n          timeslipPoints: [60, 330, 660, 1000, 1320],\n          rolloutBehavior: 'ET clock starts after rollout distance (TIMESLIP.FRM:1380)',\n        },\n        termination: {\n          reason: terminationReason,\n          steps: stepCount,\n          t_s: state.t_s,\n          target_ft: finishDistance_ft,\n        },\n      },\n    };\n    \n    console.log('[RSACLASSIC] done', {\n      et_s: +(result?.et_s?.toFixed?.(4) ?? result?.et_s),\n      mph: +(result?.mph?.toFixed?.(1) ?? result?.mph),\n      steps: result?.meta?.termination?.steps ?? stepCount,\n      wallMs: Date.now() - WATCH_START_MS,\n    });\n    \n    return result;\n  }\n}\n\n/**\n * RSACLASSIC model instance.\n */\nexport const RSACLASSIC: PhysicsModel = new RSACLASSICModel();\n","/**\r\n * VB6 Exact Simulation Step Implementation\r\n * \r\n * This file implements the EXACT VB6 TIMESLIP.FRM simulation loop logic.\r\n * \r\n * VB6 Flow (TIMESLIP.FRM lines 1078-1280):\r\n * 1. Calculate adaptive timestep: TimeStep = TSMax * (AgsMax / Ags0)^4\r\n * 2. Estimate next velocity: Vel(L) = Vel0 + Ags0*gc*TimeStep + Jerk*gc*TimeStep^2/2\r\n * 3. Calculate VelSqrd = Vel(L)^2 - Vel0^2\r\n * 4. Calculate clutch/converter slip and engine RPM\r\n * 5. Get HP from curve, apply hpc correction\r\n * 6. Calculate drag forces and AMax\r\n * 7. Initial HP chain and time estimate\r\n * 8. ITERATE (up to 12 times) to converge PMI and time:\r\n *    - Calculate Work = (2*PI/60)^2 / (12*550*dtk1)\r\n *    - HPEngPMI = EngAccHP * Work\r\n *    - HPChasPMI = ChasAccHP * Work\r\n *    - HP = (HPSave - HPEngPMI) * ClutchSlip\r\n *    - HP = ((HP * TGEff * Efficiency - HPChasPMI) / TireSlip) - DragHP\r\n *    - PQWT = 550 * gc * HP / Weight\r\n *    - AGS(L) = PQWT / (Vel(L) * gc)\r\n *    - Apply jerk limits\r\n *    - Apply AMin/AMax clamps\r\n *    - time(L) = VelSqrd / (2*PQWT) + Time0\r\n *    - Check convergence: |100*(dtk2-dtk1)/dtk2| <= 0.01\r\n * 9. After convergence: Dist(L) = ((2*PQWT*dt + Vel0^2)^1.5 - Vel0^3) / (3*PQWT) + Dist0\r\n */\r\n\r\nimport { \r\n  gc, PI, JMin, JMax, AMin, K6, K61, Z5,\r\n  // Quarter Pro constants\r\n  CMU, CMUK, KP21, KP22, FRCT, AX,\r\n  // Bonneville Pro constants\r\n  CMU_BV, CMUK_BV, KP21_BV, KP22_BV, FRCT_BV, AX_BV\r\n} from './constants';\r\n\r\n// ============================================================================\r\n// Types\r\n// ============================================================================\r\n\r\n/**\r\n * State variables that persist across simulation steps\r\n */\r\nexport interface VB6SimState {\r\n  L: number;              // Step index\r\n  time_s: number;         // Current time (seconds)\r\n  Vel_ftps: number;       // Current velocity (ft/s)\r\n  Dist_ft: number;        // Current distance (ft)\r\n  AGS_g: number;          // Current acceleration (g's)\r\n  EngRPM: number;         // Current engine RPM\r\n  DSRPM: number;          // Current driveshaft RPM\r\n  Gear: number;           // Current gear (1-indexed)\r\n  SLIP: boolean;          // True if traction limited\r\n  \r\n  // Previous step values (for iteration)\r\n  Vel0_ftps: number;      // Previous velocity\r\n  Ags0_g: number;         // Previous acceleration\r\n  Time0_s: number;        // Previous time\r\n  Dist0_ft: number;       // Previous distance\r\n  RPM0: number;           // Previous engine RPM\r\n  DSRPM0: number;         // Previous driveshaft RPM\r\n  \r\n  // Tracking\r\n  AgsMax_g: number;       // Maximum acceleration seen (for adaptive timestep)\r\n  TireGrowth: number;     // Current tire growth factor\r\n  TireCirFt: number;      // Current tire circumference (ft)\r\n  \r\n  // Shift tracking (VB6 TIMESLIP.FRM:1070-1072)\r\n  ShiftFlag: number;      // 0=normal, 1=shift initiated, 2=shift in progress\r\n  PrevGear: number;       // Previous gear (to detect shifts)\r\n}\r\n\r\n/**\r\n * Vehicle parameters (constant for a run)\r\n */\r\nexport interface VB6VehicleParams {\r\n  Weight_lbf: number;\r\n  Wheelbase_in: number;\r\n  YCG_in: number;           // CG height (inches)\r\n  StaticFWt_lbf: number;    // Static front weight\r\n  TireDia_in: number;\r\n  TireWidth_in: number;\r\n  Rollout_in: number;\r\n  \r\n  // Drivetrain\r\n  GearRatio: number;        // Final drive ratio\r\n  TGR: number[];            // Transmission gear ratios (1-indexed in VB6)\r\n  TGEff: number[];          // Gear efficiencies\r\n  Efficiency: number;       // Overall driveline efficiency\r\n  DTShift: number;          // Shift time (0.2s clutch, 0.25s converter) - VB6 TIMESLIP.FRM:702-703\r\n  Slippage: number;         // Clutch/converter slippage factor\r\n  TorqueMult: number;       // Converter torque multiplier\r\n  Stall: number;            // Stall/slip RPM\r\n  LockUp: boolean;          // Converter lockup enabled\r\n  isClutch: boolean;        // True for clutch, false for converter\r\n  \r\n  // Aero\r\n  RefArea_ft2: number;\r\n  DragCoef: number;\r\n  LiftCoef: number;\r\n  BodyStyle: number;        // 8 = motorcycle\r\n  \r\n  // PMI\r\n  EnginePMI: number;\r\n  TiresPMI: number;\r\n  TransPMI: number;\r\n  \r\n  // HP curve (arrays for TABY interpolation)\r\n  xrpm: number[];\r\n  yhp: number[];\r\n  NHP: number;              // Number of HP points\r\n  HPTQMult: number;         // HP/TQ multiplier\r\n  \r\n  // Shift points\r\n  ShiftRPM: number[];       // Shift RPMs per gear\r\n  NGR: number;              // Number of gears\r\n  LaunchRPM: number;        // Launch RPM (for first step handling)\r\n  \r\n  // Shift by Time (alternative to shift by RPM)\r\n  ShiftMode: 'rpm' | 'time'; // 'rpm' = shift at RPM, 'time' = shift at elapsed time\r\n  ShiftTimes: number[];      // Shift at these elapsed times (seconds)\r\n  \r\n  // Rev Limiter\r\n  RevLimiterRPM: number;     // High-side RPM limit (0 = disabled)\r\n}\r\n\r\n/**\r\n * Environment parameters\r\n */\r\nexport interface VB6EnvParams {\r\n  rho: number;              // Air density (lbm/ft³) - VB6 uses lbm not slugs!\r\n  hpc: number;              // HP correction factor\r\n  TractionIndex: number;\r\n  TrackTempEffect: number;\r\n  WindSpeed_mph: number;\r\n  WindAngle_deg: number;\r\n  isLandSpeed?: boolean;    // True for Bonneville Pro mode (different constants)\r\n}\r\n\r\n/**\r\n * Computed values for current step\r\n */\r\nexport interface VB6StepComputed {\r\n  TimeStep_s: number;\r\n  VelSqrd: number;\r\n  LockRPM: number;\r\n  ClutchSlip: number;\r\n  zStall: number;\r\n  SlipRatio: number;\r\n  TireSlip: number;\r\n  WindFPS: number;\r\n  q: number;\r\n  RefArea2_ft2: number;\r\n  DownForce_lbf: number;\r\n  DragForce_lbf: number;\r\n  DragHP: number;\r\n  DynamicFWT_lbf: number;\r\n  DynamicRWT_lbf: number;\r\n  WheelBarWT_lbf: number;\r\n  CRTF: number;\r\n  AMax_g: number;\r\n  ChassisPMI: number;\r\n  EngAccHP: number;\r\n  ChasAccHP: number;\r\n  HPSave: number;       // Engine HP from curve (before clutch slip and drivetrain losses)\r\n  HPAtWheels: number;   // HP at wheels (after drivetrain losses, before drag subtraction)\r\n  HP: number;           // Net HP (HPAtWheels - DragHP)\r\n  PQWT: number;\r\n  iterations: number;\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\n/**\r\n * VB6 TABY function - linear interpolation in HP curve\r\n * TIMESLIP.FRM uses 1st order (linear) interpolation\r\n */\r\nexport function TABY(xrpm: number[], yhp: number[], NHP: number, _order: number, rpm: number): number {\r\n  // Find bracketing points\r\n  let i = 0;\r\n  for (i = 0; i < NHP - 1; i++) {\r\n    if (rpm <= xrpm[i + 1]) break;\r\n  }\r\n  \r\n  // Clamp to range\r\n  if (i >= NHP - 1) i = NHP - 2;\r\n  if (i < 0) i = 0;\r\n  \r\n  // Linear interpolation\r\n  const x0 = xrpm[i];\r\n  const x1 = xrpm[i + 1];\r\n  const y0 = yhp[i];\r\n  const y1 = yhp[i + 1];\r\n  \r\n  if (x1 === x0) return y0;\r\n  \r\n  const t = (rpm - x0) / (x1 - x0);\r\n  return y0 + t * (y1 - y0);\r\n}\r\n\r\n/**\r\n * VB6 Tire subroutine - calculates tire growth and circumference\r\n * TIMESLIP.FRM line 1585-1606\r\n * \r\n * Note: Bonneville Pro uses a completely different formula than Quarter Pro!\r\n */\r\nexport function vb6Tire(\r\n  TireDia_in: number,\r\n  TireWidth_in: number,\r\n  Vel_ftps: number,\r\n  Ags0_g: number,\r\n  isLandSpeed?: boolean\r\n): { TireGrowth: number; TireCirFt: number } {\r\n  let TireGrowth: number;\r\n  let TireCirFt: number;\r\n  \r\n  if (isLandSpeed) {\r\n    // VB6: TIMESLIP.FRM:1603-1605 - Bonneville Pro\r\n    // TireGrowth = 1 + 0.00004 * Vel(L)\r\n    // TireCirFt = TireGrowth * TireDia * PI / 12\r\n    // Note: No tire squat for BVPro!\r\n    TireGrowth = 1 + 0.00004 * Vel_ftps;\r\n    TireCirFt = TireGrowth * TireDia_in * PI / 12;\r\n  } else {\r\n    // VB6: TIMESLIP.FRM:1589-1596 - Quarter Pro\r\n    // TGK = (TireWidth^1.4 + TireDia - 16) / (0.171 * TireDia^1.7)\r\n    // TireGrowth = 1 + TGK * 0.0000135 * Vel^1.6\r\n    // TGLinear = 1 + TGK * 0.00035 * Vel\r\n    // If TGLinear < TireGrowth Then TireGrowth = TGLinear\r\n    // TireSQ = TireGrowth - 0.035 * Abs(Ags0)\r\n    // TireCirFt = TireSQ * TireDia * PI / 12\r\n    const TGK = (Math.pow(TireWidth_in, 1.4) + TireDia_in - 16) / (0.171 * Math.pow(TireDia_in, 1.7));\r\n    TireGrowth = 1 + TGK * 0.0000135 * Math.pow(Vel_ftps, 1.6);\r\n    const TGLinear = 1 + TGK * 0.00035 * Vel_ftps;\r\n    if (TGLinear < TireGrowth) TireGrowth = TGLinear;\r\n    \r\n    // Tire squat under load\r\n    const TireSQ = TireGrowth - 0.035 * Math.abs(Ags0_g);\r\n    TireCirFt = TireSQ * TireDia_in * PI / 12;\r\n  }\r\n  \r\n  return { TireGrowth, TireCirFt };\r\n}\r\n\r\n/**\r\n * Calculate CAXI (traction coefficient base)\r\n * VB6: TIMESLIP.FRM:1050\r\n * CAXI = (1 - (TractionIndex - 1) * 0.01) / (TrackTempEffect ^ 0.25)\r\n */\r\nexport function calcCAXI(TractionIndex: number, TrackTempEffect: number): number {\r\n  return (1 - (TractionIndex - 1) * 0.01) / Math.pow(TrackTempEffect, 0.25);\r\n}\r\n\r\n/**\r\n * Get AX (traction coefficient multiplier)\r\n * VB6: TIMESLIP.FRM:551 - Const AX = 10.8 for Quarter Jr/Pro\r\n * VB6: TIMESLIP.FRM:561 - Const AX = 9.7 for Bonneville Pro\r\n * This is a constant, not calculated from temperature\r\n */\r\nexport function calcAX(isLandSpeed?: boolean): number {\r\n  return isLandSpeed ? AX_BV : AX;\r\n}\r\n\r\n// ============================================================================\r\n// Main Simulation Step Function\r\n// ============================================================================\r\n\r\n/**\r\n * Throttle stop configuration for bracket racing.\r\n * Applied during simulation to reduce HP during specified time window.\r\n */\r\nexport interface ThrottleStopParams {\r\n  enabled: boolean;\r\n  activateTime_s: number;    // When stop activates (seconds after rollout)\r\n  duration_s: number;        // How long stop is active\r\n  throttlePct: number;       // Throttle percentage when active (0-100)\r\n  rampTime_s?: number;       // Time to ramp (default: instant)\r\n}\r\n\r\n/**\r\n * Calculate throttle stop HP multiplier based on current time.\r\n * Returns 1.0 for full power, or reduced value when stop is active.\r\n */\r\nfunction calcThrottleStopMultiplier(\r\n  currentTime_s: number,\r\n  throttleStop?: ThrottleStopParams\r\n): number {\r\n  if (!throttleStop?.enabled) return 1.0;\r\n  \r\n  const { activateTime_s, duration_s, throttlePct, rampTime_s = 0 } = throttleStop;\r\n  const deactivateTime_s = activateTime_s + duration_s;\r\n  \r\n  // Before activation - full power\r\n  if (currentTime_s < activateTime_s) return 1.0;\r\n  \r\n  // After deactivation - full power\r\n  if (currentTime_s >= deactivateTime_s) return 1.0;\r\n  \r\n  // During activation - reduced power\r\n  const targetMult = throttlePct / 100;\r\n  \r\n  // Handle ramp-in\r\n  if (rampTime_s > 0 && currentTime_s < activateTime_s + rampTime_s) {\r\n    const rampProgress = (currentTime_s - activateTime_s) / rampTime_s;\r\n    return 1.0 - (1.0 - targetMult) * rampProgress;\r\n  }\r\n  \r\n  // Handle ramp-out\r\n  if (rampTime_s > 0 && currentTime_s > deactivateTime_s - rampTime_s) {\r\n    const rampProgress = (deactivateTime_s - currentTime_s) / rampTime_s;\r\n    return 1.0 - (1.0 - targetMult) * rampProgress;\r\n  }\r\n  \r\n  return targetMult;\r\n}\r\n\r\n/**\r\n * Execute one VB6 simulation step with full iteration loop.\r\n * \r\n * This is an EXACT port of TIMESLIP.FRM lines 1078-1280.\r\n * \r\n * @param state Current simulation state (will be modified)\r\n * @param vehicle Vehicle parameters\r\n * @param env Environment parameters\r\n * @param TSMax Maximum timestep (from initialization)\r\n * @param throttleStop Optional throttle stop configuration\r\n * @returns Computed values for this step\r\n */\r\nexport function vb6SimulationStep(\r\n  state: VB6SimState,\r\n  vehicle: VB6VehicleParams,\r\n  env: VB6EnvParams,\r\n  TSMax: number,\r\n  throttleStop?: ThrottleStopParams\r\n): VB6StepComputed {\r\n  const iGear = state.Gear;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1070-1076 - Check for gear change\r\n  // At top of gear change loop, TimeStep = DTShift\r\n  // ========================================================================\r\n  let TimeStep: number;\r\n  const gearChanged = state.Gear !== state.PrevGear;\r\n  \r\n  if (gearChanged) {\r\n    // VB6: TIMESLIP.FRM:1072 - TimeStep = DTShift at gear change\r\n    TimeStep = vehicle.DTShift;\r\n    state.PrevGear = state.Gear;\r\n  } else {\r\n    // ========================================================================\r\n    // TIMESLIP.FRM:1082 - Calculate adaptive timestep\r\n    // TimeStep = TSMax * (AgsMax / Ags0) ^ 4\r\n    // ========================================================================\r\n    TimeStep = TSMax;\r\n    if (state.Ags0_g > 0 && state.L > 1) {\r\n      // Limit the ratio to prevent huge timesteps at terminal velocity\r\n      const ratio = Math.min(state.AgsMax_g / state.Ags0_g, 10);\r\n      TimeStep = TSMax * Math.pow(ratio, 4);\r\n    }\r\n    // Cap timestep to prevent numerical instability at terminal velocity\r\n    if (TimeStep > 0.1) TimeStep = 0.1;\r\n  }\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1084-1088 - Calculate jerk from previous step\r\n  // ========================================================================\r\n  let Jerk = 0;\r\n  const Work_time = state.time_s - state.Time0_s;\r\n  if (Work_time > 0) {\r\n    Jerk = (state.AGS_g - state.Ags0_g) / Work_time;\r\n  }\r\n  if (Jerk < JMin) Jerk = JMin;\r\n  if (Jerk > JMax) Jerk = JMax;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1090-1096 - Save previous values\r\n  // ========================================================================\r\n  state.Vel0_ftps = state.Vel_ftps;\r\n  state.Ags0_g = state.AGS_g;\r\n  state.Time0_s = state.time_s;\r\n  state.Dist0_ft = state.Dist_ft;\r\n  state.RPM0 = state.EngRPM;\r\n  state.DSRPM0 = state.DSRPM;\r\n  \r\n  // TIMESLIP.FRM:1093-1094 - Special handling for first step at launch\r\n  // If RPM0 = LaunchRPM And Time0 = 0 Then\r\n  //     RPM0 = Stall: If LaunchRPM < Stall Then Time0 = EnginePMI * (Stall - LaunchRPM) / 250000\r\n  if (state.RPM0 === vehicle.LaunchRPM && state.Time0_s === 0) {\r\n    state.RPM0 = vehicle.Stall;\r\n    if (vehicle.LaunchRPM < vehicle.Stall) {\r\n      state.Time0_s = vehicle.EnginePMI * (vehicle.Stall - vehicle.LaunchRPM) / 250000;\r\n    }\r\n  }\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1091 - Update tire growth\r\n  // ========================================================================\r\n  const tireResult = vb6Tire(vehicle.TireDia_in, vehicle.TireWidth_in, state.Vel_ftps, state.Ags0_g, env.isLandSpeed);\r\n  state.TireGrowth = tireResult.TireGrowth;\r\n  state.TireCirFt = tireResult.TireCirFt;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1098-1102 - Calculate tire slip\r\n  // VB6: Different formulas for Quarter Pro vs Bonneville Pro\r\n  // ========================================================================\r\n  let TireSlip: number;\r\n  if (env.isLandSpeed) {\r\n    // Bonneville Pro: TIMESLIP.FRM:875\r\n    // TireSlip = 1.01 + (gc_TractionIndex.Value - 1) * 0.01\r\n    // Note: No distance-based reduction for BVPro\r\n    TireSlip = 1.01 + (env.TractionIndex - 1) * 0.01;\r\n  } else {\r\n    // Quarter Pro: TIMESLIP.FRM:1098-1101\r\n    // Work = 0.005 * (TractionIndex - 1) + 3 * (TrackTempEffect - 1)\r\n    // TireSlip = 1.02 + Work * (1 - (Dist0 / 1320) ^ 2)\r\n    const Work_slip = 0.005 * (env.TractionIndex - 1) + 3 * (env.TrackTempEffect - 1);\r\n    TireSlip = 1.02 + Work_slip * (1 - Math.pow(state.Dist0_ft / 1320, 2));\r\n  }\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1074-1075 - Calculate chassis PMI for this gear\r\n  // ChassisPMI = TiresPMI + TransPMI * GearRatio^2 * TGR(iGear)^2\r\n  // ========================================================================\r\n  const TGR_gear = vehicle.TGR[iGear - 1] ?? 1; // Convert to 0-indexed\r\n  const ChassisPMI = vehicle.TiresPMI + vehicle.TransPMI * Math.pow(vehicle.GearRatio, 2) * Math.pow(TGR_gear, 2);\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1107 - Estimate next velocity (first pass)\r\n  // Vel(L) = Vel0 + Ags0 * gc * TimeStep + Jerk * gc * TimeStep^2 / 2\r\n  // ========================================================================\r\n  let Vel_L = state.Vel0_ftps + state.Ags0_g * gc * TimeStep + Jerk * gc * TimeStep * TimeStep / 2;\r\n  \r\n  // Sanity check: velocity should never go negative or drop dramatically\r\n  // At terminal velocity, maintain current speed\r\n  if (Vel_L < state.Vel0_ftps * 0.9 && state.Vel0_ftps > 100) {\r\n    // Velocity dropped more than 10% at high speed - likely numerical issue\r\n    Vel_L = state.Vel0_ftps;\r\n  }\r\n  if (Vel_L < 0) Vel_L = 0;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1109 - Skip timestep limiting during shift\r\n  // If ShiftFlag = 2 Then GoTo 270\r\n  // ========================================================================\r\n  const ShiftRPM_gear = vehicle.ShiftRPM[iGear - 1] ?? 9000;\r\n  \r\n  if (!gearChanged) {\r\n    // Only apply timestep limits when NOT in a gear change\r\n    // TIMESLIP.FRM:1111-1120 - Limit timestep\r\n    // TIMESLIP.FRM:1064 - Minimum timestep (from TSMax init)\r\n    if (TimeStep < 0.005) TimeStep = 0.005;\r\n    // TIMESLIP.FRM:1120 - Absolute max timestep\r\n    if (TimeStep > 0.05) TimeStep = 0.05;\r\n    \r\n    // Recalculate velocity with limited timestep\r\n    Vel_L = state.Vel0_ftps + state.Ags0_g * gc * TimeStep + Jerk * gc * TimeStep * TimeStep / 2;\r\n    \r\n    // TIMESLIP.FRM:1125-1129 - Limit velocity to shift point\r\n    if (state.Vel0_ftps > 0 && state.RPM0 > vehicle.Stall && iGear < vehicle.NGR) {\r\n      const VelAtShift = state.Vel0_ftps * (ShiftRPM_gear + 5) / state.RPM0;\r\n      if (Vel_L > VelAtShift) {\r\n        Vel_L = VelAtShift;\r\n        // Recalculate timestep to match this velocity\r\n        if (state.Ags0_g * gc > 0) {\r\n          TimeStep = (Vel_L - state.Vel0_ftps) / (state.Ags0_g * gc);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // During gear change (gearChanged=true), TimeStep=DTShift is used without limiting\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1139 - Calculate VelSqrd\r\n  // VelSqrd = Vel(L)^2 - Vel0^2\r\n  // ========================================================================\r\n  const VelSqrd = Vel_L * Vel_L - state.Vel0_ftps * state.Vel0_ftps;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1140 - Calculate DSRPM\r\n  // DSRPM = TireSlip * Vel(L) * 60 / TireCirFt\r\n  // ========================================================================\r\n  const DSRPM = TireSlip * Vel_L * 60 / state.TireCirFt;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1144-1174 - Clutch/Converter calculations\r\n  // ========================================================================\r\n  const LockRPM = DSRPM * vehicle.GearRatio * TGR_gear;\r\n  let EngRPM_L = vehicle.Slippage * LockRPM;\r\n  let ClutchSlip: number;\r\n  let zStall = vehicle.Stall;\r\n  let SlipRatio = 0;\r\n  \r\n  if (vehicle.isClutch) {\r\n    // TIMESLIP.FRM:1148-1152 - Clutch\r\n    if (EngRPM_L < vehicle.Stall) {\r\n      if (iGear === 1 || !vehicle.LockUp) {\r\n        EngRPM_L = vehicle.Stall;\r\n      }\r\n    }\r\n    ClutchSlip = LockRPM / EngRPM_L;\r\n  } else {\r\n    // TIMESLIP.FRM:1154-1172 - Converter\r\n    if (iGear === 1 || !vehicle.LockUp) {\r\n      // Non lock-up converter\r\n      zStall = vehicle.Stall;\r\n      SlipRatio = vehicle.Slippage * LockRPM / zStall;\r\n      \r\n      if (state.L > 2) {\r\n        if (SlipRatio > 0.6) {\r\n          zStall = zStall * (1 + (vehicle.Slippage - 1) * (SlipRatio - 0.6) / ((1 / vehicle.Slippage) - 0.6));\r\n        }\r\n        SlipRatio = vehicle.Slippage * LockRPM / zStall;\r\n      }\r\n      ClutchSlip = 1 / vehicle.Slippage;\r\n      \r\n      if (EngRPM_L < zStall) {\r\n        EngRPM_L = zStall;\r\n        const Work_conv = vehicle.TorqueMult - (vehicle.TorqueMult - 1) * SlipRatio;\r\n        ClutchSlip = Work_conv * LockRPM / zStall;\r\n      }\r\n    } else {\r\n      // Lock-up converter\r\n      EngRPM_L = 1.005 * LockRPM; // 0.5% slippage\r\n      ClutchSlip = LockRPM / EngRPM_L;\r\n    }\r\n  }\r\n  if (ClutchSlip > 1) ClutchSlip = 1;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1176-1178 - Get HP from curve\r\n  // ========================================================================\r\n  let HP = TABY(vehicle.xrpm, vehicle.yhp, vehicle.NHP, 1, EngRPM_L);\r\n  HP = vehicle.HPTQMult * HP / env.hpc;\r\n  \r\n  // Rev limiter - cut power above the limit RPM\r\n  // This simulates a high-side rev limiter that cuts fuel/spark\r\n  if (vehicle.RevLimiterRPM > 0 && EngRPM_L >= vehicle.RevLimiterRPM) {\r\n    // Hard cut - reduce HP to near zero (simulates fuel/spark cut)\r\n    HP = HP * 0.05; // 5% power at limiter (enough to maintain RPM, not accelerate)\r\n  }\r\n  \r\n  // Apply throttle stop if configured (bracket racing feature)\r\n  // This reduces HP during the specified time window\r\n  const throttleStopMult = calcThrottleStopMultiplier(state.time_s, throttleStop);\r\n  HP = HP * throttleStopMult;\r\n  \r\n  const HPSave = HP;\r\n  HP = HP * ClutchSlip;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1180-1194 - Calculate drag forces\r\n  // ========================================================================\r\n  // Wind effective velocity\r\n  const WindFPS = Math.sqrt(\r\n    Vel_L * Vel_L + \r\n    2 * Vel_L * (env.WindSpeed_mph / Z5) * Math.cos(PI * env.WindAngle_deg / 180) + \r\n    Math.pow(env.WindSpeed_mph / Z5, 2)\r\n  );\r\n  \r\n  // Dynamic pressure (VB6 uses lbm/ft³ for rho, divides by gc)\r\n  const q = Math.sign(WindFPS) * env.rho * Math.pow(Math.abs(WindFPS), 2) / (2 * gc);\r\n  \r\n  // Frontal area with tire growth\r\n  let RefArea2: number;\r\n  if (vehicle.BodyStyle === 8) {\r\n    // Motorcycle\r\n    RefArea2 = vehicle.RefArea_ft2 + ((state.TireGrowth - 1) * vehicle.TireDia_in / 2) * vehicle.TireWidth_in / 144;\r\n  } else {\r\n    RefArea2 = vehicle.RefArea_ft2 + ((state.TireGrowth - 1) * vehicle.TireDia_in / 2) * (2 * vehicle.TireWidth_in) / 144;\r\n  }\r\n  \r\n  // Down force (weight + aero lift)\r\n  const DownForce = vehicle.Weight_lbf + vehicle.LiftCoef * RefArea2 * q;\r\n  \r\n  // Select constants based on land speed mode\r\n  // VB6: TIMESLIP.FRM:550-570 - different constants for ISBVPRO\r\n  const cmu_const = env.isLandSpeed ? CMU_BV : CMU;\r\n  const cmuk_const = env.isLandSpeed ? CMUK_BV : CMUK;\r\n  const frct_const = env.isLandSpeed ? FRCT_BV : FRCT;\r\n  \r\n  // Rolling resistance coefficient (decreases with distance for QPro, constant for BVPro)\r\n  const cmu1 = cmu_const - (state.Dist0_ft / 1320) * cmuk_const;\r\n  \r\n  // Total drag force\r\n  const DragForce = cmu1 * DownForce + 0.0001 * DownForce * (Z5 * Vel_L) + vehicle.DragCoef * RefArea2 * q;\r\n  const DragHP = DragForce * Vel_L / 550;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1196-1211 - Calculate dynamic weight transfer\r\n  // ========================================================================\r\n  const TireRadIn = 12 * state.TireCirFt / (2 * PI);\r\n  const deltaFWT = (state.Ags0_g * vehicle.Weight_lbf * ((vehicle.YCG_in - TireRadIn) + (frct_const / vehicle.Efficiency) * TireRadIn) + DragForce * vehicle.YCG_in) / vehicle.Wheelbase_in;\r\n  let DynamicFWT = vehicle.StaticFWt_lbf - deltaFWT;\r\n  \r\n  // Wheelie bar\r\n  let WheelBarWT = 0;\r\n  if (DynamicFWT < 0) {\r\n    WheelBarWT = -DynamicFWT * vehicle.Wheelbase_in / 64;\r\n    DynamicFWT = 0;\r\n  }\r\n  \r\n  // Dynamic rear weight\r\n  let DynamicRWT = DownForce - DynamicFWT - WheelBarWT;\r\n  if (DynamicRWT < 0) DynamicRWT = vehicle.Weight_lbf;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1213-1216 - Calculate AMax (traction limit)\r\n  // ========================================================================\r\n  const CAXI = calcCAXI(env.TractionIndex, env.TrackTempEffect);\r\n  const AX_val = calcAX(env.isLandSpeed);\r\n  let CRTF = CAXI * AX_val * vehicle.TireDia_in * (vehicle.TireWidth_in + 1) * (0.92 + 0.08 * Math.pow(DynamicRWT / 1900, 2.15));\r\n  if (vehicle.BodyStyle === 8) CRTF = 0.5 * CRTF;\r\n  \r\n  const AMax_g = ((CRTF / state.TireGrowth) - DragForce) / vehicle.Weight_lbf;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1218-1229 - Initial HP chain and time estimate\r\n  // VB6: HP = HP * TGEff(iGear) * Efficiency / TireSlip - DragHP\r\n  // \r\n  // NOTE: TorqueMult is handled through ClutchSlip when converter is stalling.\r\n  // The VB6 HP chain does NOT directly apply TorqueMult - it's incorporated via ClutchSlip.\r\n  // ========================================================================\r\n  const TGEff_gear = vehicle.TGEff[iGear - 1] ?? 0.99;\r\n  HP = HP * TGEff_gear * vehicle.Efficiency / TireSlip;\r\n  const HPAtWheels = HP;  // HP at wheels BEFORE subtracting drag (for plotting)\r\n  HP = HP - DragHP;\r\n  \r\n  let PQWT = 550 * gc * HP / vehicle.Weight_lbf;\r\n  let AGS_g = PQWT / (Vel_L * gc);\r\n  \r\n  // TIMESLIP.FRM:1223-1228 - Initial AMin/AMax clamps\r\n  // VB6 uses reflection formula: AGS = AMAX - (AGS - AMAX) = 2*AMAX - AGS\r\n  // This can produce negative values when AGS >> AMAX, which then get clamped to AMin\r\n  let SLIP = false;\r\n  if (AGS_g > AMax_g) {\r\n    SLIP = true;\r\n    PQWT = PQWT * (AMax_g - (AGS_g - AMax_g)) / AGS_g;\r\n    AGS_g = AMax_g - (AGS_g - AMax_g);\r\n  }\r\n  if (AGS_g < AMin) {\r\n    // VB6: TIMESLIP.FRM:1226 - Clamp to AMin\r\n    // When AGS is clamped, PQWT must be recalculated to be consistent\r\n    // PQWT = AGS * gc * Vel, so if AGS = AMin, PQWT = AMin * gc * Vel\r\n    AGS_g = AMin;\r\n    PQWT = AMin * gc * Vel_L;\r\n  }\r\n  \r\n  // Initial time estimate\r\n  // VB6: time(L) = VelSqrd / (2 * PQWT) + Time0\r\n  // Protect against negative VelSqrd (shouldn't happen with AMin clamp)\r\n  const safeVelSqrd = Math.max(0, VelSqrd);\r\n  let time_L = safeVelSqrd / (2 * PQWT) + state.Time0_s;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1231-1240 - Calculate acceleration HP terms\r\n  // ========================================================================\r\n  // Select KP21/KP22 based on land speed mode\r\n  // VB6: TIMESLIP.FRM:557-558 (QPro) vs 567-568 (BVPro)\r\n  const kp21_const = env.isLandSpeed ? KP21_BV : KP21;\r\n  const kp22_const = env.isLandSpeed ? KP22_BV : KP22;\r\n  \r\n  let EngAccHP = vehicle.EnginePMI * EngRPM_L * (EngRPM_L - state.RPM0);\r\n  if (EngAccHP < 0) {\r\n    if (vehicle.isClutch) {\r\n      EngAccHP = kp21_const * EngAccHP;\r\n    } else {\r\n      EngAccHP = kp22_const * EngAccHP;\r\n    }\r\n  }\r\n  \r\n  let ChasAccHP = ChassisPMI * DSRPM * (DSRPM - state.DSRPM0);\r\n  if (ChasAccHP < 0) ChasAccHP = 0;\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1244-1276 - ITERATION LOOP\r\n  // ========================================================================\r\n  let HPEngPMI = 0;\r\n  let HPChasPMI = 0;\r\n  let k = 0;\r\n  \r\n  for (k = 1; k <= 12; k++) {\r\n    const dtk1 = time_L - state.Time0_s;\r\n    if (dtk1 <= 0) break;\r\n    \r\n    // TIMESLIP.FRM:1247-1248\r\n    const Work = Math.pow(2 * PI / 60, 2) / (12 * 550 * dtk1);\r\n    HPEngPMI = EngAccHP * Work;\r\n    HPChasPMI = ChasAccHP * Work;\r\n    \r\n    // TIMESLIP.FRM:1250-1253\r\n    // VB6: HP = (HPSave - HPEngPMI) * ClutchSlip\r\n    // VB6: HP = ((HP * TGEff(iGear) * Efficiency - HPChasPMI) / TireSlip) - DragHP\r\n    HP = (HPSave - HPEngPMI) * ClutchSlip;\r\n    HP = ((HP * TGEff_gear * vehicle.Efficiency - HPChasPMI) / TireSlip) - DragHP;\r\n    PQWT = 550 * gc * HP / vehicle.Weight_lbf;\r\n    AGS_g = PQWT / (Vel_L * gc);\r\n    \r\n    // TIMESLIP.FRM:1255-1258 - Jerk limits\r\n    let Jerk_iter = 0;\r\n    if (dtk1 !== 0) {\r\n      Jerk_iter = (AGS_g - state.Ags0_g) / dtk1;\r\n    }\r\n    if (Jerk_iter < JMin) {\r\n      Jerk_iter = JMin;\r\n      AGS_g = state.Ags0_g + Jerk_iter * dtk1;\r\n      PQWT = AGS_g * gc * Vel_L;\r\n    }\r\n    if (Jerk_iter > JMax) {\r\n      Jerk_iter = JMax;\r\n      AGS_g = state.Ags0_g + Jerk_iter * dtk1;\r\n      PQWT = AGS_g * gc * Vel_L;\r\n    }\r\n    \r\n    // TIMESLIP.FRM:1260-1266 - AMin/AMax clamps\r\n    // VB6 uses reflection formula: AGS = AMAX - (AGS - AMAX) = 2*AMAX - AGS\r\n    // This can produce negative values when AGS >> AMAX, which then get clamped to AMin\r\n    SLIP = false;\r\n    if (AGS_g > AMax_g) {\r\n      SLIP = true;\r\n      PQWT = PQWT * (AMax_g - (AGS_g - AMax_g)) / AGS_g;\r\n      AGS_g = AMax_g - (AGS_g - AMax_g);\r\n    }\r\n    if (AGS_g < AMin) {\r\n      // VB6: TIMESLIP.FRM:1266 - Scale PQWT proportionally, then clamp AGS\r\n      // VB6: PQWT = PQWT * AMin / AGS(L): AGS(L) = AMin\r\n      PQWT = PQWT * AMin / AGS_g;\r\n      AGS_g = AMin;\r\n    }\r\n    \r\n    // TIMESLIP.FRM:1268-1270 - New time estimate and convergence check\r\n    // Protect against negative VelSqrd (shouldn't happen with AMin clamp)\r\n    const safeVelSqrd_iter = Math.max(0, VelSqrd);\r\n    const dtk2_time = safeVelSqrd_iter / (2 * PQWT) + state.Time0_s;\r\n    const dtk2 = dtk2_time - state.Time0_s;\r\n    \r\n    if (k === 12 || Math.abs(100 * (dtk2 - dtk1) / dtk2) <= 0.01) {\r\n      time_L = dtk2_time;\r\n      break;\r\n    }\r\n    \r\n    // TIMESLIP.FRM:1272-1275 - Relaxation for next iteration\r\n    let z = HP / HPSave;\r\n    if (z < K6) z = K6;\r\n    if (z > K61) z = K61;\r\n    time_L = state.Time0_s + dtk1 + z * (dtk2 - dtk1);\r\n  }\r\n  \r\n  // ========================================================================\r\n  // TIMESLIP.FRM:1280 - Calculate distance after convergence\r\n  // Dist(L) = ((2*PQWT*(time(L)-Time0) + Vel0^2)^1.5 - Vel0^3) / (3*PQWT) + Dist0\r\n  // ========================================================================\r\n  const dt_final = time_L - state.Time0_s;\r\n  let Dist_L: number;\r\n  \r\n  // At terminal velocity, PQWT is very small or negative, so use simple distance = velocity * time\r\n  // The complex VB6 formula can produce NaN when PQWT is negative (drag > power)\r\n  if (PQWT < 0.1 || dt_final <= 0) {\r\n    // Near terminal velocity or invalid timestep - use average velocity for distance\r\n    const avgVel = (state.Vel0_ftps + Vel_L) / 2;\r\n    Dist_L = state.Dist0_ft + Math.max(0, avgVel * Math.abs(dt_final));\r\n  } else {\r\n    const Vel0_cubed = Math.pow(state.Vel0_ftps, 3);\r\n    const term = 2 * PQWT * dt_final + state.Vel0_ftps * state.Vel0_ftps;\r\n    if (term < 0) {\r\n      // Numerical instability - fall back to simple formula\r\n      const avgVel = (state.Vel0_ftps + Vel_L) / 2;\r\n      Dist_L = state.Dist0_ft + avgVel * dt_final;\r\n    } else {\r\n      Dist_L = (Math.pow(term, 1.5) - Vel0_cubed) / (3 * PQWT) + state.Dist0_ft;\r\n    }\r\n  }\r\n  \r\n  // ========================================================================\r\n  // Update state\r\n  // ========================================================================\r\n  state.L += 1;\r\n  state.time_s = time_L;\r\n  state.Vel_ftps = Vel_L;\r\n  state.Dist_ft = Dist_L;\r\n  state.AGS_g = AGS_g;\r\n  state.EngRPM = EngRPM_L;\r\n  state.DSRPM = DSRPM;\r\n  state.SLIP = SLIP;\r\n  \r\n  // VB6: AgsMax is set ONCE at launch (line 1028) and never updated\r\n  // It's the initial launch acceleration, NOT the maximum seen during the run\r\n  // Do NOT update AgsMax_g here - it should remain at the initial value\r\n  \r\n  return {\r\n    TimeStep_s: TimeStep,\r\n    VelSqrd,\r\n    LockRPM,\r\n    ClutchSlip,\r\n    zStall,\r\n    SlipRatio,\r\n    TireSlip,\r\n    WindFPS,\r\n    q,\r\n    RefArea2_ft2: RefArea2,\r\n    DownForce_lbf: DownForce,\r\n    DragForce_lbf: DragForce,\r\n    DragHP,\r\n    DynamicFWT_lbf: DynamicFWT,\r\n    DynamicRWT_lbf: DynamicRWT,\r\n    WheelBarWT_lbf: WheelBarWT,\r\n    CRTF,\r\n    AMax_g,\r\n    ChassisPMI,\r\n    EngAccHP,\r\n    ChasAccHP,\r\n    HPSave,\r\n    HPAtWheels,\r\n    HP,\r\n    PQWT,\r\n    iterations: k,\r\n  };\r\n}\r\n\r\n/**\r\n * Initialize VB6 simulation state\r\n */\r\nexport function vb6InitState(\r\n  vehicle: VB6VehicleParams,\r\n  env: VB6EnvParams,\r\n  launchRPM: number\r\n): VB6SimState {\r\n  // VB6: TIMESLIP.FRM:1003-1057 - Initialize launch conditions\r\n  // L = 1: Time0 = 0: time(L) = 0: Vel(L) = 0: Dist(L) = 0: DSRPM = 0\r\n  \r\n  // Initial tire calculations (at zero velocity)\r\n  const tireResult = vb6Tire(vehicle.TireDia_in, vehicle.TireWidth_in, 0, 0, env.isLandSpeed);\r\n  \r\n  // VB6: TIMESLIP.FRM:1010-1014 - Get HP and calculate torque\r\n  // Call TABY(xrpm(), yhp(), NHP, 1, EngRPM(L), HP)\r\n  // HP = gc_HPTQMult.Value * HP / hpc\r\n  // TQ = Z6 * HP / EngRPM(L)\r\n  // TQ = TQ * gc_TorqueMult.Value * TGR(iGear) * TGEff(iGear)\r\n  const HP_launch = TABY(vehicle.xrpm, vehicle.yhp, vehicle.NHP, 1, launchRPM);\r\n  const HP_corrected = vehicle.HPTQMult * HP_launch / env.hpc;\r\n  const Z6 = 5252;\r\n  let TQ = Z6 * HP_corrected / launchRPM;\r\n  const TGR_1 = vehicle.TGR[0] ?? 1;\r\n  const TGEff_1 = vehicle.TGEff[0] ?? 0.99;\r\n  TQ = TQ * vehicle.TorqueMult * TGR_1 * TGEff_1;\r\n  \r\n  // VB6: TIMESLIP.FRM:1016-1019 - Calculate drag force at launch (Vel=0)\r\n  // WindFPS = Sqr(Vel(L)^2 + ...) = WindSpeed/Z5 at Vel=0\r\n  // q = Sgn(WindFPS) * rho * Abs(WindFPS)^2 / (2*gc)\r\n  // DragForce = CMU * Weight + DragCoef * RefArea * q\r\n  const cmu_launch = env.isLandSpeed ? CMU_BV : CMU;\r\n  const WindFPS_launch = env.WindSpeed_mph / Z5;\r\n  const q_launch = Math.sign(WindFPS_launch) * env.rho * Math.pow(Math.abs(WindFPS_launch), 2) / (2 * gc);\r\n  const DragForce_launch = cmu_launch * vehicle.Weight_lbf + vehicle.DragCoef * vehicle.RefArea_ft2 * q_launch;\r\n  \r\n  // VB6: TIMESLIP.FRM:872-875 - Initial tire slip\r\n  // Different formulas for Quarter Pro vs Bonneville Pro\r\n  let TireSlip_init: number;\r\n  if (env.isLandSpeed) {\r\n    // Bonneville Pro: TIMESLIP.FRM:875\r\n    // TireSlip = 1.01 + (gc_TractionIndex.Value - 1) * 0.01\r\n    TireSlip_init = 1.01 + (env.TractionIndex - 1) * 0.01;\r\n  } else {\r\n    // Quarter Pro: TIMESLIP.FRM:872\r\n    // TireSlip = 1.02 + (gc_TractionIndex.Value - 1) * 0.005 + (TrackTempEffect - 1) * 3\r\n    TireSlip_init = 1.02 + (env.TractionIndex - 1) * 0.005 + (env.TrackTempEffect - 1) * 3;\r\n  }\r\n  \r\n  // VB6: TIMESLIP.FRM:1020 - Calculate wheel force\r\n  // force = TQ * GearRatio * Efficiency / (TireSlip * TireDia / 24) - DragForce\r\n  const force = TQ * vehicle.GearRatio * vehicle.Efficiency / (TireSlip_init * vehicle.TireDia_in / 24) - DragForce_launch;\r\n  \r\n  // VB6: TIMESLIP.FRM:1022-1027 - Estimate initial acceleration\r\n  // If gc_TransType.Value Then (converter)\r\n  //     Ags0 = 0.96 * force / Weight  '4% misc losses\r\n  // Else (clutch)\r\n  //     Ags0 = 0.88 * force / Weight  '12% misc losses\r\n  const lossFactor = vehicle.isClutch ? 0.88 : 0.96;\r\n  let Ags0_g = lossFactor * force / vehicle.Weight_lbf;\r\n  \r\n  // VB6: TIMESLIP.FRM:1046-1054 - Calculate AMAX and clamp Ags0\r\n  // StaticRWT = DownForce - StaticFWt: If StaticRWT < 0 Then StaticRWT = Weight\r\n  const DownForce_init = vehicle.Weight_lbf;\r\n  let StaticRWT = DownForce_init - vehicle.StaticFWt_lbf;\r\n  if (StaticRWT < 0) StaticRWT = vehicle.Weight_lbf;\r\n  \r\n  // CAXI = (1 - (TractionIndex - 1) * 0.01) / (TrackTempEffect ^ 0.25)\r\n  const CAXI_init = calcCAXI(env.TractionIndex, env.TrackTempEffect);\r\n  const AX_init = calcAX(env.isLandSpeed);\r\n  \r\n  // CRTF = CAXI * AX * TireDia * (TireWidth + 1) * (0.92 + 0.08 * (StaticRWT / 1900) ^ 2.15)\r\n  let CRTF_init = CAXI_init * AX_init * vehicle.TireDia_in * (vehicle.TireWidth_in + 1) * \r\n                  (0.92 + 0.08 * Math.pow(StaticRWT / 1900, 2.15));\r\n  if (vehicle.BodyStyle === 8) CRTF_init = 0.5 * CRTF_init;\r\n  \r\n  // AMAX = (CRTF - DragForce) / Weight\r\n  const AMax_init = (CRTF_init - DragForce_launch) / vehicle.Weight_lbf;\r\n  \r\n  // VB6: TIMESLIP.FRM:1055-1056 - Clamp Ags0 to AMax/AMin\r\n  // If Ags0 > AMAX Then Ags0 = AMAX: SLIP(L) = 1\r\n  // If Ags0 < AMin Then Ags0 = AMin\r\n  if (Ags0_g > AMax_init) Ags0_g = AMax_init;\r\n  if (Ags0_g < AMin) Ags0_g = AMin;\r\n  \r\n  return {\r\n    L: 1,\r\n    time_s: 0,\r\n    Vel_ftps: 0.001, // Small non-zero to avoid division by zero\r\n    Dist_ft: 0,\r\n    AGS_g: Ags0_g,\r\n    EngRPM: launchRPM,\r\n    DSRPM: 0,\r\n    Gear: 1,\r\n    SLIP: false,\r\n    \r\n    Vel0_ftps: 0,\r\n    Ags0_g: Ags0_g,\r\n    Time0_s: 0,\r\n    Dist0_ft: 0,\r\n    RPM0: launchRPM,\r\n    DSRPM0: 0,\r\n    \r\n    AgsMax_g: Ags0_g,\r\n    TireGrowth: tireResult.TireGrowth,\r\n    TireCirFt: tireResult.TireCirFt,\r\n    \r\n    // Shift tracking\r\n    ShiftFlag: 0,\r\n    PrevGear: 1,\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate TSMax (maximum timestep) per VB6 initialization\r\n * TIMESLIP.FRM:1062-1064\r\n */\r\nexport function vb6CalcTSMaxInit(\r\n  DistToPrint1_ft: number,\r\n  HP: number,\r\n  TorqueMult: number,\r\n  Weight_lbf: number\r\n): number {\r\n  // TSMax = DistToPrint(1) * 0.11 * (HP * TorqueMult / Weight)^(-1/3)\r\n  // TSMax = TSMax / 15\r\n  let TSMax = DistToPrint1_ft * 0.11 * Math.pow(HP * TorqueMult / Weight_lbf, -1/3);\r\n  TSMax = TSMax / 15;\r\n  if (TSMax < 0.005) TSMax = 0.005;\r\n  return TSMax;\r\n}\r\n","/**\r\n * VB6 EXACT PORT - TABY and DTABY Interpolation Functions\r\n * \r\n * Source: RSALIB.BAS lines 11-141, 471-573\r\n * \r\n * These are the exact VB6 Lagrangian interpolation routines used for:\r\n * - HP curve interpolation (TABY - 1D)\r\n * - ENGINE() synthetic curve generation (DTABY - 2D)\r\n */\r\n\r\n/**\r\n * Binary search for interpolation bracket\r\n * VB6: RSALIB.BAS lines 11-79 (BISC subroutine)\r\n * \r\n * @param X Array of x values (1-indexed in VB6, 0-indexed here)\r\n * @param XVAL Value to find\r\n * @param N Number of points\r\n * @returns { KBOTM, KTOP, JJ } - bracket indices and boundary flag\r\n */\r\nexport function bisc(\r\n  X: number[],\r\n  XVAL: number,\r\n  N: number\r\n): { KBOTM: number; KTOP: number; JJ: number } {\r\n  let JJ = 0;\r\n  let KBOTM = 0;  // 0-indexed (VB6 uses 1)\r\n  let KTOP = N - 1;  // 0-indexed (VB6 uses N)\r\n  \r\n  const X1 = X[0];\r\n  const XN = X[N - 1];\r\n  \r\n  // Check if XVAL is outside the range\r\n  if (XVAL <= X1) {\r\n    JJ = 1;\r\n    KTOP = 1;\r\n    return { KBOTM, KTOP, JJ };\r\n  }\r\n  \r\n  if (XVAL >= XN) {\r\n    JJ = 1;\r\n    KBOTM = N - 2;\r\n    KTOP = N - 1;\r\n    return { KBOTM, KTOP, JJ };\r\n  }\r\n  \r\n  // Binary search\r\n  while (KTOP - KBOTM > 1) {\r\n    const KMID = Math.floor((KBOTM + KTOP) / 2);\r\n    if (XVAL < X[KMID]) {\r\n      KTOP = KMID;\r\n    } else {\r\n      KBOTM = KMID;\r\n    }\r\n  }\r\n  \r\n  return { KBOTM, KTOP, JJ };\r\n}\r\n\r\n/**\r\n * 1D Lagrangian Interpolation\r\n * VB6: RSALIB.BAS lines 531-573 (TABY subroutine)\r\n * \r\n * @param XTAB X values array (0-indexed)\r\n * @param YTAB Y values array (0-indexed)\r\n * @param N Number of points\r\n * @param L Interpolation order (1=linear, 2=quadratic, 3=cubic)\r\n * @param XVAL X value to interpolate\r\n * @returns Interpolated Y value\r\n */\r\nexport function taby(\r\n  XTAB: number[],\r\n  YTAB: number[],\r\n  N: number,\r\n  L: number,\r\n  XVAL: number\r\n): number {\r\n  // Handle edge cases\r\n  if (N <= 0) return 0;\r\n  if (N === 1) return YTAB[0];\r\n  \r\n  let KBOTM = 0;\r\n  let KTOP = 1;\r\n  \r\n  if (N === 2) {\r\n    // Linear interpolation between two points\r\n    KBOTM = 0;\r\n    KTOP = 1;\r\n  } else {\r\n    // Use binary search for 3+ points\r\n    const result = bisc(XTAB, XVAL, N);\r\n    KBOTM = result.KBOTM;\r\n    KTOP = result.KTOP;\r\n    const JJ = result.JJ;\r\n    \r\n    if (KBOTM === KTOP) {\r\n      return YTAB[KBOTM];\r\n    }\r\n    \r\n    // Expand bracket based on interpolation order\r\n    if (JJ !== 1 && L > 1) {\r\n      KTOP = KTOP + 1;\r\n      if (L >= 3 || KTOP > N - 1) {\r\n        if (KTOP > N - 1) KTOP = N - 1;\r\n        KBOTM = KBOTM - 1;\r\n        if (KBOTM < 0) KBOTM = 0;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Calculate Lagrange coefficients\r\n  let YVAL = 0;\r\n  for (let j = KBOTM; j <= KTOP; j++) {\r\n    let P = 1;\r\n    const xtabj = XTAB[j];\r\n    for (let i = KBOTM; i <= KTOP; i++) {\r\n      if (i === j) {\r\n        P = P * YTAB[j];\r\n      } else {\r\n        const xtabi = XTAB[i];\r\n        P = P * (XVAL - xtabi) / (xtabj - xtabi);\r\n      }\r\n    }\r\n    YVAL = YVAL + P;\r\n  }\r\n  \r\n  return YVAL;\r\n}\r\n\r\n/**\r\n * 2D Lagrangian Interpolation\r\n * VB6: RSALIB.BAS lines 81-141 (DTABY subroutine)\r\n * \r\n * Interpolates a 2D table where:\r\n * - XTAB is the row variable (e.g., RPM ratio)\r\n * - ZTAB is the column variable (e.g., HP/CID ratio)\r\n * - YTAB is a flattened 2D array stored column-major\r\n * \r\n * @param XTAB X values array (row variable, 0-indexed)\r\n * @param ZTAB Z values array (column variable, 0-indexed)\r\n * @param YTAB Y values 2D array flattened column-major (0-indexed)\r\n * @param NX Number of X points\r\n * @param NZ Number of Z points\r\n * @param LX X interpolation order\r\n * @param LZ Z interpolation order\r\n * @param XVAL X value to interpolate\r\n * @param ZVAL Z value to interpolate\r\n * @returns Interpolated Y value\r\n */\r\nexport function dtaby(\r\n  XTAB: number[],\r\n  ZTAB: number[],\r\n  YTAB: number[],  // Flattened 2D array, column-major: YTAB[z * NX + x]\r\n  NX: number,\r\n  NZ: number,\r\n  LX: number,\r\n  LZ: number,\r\n  XVAL: number,\r\n  ZVAL: number\r\n): number {\r\n  // Handle single column case\r\n  if (NZ === 1) {\r\n    // Extract column and interpolate in X\r\n    const YX: number[] = [];\r\n    for (let i = 0; i < NX; i++) {\r\n      YX.push(YTAB[i]);\r\n    }\r\n    return taby(XTAB, YX, NX, LX, XVAL);\r\n  }\r\n  \r\n  // Find Z bracket\r\n  const zResult = bisc(ZTAB, ZVAL, NZ);\r\n  let KBOTM = zResult.KBOTM;\r\n  let KTOP = zResult.KTOP;\r\n  const JJ = zResult.JJ;\r\n  \r\n  // Expand Z bracket based on interpolation order\r\n  if (JJ !== 1 && LZ > 1) {\r\n    KTOP = KTOP + 1;\r\n    if (LZ >= 3 || KTOP > NZ - 1) {\r\n      if (KTOP > NZ - 1) KTOP = NZ - 1;\r\n      KBOTM = KBOTM - 1;\r\n      if (KBOTM < 0) KBOTM = 0;\r\n    }\r\n  }\r\n  \r\n  // For each Z in bracket, interpolate in X direction\r\n  const YY: number[] = [];\r\n  const ZZ: number[] = [];\r\n  \r\n  for (let i = KBOTM; i <= KTOP; i++) {\r\n    // Extract column i\r\n    const YX: number[] = [];\r\n    for (let j = 0; j < NX; j++) {\r\n      YX.push(YTAB[i * NX + j]);\r\n    }\r\n    // Interpolate in X\r\n    const yInterp = taby(XTAB, YX, NX, LX, XVAL);\r\n    YY.push(yInterp);\r\n    ZZ.push(ZTAB[i]);\r\n  }\r\n  \r\n  // Interpolate in Z direction\r\n  const L2 = KTOP - KBOTM + 1;\r\n  const L4 = Math.min(LZ, L2);\r\n  return taby(ZZ, YY, L2, L4, ZVAL);\r\n}\r\n\r\n/**\r\n * Helper to convert VB6 1-indexed 2D array to 0-indexed flattened array\r\n * VB6 stores: sY(row + (col-1)*NX) where row=1..NX, col=1..NZ\r\n * We store: YTAB[col * NX + row] where row=0..NX-1, col=0..NZ-1\r\n */\r\nexport function flattenVB6Array(\r\n  sY: number[][],  // sY[row][col] where row=1..NX, col=1..NZ (1-indexed)\r\n  NX: number,\r\n  NZ: number\r\n): number[] {\r\n  const result: number[] = [];\r\n  for (let col = 0; col < NZ; col++) {\r\n    for (let row = 0; row < NX; row++) {\r\n      // VB6 uses 1-indexed, so sY[row+1][col+1]\r\n      result.push(sY[row + 1]?.[col + 1] ?? 0);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Simple linear interpolation (for compatibility with existing code)\r\n * This is a simplified version that matches the basic TABY behavior\r\n */\r\nexport function tabyLinear(\r\n  xrpm: number[],\r\n  yhp: number[],\r\n  NHP: number,\r\n  _order: number,\r\n  rpm: number\r\n): number {\r\n  // Find bracketing points\r\n  let i = 0;\r\n  for (i = 0; i < NHP - 1; i++) {\r\n    if (rpm <= xrpm[i + 1]) break;\r\n  }\r\n  \r\n  // Clamp to range\r\n  if (i >= NHP - 1) i = NHP - 2;\r\n  if (i < 0) i = 0;\r\n  \r\n  // Linear interpolation\r\n  const x0 = xrpm[i];\r\n  const x1 = xrpm[i + 1];\r\n  const y0 = yhp[i];\r\n  const y1 = yhp[i + 1];\r\n  \r\n  if (x1 === x0) return y0;\r\n  \r\n  const t = (rpm - x0) / (x1 - x0);\r\n  return y0 + t * (y1 - y0);\r\n}\r\n","/**\r\n * VB6 CalcWork Function - Fuel System Multiplier\r\n * \r\n * Source: QTRPERF.BAS lines 256-265\r\n * \r\n * This function returns a multiplier based on fuel system type that affects:\r\n * - HP curve shape in ENGINE() synthetic curve generation\r\n * - Peak HP limits in SetPeakHP()\r\n * - Weight limits in SetWeight()\r\n */\r\n\r\n/**\r\n * Fuel system type (matches VB6 gc_FuelSystem.Value)\r\n */\r\nexport type FuelSystemValue = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;\r\n\r\n/**\r\n * Calculate fuel system work multiplier\r\n * \r\n * VB6: QTRPERF.BAS lines 256-265\r\n * \r\n * ```vb\r\n * Public Function CalcWork()\r\n *     Select Case gc_FuelSystem.Value\r\n *         Case 1, 2:  CalcWork = 1\r\n *         Case 3, 4:  CalcWork = 1.08\r\n *         Case 5:     CalcWork = 5\r\n *         Case 6:     CalcWork = 2 * 1\r\n *         Case 7, 9:  CalcWork = 2.5 * 1.08\r\n *         Case 8:     CalcWork = 1.5 * 5.5\r\n *     End Select\r\n * End Function\r\n * ```\r\n * \r\n * @param fuelSystem Fuel system type (1-9)\r\n * @returns Work multiplier\r\n */\r\nexport function calcWork(fuelSystem: FuelSystemValue): number {\r\n  switch (fuelSystem) {\r\n    case 1:  // Gasoline Carburetor\r\n    case 2:  // Gasoline Injector\r\n      return 1;\r\n    \r\n    case 3:  // Methanol Carburetor\r\n    case 4:  // Methanol Injector\r\n      return 1.08;\r\n    \r\n    case 5:  // Nitromethane Injector\r\n      return 5;\r\n    \r\n    case 6:  // Supercharged Gasoline\r\n      return 2 * 1;  // = 2\r\n    \r\n    case 7:  // Supercharged Methanol\r\n    case 9:  // Flat Rate Engine HP (Electric)\r\n      return 2.5 * 1.08;  // = 2.7\r\n    \r\n    case 8:  // Supercharged Nitro\r\n      return 1.5 * 5.5;  // = 8.25\r\n    \r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Fuel system names for display\r\n */\r\nexport const FUEL_SYSTEM_NAMES: Record<FuelSystemValue, string> = {\r\n  1: 'Gasoline Carburetor',\r\n  2: 'Gasoline Injector',\r\n  3: 'Methanol Carburetor',\r\n  4: 'Methanol Injector',\r\n  5: 'Nitromethane Injector',\r\n  6: 'Supercharged Gasoline',\r\n  7: 'Supercharged Methanol',\r\n  8: 'Supercharged Nitro',\r\n  9: 'Flat Rate Engine HP',\r\n};\r\n\r\n/**\r\n * Check if fuel system is naturally aspirated\r\n */\r\nexport function isNaturallyAspirated(fuelSystem: FuelSystemValue): boolean {\r\n  return fuelSystem <= 5;\r\n}\r\n\r\n/**\r\n * Check if fuel system is supercharged\r\n */\r\nexport function isSupercharged(fuelSystem: FuelSystemValue): boolean {\r\n  return fuelSystem >= 6 && fuelSystem <= 8;\r\n}\r\n\r\n/**\r\n * Get fuel type (1=gas, 2=methanol, 3=nitro)\r\n */\r\nexport function getFuelType(fuelSystem: FuelSystemValue): 1 | 2 | 3 {\r\n  switch (fuelSystem) {\r\n    case 1:\r\n    case 2:\r\n    case 6:\r\n      return 1;  // Gasoline\r\n    case 3:\r\n    case 4:\r\n    case 7:\r\n    case 9:\r\n      return 2;  // Methanol\r\n    case 5:\r\n    case 8:\r\n      return 3;  // Nitromethane\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\n/**\r\n * Get carburetion type (1=carb, 2=injector, 3=supercharger)\r\n */\r\nexport function getCarburetionType(fuelSystem: FuelSystemValue): 1 | 2 | 3 {\r\n  switch (fuelSystem) {\r\n    case 1:\r\n    case 3:\r\n      return 1;  // Carburetor\r\n    case 2:\r\n    case 4:\r\n    case 5:\r\n      return 2;  // Injector\r\n    case 6:\r\n    case 7:\r\n    case 8:\r\n    case 9:\r\n      return 3;  // Supercharger\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n","/**\r\n * VB6 ENGINE Subroutine - Builds synthetic HP curve from peak HP/RPM\r\n * \r\n * This is the QuarterJr method for generating an HP curve when only\r\n * peak HP and peak RPM are known. It uses lookup tables based on\r\n * HP/CID ratio to create a realistic curve shape.\r\n * \r\n * From TIMESLIP.FRM lines 1758-1828\r\n */\r\n\r\nimport { Z6 } from './constants';\r\nimport { dtaby } from './dtaby';\r\nimport { calcWork, type FuelSystemValue } from './calcWork';\r\n\r\n// Normalized RPM points (fraction of peak RPM) - 0-indexed for DTABY\r\nconst SX_0 = [\r\n  0.25, 0.5, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, 1.05, 1.1, 1.15, 1.2, 1.25\r\n];\r\n\r\n// HP/CID ratio breakpoints - 0-indexed for DTABY\r\nconst SZ_0 = [0.7, 1.2, 1.7, 2.5, 3.4];\r\n\r\n// Torque ratio lookup table flattened for DTABY (column-major order)\r\n// 16 rows (RPM points) x 5 columns (HP/CID ratios)\r\n// VB6: sY(row + (col-1)*16) where row=1..16, col=1..5\r\nconst SY_FLAT = [\r\n  // Column 1: HP/CID = 0.7\r\n  0.53, 0.975, 1.098, 1.13, 1.152, 1.16, 1.153, 1.122, 1.086, 1.045, 1.0, 0.938, 0.865, 0.795, 0.72, 0.63,\r\n  // Column 2: HP/CID = 1.2\r\n  0.365, 0.87, 1.018, 1.066, 1.11, 1.129, 1.132, 1.11, 1.079, 1.042, 1.0, 0.935, 0.855, 0.762, 0.66, 0.54,\r\n  // Column 3: HP/CID = 1.7\r\n  0.24, 0.79, 0.96, 1.023, 1.08, 1.106, 1.117, 1.102, 1.074, 1.04, 1.0, 0.932, 0.845, 0.736, 0.612, 0.474,\r\n  // Column 4: HP/CID = 2.5\r\n  0.1, 0.7, 0.894, 0.972, 1.04, 1.08, 1.096, 1.09, 1.069, 1.037, 1.0, 0.928, 0.83, 0.698, 0.55, 0.39,\r\n  // Column 5: HP/CID = 3.4\r\n  0, 0.63, 0.84, 0.924, 1.0, 1.055, 1.079, 1.082, 1.064, 1.035, 1.0, 0.923, 0.815, 0.662, 0.49, 0.31,\r\n];\r\n\r\n// Legacy 1-indexed arrays for backward compatibility\r\nconst SX = [\r\n  0,      // placeholder for 1-indexing\r\n  0.25, 0.5, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1.0, 1.05, 1.1, 1.15, 1.2, 1.25\r\n];\r\n\r\nconst SZ = [0, 0.7, 1.2, 1.7, 2.5, 3.4]; // 1-indexed\r\n\r\n// Supercharged nitro torque ratios (special case)\r\nconst SYS = [\r\n  0,      // placeholder for 1-indexing\r\n  0, 0.61, 0.8, 0.9, 0.98, 1.035, 1.055, 1.06, 1.05, 1.03, 1.0, 0.93, 0.85, 0.765, 0.67, 0.58\r\n];\r\n\r\n/**\r\n * 2D interpolation for torque ratio lookup using DTABY\r\n * VB6: Call DTABY(SX(), sz(), sY(), NHP, 5, 1, 1, SX(N), HPCID, TQR)\r\n */\r\nfunction interpolateTorqueRatio(rpmRatio: number, hpCidRatio: number): number {\r\n  // Use proper DTABY 2D Lagrangian interpolation\r\n  // LX=1, LZ=1 means linear interpolation in both dimensions\r\n  return dtaby(\r\n    SX_0,      // X values (RPM ratios)\r\n    SZ_0,      // Z values (HP/CID ratios)\r\n    SY_FLAT,   // Y values (torque ratios, flattened column-major)\r\n    16,        // NX = 16 RPM points\r\n    5,         // NZ = 5 HP/CID points\r\n    1,         // LX = 1 (linear in X)\r\n    1,         // LZ = 1 (linear in Z)\r\n    rpmRatio,  // XVAL\r\n    hpCidRatio // ZVAL\r\n  );\r\n}\r\n\r\nexport interface EngineCurveInputs {\r\n  peakHP: number;\r\n  peakRPM: number;\r\n  displacement_cid: number;\r\n  fuelSystem: number;  // 1-5 = naturally aspirated, 6+ = supercharged, 8 = nitro\r\n}\r\n\r\nexport interface EngineCurveResult {\r\n  xrpm: number[];  // RPM points (1-indexed, 16 points)\r\n  yhp: number[];   // HP at each RPM point\r\n  ztq: number[];   // Torque at each RPM point\r\n  NHP: number;     // Number of points (16)\r\n}\r\n\r\n/**\r\n * Build synthetic HP curve from peak HP/RPM (QuarterJr method)\r\n * \r\n * This replicates the VB6 ENGINE subroutine from TIMESLIP.FRM\r\n */\r\nexport function buildEngineCurve(inputs: EngineCurveInputs): EngineCurveResult {\r\n  const { peakHP, peakRPM, displacement_cid, fuelSystem } = inputs;\r\n  \r\n  // Calculate torque at peak HP\r\n  // TQPHP = Z6 * gc_PeakHP.Value / gc_RPMPeakHP.Value\r\n  const TQPHP = Z6 * peakHP / peakRPM;\r\n  \r\n  // Calculate HP/CID ratio (normalized by CalcWork based on fuel system)\r\n  // HPCID = (gc_PeakHP.Value / gc_Displacement.Value) / CalcWork\r\n  const workMultiplier = calcWork(fuelSystem as FuelSystemValue);\r\n  let HPCID = (peakHP / displacement_cid) / workMultiplier;\r\n  \r\n  // Clamp HP/CID ratio to valid range\r\n  if (fuelSystem <= 5) {\r\n    // Naturally aspirated\r\n    if (HPCID < SZ[1]) HPCID = SZ[1]; // 0.7\r\n  } else {\r\n    // Supercharged\r\n    if (HPCID < SZ[2]) HPCID = SZ[2]; // 1.2\r\n  }\r\n  if (HPCID > SZ[5]) HPCID = SZ[5]; // 3.4\r\n  \r\n  const xrpm: number[] = [0]; // 1-indexed\r\n  const yhp: number[] = [0];\r\n  const ztq: number[] = [0];\r\n  \r\n  const NHP = 16;\r\n  \r\n  for (let n = 1; n <= NHP; n++) {\r\n    // RPM at this point\r\n    xrpm[n] = SX[n] * peakRPM;\r\n    \r\n    let TQ: number;\r\n    if (fuelSystem === 8) {\r\n      // Supercharged nitro - use special curve\r\n      TQ = SYS[n] * TQPHP;\r\n    } else {\r\n      // Everything else - interpolate from lookup table\r\n      const TQR = interpolateTorqueRatio(SX[n], HPCID);\r\n      TQ = TQR * TQPHP;\r\n    }\r\n    \r\n    // HP = RPM * TQ / Z6\r\n    yhp[n] = xrpm[n] * TQ / Z6;\r\n    ztq[n] = TQ;\r\n  }\r\n  \r\n  return { xrpm, yhp, ztq, NHP };\r\n}\r\n\r\n/**\r\n * Convert 1-indexed arrays to 0-indexed for use in simulation\r\n */\r\nexport function convertToZeroIndexed(curve: EngineCurveResult): { rpm: number[]; hp: number[] } {\r\n  const rpm: number[] = [];\r\n  const hp: number[] = [];\r\n  \r\n  for (let i = 1; i <= curve.NHP; i++) {\r\n    rpm.push(curve.xrpm[i]);\r\n    hp.push(curve.yhp[i]);\r\n  }\r\n  \r\n  return { rpm, hp };\r\n}\r\n","/**\r\n * VB6 QuarterJr Mode Calculations\r\n * \r\n * Source: QTRPERF.BAS - Various Set* functions\r\n *         TIMESLIP.FRM lines 714-806 (QuarterJr initialization)\r\n * \r\n * QuarterJr mode is a simplified input mode where the user provides:\r\n * - Peak HP\r\n * - RPM at Peak HP\r\n * - Displacement (CID)\r\n * - Fuel System Type\r\n * \r\n * The program then calculates:\r\n * - Synthetic HP curve (ENGINE subroutine)\r\n * - Transmission efficiencies\r\n * - Torque multiplier and slippage (for converter)\r\n * - PMI values\r\n * - Drag/lift coefficients by body style\r\n */\r\n\r\nimport { type FuelSystemValue, isNaturallyAspirated } from './calcWork';\r\nimport { buildEngineCurve, convertToZeroIndexed } from './engineCurve';\r\nimport { taby } from './dtaby';\r\n\r\n/**\r\n * QuarterJr input parameters\r\n */\r\nexport interface QuarterJrInputs {\r\n  // Required\r\n  peakHP: number;\r\n  rpmAtPeakHP: number;\r\n  displacement_cid: number;\r\n  fuelSystem: FuelSystemValue;\r\n  \r\n  // Vehicle\r\n  weight_lbf: number;\r\n  wheelbase_in: number;\r\n  tireDia_in: number;\r\n  tireWidth_in: number;\r\n  rollout_in: number;\r\n  \r\n  // Transmission\r\n  isConverter: boolean;  // true = converter, false = clutch\r\n  gearRatios: number[];  // Transmission gear ratios\r\n  finalDrive: number;    // Final drive ratio\r\n  \r\n  // Converter-specific (optional)\r\n  converterDia_in?: number;\r\n  slipStallRPM?: number;  // Can be RPM or index\r\n  \r\n  // Clutch-specific (optional)\r\n  slipRPM?: number;\r\n  \r\n  // Optional overrides\r\n  bodyStyle?: number;    // 1-8, default calculated from weight\r\n  shiftRPM?: number;     // Default = rpmAtPeakHP\r\n}\r\n\r\n/**\r\n * QuarterJr calculated outputs\r\n */\r\nexport interface QuarterJrOutputs {\r\n  // HP curve\r\n  xrpm: number[];\r\n  yhp: number[];\r\n  ztq: number[];\r\n  NHP: number;\r\n  \r\n  // Transmission\r\n  transEff: number[];    // Per-gear efficiency\r\n  shiftRPMs: number[];   // Per-gear shift RPM\r\n  \r\n  // Converter/Clutch\r\n  torqueMult: number;\r\n  slippage: number;\r\n  stallRPM: number;\r\n  launchRPM: number;\r\n  \r\n  // PMI\r\n  enginePMI: number;\r\n  transPMI: number;\r\n  tiresPMI: number;\r\n  \r\n  // Aero\r\n  dragCoef: number;\r\n  liftCoef: number;\r\n  efficiency: number;\r\n  overhang_in: number;\r\n  \r\n  // Body style\r\n  bodyStyle: number;\r\n}\r\n\r\n/**\r\n * Calculate body style from weight\r\n * VB6: QTRPERF.BAS lines 152-166\r\n */\r\nexport function calcBodyStyle(weight_lbf: number): number {\r\n  // VB6: If gc_Weight.Value > 800 Then gc_BodyStyle.Value = 1 Else gc_BodyStyle.Value = 8\r\n  return weight_lbf > 800 ? 1 : 8;  // 8 = motorcycle\r\n}\r\n\r\n/**\r\n * Get drag/lift coefficients and overhang by body style\r\n * VB6: TIMESLIP.FRM lines 768-777\r\n */\r\nexport function getAeroByBodyStyle(bodyStyle: number): {\r\n  dragCoef: number;\r\n  liftCoef: number;\r\n  overhang_in: number;\r\n} {\r\n  switch (bodyStyle) {\r\n    case 1:  // Dragster with wing\r\n      return { dragCoef: 0.66, liftCoef: 0.8, overhang_in: 30 };\r\n    case 2:  // Dragster\r\n      return { dragCoef: 0.5, liftCoef: 0.2, overhang_in: 30 };\r\n    case 3:  // Funny car body\r\n      return { dragCoef: 0.52, liftCoef: 0.8, overhang_in: 40 };\r\n    case 4:  // Altered/roadster\r\n      return { dragCoef: 0.52, liftCoef: 0.1, overhang_in: 30 };\r\n    case 5:  // Fastback\r\n      return { dragCoef: 0.28, liftCoef: 0.1, overhang_in: 30 };\r\n    case 6:  // Sedan\r\n      return { dragCoef: 0.4, liftCoef: 0.1, overhang_in: 24 };\r\n    case 7:  // Station wagon/van\r\n      return { dragCoef: 0.46, liftCoef: 0.1, overhang_in: 18 };\r\n    case 8:  // Motorcycle\r\n      return { dragCoef: 0.54, liftCoef: 0.1, overhang_in: 12 };\r\n    default:\r\n      return { dragCoef: 0.5, liftCoef: 0.2, overhang_in: 30 };\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate transmission efficiencies\r\n * VB6: TIMESLIP.FRM lines 721-737\r\n */\r\nexport function calcTransEfficiencies(\r\n  NGR: number,\r\n  isConverter: boolean\r\n): number[] {\r\n  const efficiencies: number[] = [];\r\n  \r\n  if (!isConverter) {\r\n    // Clutch type trans\r\n    // teff = 0.99\r\n    // TGEff(i) = teff - (NGR - i) * 0.005\r\n    const teff = 0.99;\r\n    for (let i = 1; i <= NGR; i++) {\r\n      efficiencies.push(teff - (NGR - i) * 0.005);\r\n    }\r\n  } else {\r\n    // Converter type trans\r\n    // teff = 0.99: If NGR >= 3 Then teff = 0.985\r\n    // TGEff(i) = teff - (NGR - i) * 2 * 0.005\r\n    const teff = NGR >= 3 ? 0.985 : 0.99;\r\n    for (let i = 1; i <= NGR; i++) {\r\n      efficiencies.push(teff - (NGR - i) * 2 * 0.005);\r\n    }\r\n  }\r\n  \r\n  return efficiencies;\r\n}\r\n\r\n/**\r\n * Calculate converter torque multiplier and slippage\r\n * VB6: TIMESLIP.FRM lines 739-758\r\n */\r\nexport function calcConverterParams(\r\n  xrpm: number[],\r\n  yhp: number[],\r\n  NHP: number,\r\n  slipStallRPM: number,\r\n  converterDia_in: number,\r\n  hpc: number\r\n): { torqueMult: number; slippage: number; work: number; stallRPM: number } {\r\n  const Z6 = 5252;\r\n  let stallRPM: number;\r\n  let work: number;\r\n  \r\n  if (slipStallRPM > 220) {\r\n    // Direct RPM input\r\n    stallRPM = slipStallRPM;\r\n    \r\n    // Get HP at stall RPM\r\n    const shp = taby(xrpm, yhp, NHP, 1, stallRPM);\r\n    const stq = shp * (Z6 / stallRPM) / hpc;\r\n    work = (stallRPM / 1000) * (stallRPM / stq);\r\n  } else {\r\n    // Stall index input\r\n    work = slipStallRPM;\r\n    stallRPM = 0;  // Will be calculated later\r\n  }\r\n  \r\n  // VB6: lrat = Work / (200 * (7 / gc_ConvDia.Value) ^ 4)\r\n  const lrat = work / (200 * Math.pow(7 / converterDia_in, 4));\r\n  \r\n  // VB6: gc_Slippage.Value = 1.01 + lrat / 20 + Work / 8000\r\n  const slippage = 1.01 + lrat / 20 + work / 8000;\r\n  \r\n  // VB6: TQMult = 2.633 - lrat ^ 0.3 - Work / 1500\r\n  let torqueMult = 2.633 - Math.pow(lrat, 0.3) - work / 1500;\r\n  if (torqueMult < 1) torqueMult = 1;\r\n  if (torqueMult > 2) torqueMult = 2;\r\n  \r\n  return { torqueMult, slippage, work, stallRPM };\r\n}\r\n\r\n/**\r\n * Calculate PMI values\r\n * VB6: TIMESLIP.FRM lines 780-806\r\n */\r\nexport function calcPMI(\r\n  estCID: number,\r\n  fuelSystem: FuelSystemValue,\r\n  isConverter: boolean,\r\n  NGR: number,\r\n  tireDia_in: number,\r\n  tireWidth_in: number,\r\n  bodyStyle: number\r\n): { enginePMI: number; transPMI: number; tiresPMI: number } {\r\n  let enginePMI: number;\r\n  let transPMI: number;\r\n  let tiresPMI: number;\r\n  \r\n  // VB6: TIMESLIP.FRM lines 787-791\r\n  if (isNaturallyAspirated(fuelSystem)) {\r\n    enginePMI = estCID / 120;\r\n  } else {\r\n    enginePMI = estCID / 90;\r\n  }\r\n  \r\n  // VB6: TIMESLIP.FRM lines 793-797\r\n  if (!isConverter) {\r\n    transPMI = NGR * enginePMI / 50;\r\n  } else {\r\n    transPMI = (NGR - 1) * enginePMI / 10;\r\n  }\r\n  \r\n  // VB6: TIMESLIP.FRM lines 799\r\n  // gc_TiresPMI.Value = 2 * (1.15 * 0.8 * (0.08 * TireDia * gc_TireWidth.Value) * (TireDia / 2) ^ 2 / 386)\r\n  tiresPMI = 2 * (1.15 * 0.8 * (0.08 * tireDia_in * tireWidth_in) * Math.pow(tireDia_in / 2, 2) / 386);\r\n  \r\n  // VB6: TIMESLIP.FRM lines 801-805 - Motorcycle adjustments\r\n  if (bodyStyle === 8) {\r\n    enginePMI = estCID / 240;\r\n    transPMI = transPMI / (240 / 120);\r\n    tiresPMI = tiresPMI / 2;\r\n  }\r\n  \r\n  return { enginePMI, transPMI, tiresPMI };\r\n}\r\n\r\n/**\r\n * Calculate overall driveline efficiency\r\n * VB6: TIMESLIP.FRM lines 760-765\r\n */\r\nexport function calcEfficiency(bodyStyle: number): number {\r\n  if (bodyStyle === 8) {\r\n    return 0.985;  // Motorcycle\r\n  }\r\n  return 0.97;  // Everything else\r\n}\r\n\r\n/**\r\n * Calculate clutch slippage\r\n * VB6: TIMESLIP.FRM lines 729\r\n */\r\nexport function calcClutchSlippage(slipStallRPM: number): number {\r\n  // gc_Slippage.Value = 1.0025 + gc_SlipStallRPM.Value / 1000000\r\n  return 1.0025 + slipStallRPM / 1000000;\r\n}\r\n\r\n/**\r\n * Main QuarterJr calculation function\r\n */\r\nexport function calculateQuarterJr(\r\n  inputs: QuarterJrInputs,\r\n  hpc: number = 1.0\r\n): QuarterJrOutputs {\r\n  const {\r\n    peakHP,\r\n    rpmAtPeakHP,\r\n    displacement_cid,\r\n    fuelSystem,\r\n    weight_lbf,\r\n    tireDia_in,\r\n    tireWidth_in,\r\n    isConverter,\r\n    gearRatios,\r\n    converterDia_in = 10,\r\n    slipStallRPM = 5000,\r\n    slipRPM = 6500,\r\n    bodyStyle: inputBodyStyle,\r\n    shiftRPM = rpmAtPeakHP,\r\n  } = inputs;\r\n  \r\n  const NGR = gearRatios.length;\r\n  \r\n  // Calculate body style\r\n  const bodyStyle = inputBodyStyle ?? calcBodyStyle(weight_lbf);\r\n  \r\n  // Build HP curve\r\n  const curve = buildEngineCurve({\r\n    peakHP,\r\n    peakRPM: rpmAtPeakHP,\r\n    displacement_cid,\r\n    fuelSystem,\r\n  });\r\n  \r\n  // Convert to 0-indexed for simulation\r\n  const { rpm: xrpm0, hp: yhp0 } = convertToZeroIndexed(curve);\r\n  \r\n  // Calculate transmission efficiencies\r\n  const transEff = calcTransEfficiencies(NGR, isConverter);\r\n  \r\n  // Calculate shift RPMs (all same for QuarterJr)\r\n  const shiftRPMs = gearRatios.map(() => shiftRPM);\r\n  \r\n  // Calculate converter/clutch parameters\r\n  let torqueMult = 1;\r\n  let slippage = 1.0025;\r\n  let stallRPM = slipRPM;\r\n  let launchRPM = slipRPM;\r\n  \r\n  if (isConverter) {\r\n    const convParams = calcConverterParams(\r\n      xrpm0,\r\n      yhp0,\r\n      curve.NHP,\r\n      slipStallRPM,\r\n      converterDia_in,\r\n      hpc\r\n    );\r\n    torqueMult = convParams.torqueMult;\r\n    slippage = convParams.slippage;\r\n    stallRPM = convParams.stallRPM || slipStallRPM;\r\n    launchRPM = stallRPM;\r\n  } else {\r\n    slippage = calcClutchSlippage(slipRPM);\r\n    stallRPM = slipRPM;\r\n    launchRPM = slipRPM;\r\n  }\r\n  \r\n  // Calculate PMI\r\n  const pmi = calcPMI(\r\n    displacement_cid,\r\n    fuelSystem,\r\n    isConverter,\r\n    NGR,\r\n    tireDia_in,\r\n    tireWidth_in,\r\n    bodyStyle\r\n  );\r\n  \r\n  // Get aero coefficients\r\n  const aero = getAeroByBodyStyle(bodyStyle);\r\n  \r\n  // Calculate efficiency\r\n  const efficiency = calcEfficiency(bodyStyle);\r\n  \r\n  return {\r\n    xrpm: curve.xrpm,\r\n    yhp: curve.yhp,\r\n    ztq: curve.ztq,\r\n    NHP: curve.NHP,\r\n    transEff,\r\n    shiftRPMs,\r\n    torqueMult,\r\n    slippage,\r\n    stallRPM,\r\n    launchRPM,\r\n    enginePMI: pmi.enginePMI,\r\n    transPMI: pmi.transPMI,\r\n    tiresPMI: pmi.tiresPMI,\r\n    dragCoef: aero.dragCoef,\r\n    liftCoef: aero.liftCoef,\r\n    efficiency,\r\n    overhang_in: aero.overhang_in,\r\n    bodyStyle,\r\n  };\r\n}\r\n","/**\r\n * VB6 Exact Simulation Model\r\n * \r\n * This model implements the EXACT VB6 TIMESLIP.FRM simulation logic.\r\n * It uses the vb6SimulationStep function which replicates the VB6 iteration loop.\r\n * \r\n * Key differences from rsaclassic.ts:\r\n * 1. Uses VB6's velocity-first approach (estimate velocity, then iterate to converge time)\r\n * 2. Implements the full 12-iteration convergence loop for PMI\r\n * 3. Uses VB6's exact formulas for all calculations\r\n * 4. Matches VB6's variable naming and calculation order\r\n */\r\n\r\nimport type { SimInputs, SimResult } from '../index';\r\nimport { \r\n  vb6SimulationStep, \r\n  vb6InitState, \r\n  vb6CalcTSMaxInit,\r\n  TABY,\r\n  type VB6VehicleParams,\r\n  type VB6EnvParams,\r\n  type ThrottleStopParams,\r\n} from '../vb6/vb6SimulationStep';\r\nimport { airDensityVB6, type FuelSystemType } from '../vb6/air';\r\nimport { gc, FPS_TO_MPH } from '../vb6/constants';\r\nimport { buildEngineCurve, convertToZeroIndexed } from '../vb6/engineCurve';\r\nimport { \r\n  calcBodyStyle, \r\n  getAeroByBodyStyle, \r\n  calcTransEfficiencies, \r\n  calcPMI, \r\n  calcEfficiency,\r\n  calcClutchSlippage,\r\n} from '../vb6/quarterJr';\r\nimport { type FuelSystemValue } from '../vb6/calcWork';\r\nimport { taby } from '../vb6/dtaby';\r\nimport { Z6 } from '../vb6/constants';\r\nimport { DISTANCES, RACE_LENGTH_INFO, type RaceLength } from '../../config/raceLengths';\r\n\r\n/**\r\n * Get race length in feet from race length key\r\n */\r\nfunction getRaceLengthFt(raceLength: RaceLength | string): number {\r\n  const info = RACE_LENGTH_INFO[raceLength as RaceLength];\r\n  if (info) return info.lengthFt;\r\n  \r\n  // Fallback for legacy values\r\n  if (raceLength === 'EIGHTH') return 660;\r\n  if (raceLength === 'QUARTER') return 1320;\r\n  return 1320; // Default to quarter mile\r\n}\r\n\r\n/**\r\n * Get distance checkpoints for a race length\r\n */\r\nfunction getDistanceTargets(raceLength: RaceLength | string): readonly number[] {\r\n  const distances = DISTANCES[raceLength as RaceLength];\r\n  if (distances) return distances;\r\n  \r\n  // Fallback\r\n  return raceLength === 'EIGHTH' ? DISTANCES.EIGHTH : DISTANCES.QUARTER;\r\n}\r\n\r\n/**\r\n * Trace point for simulation output\r\n */\r\ninterface TracePoint {\r\n  t_s: number;\r\n  s_ft: number;\r\n  v_fps: number;\r\n  v_mph: number;\r\n  a_g: number;\r\n  rpm: number;           // Engine RPM\r\n  dsrpm: number;         // Driveshaft RPM (engine side: EngRPM / TransGearRatio)\r\n  lockRpm: number;       // Lock-up RPM (clutch/converter output)\r\n  gear: number;\r\n  slip: boolean;\r\n  tireSlip: number;      // Tire slip factor (>1 means wheel spin)\r\n  hp: number;            // Engine HP at wheels (after drivetrain losses)\r\n  dragHp: number;        // Drag HP (power consumed by aerodynamic drag)\r\n  netHp: number;         // Net HP = hp - dragHp (can be negative at terminal velocity)\r\n  wheelSpeed_mph: number; // Wheel surface speed (car speed × tire slip)\r\n  throttleStopActive?: boolean; // True when throttle stop is reducing power\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Map fuel string to VB6 fuel system type\r\n * \r\n * VB6 Fuel System Types:\r\n * 1 = Gas + Carb\r\n * 2 = Gas + Inject\r\n * 3 = Methanol + Carb\r\n * 4 = Methanol + Inject\r\n * 5 = Nitro + Inject\r\n * 6 = Gas + Supercharged\r\n * 7 = Methanol + Supercharged\r\n * 8 = Nitro + Supercharged\r\n * 9 = Electric\r\n */\r\nfunction getFuelSystemType(fuel: string | undefined): FuelSystemType {\r\n  if (!fuel) return 1;\r\n  const f = fuel.toUpperCase();\r\n  \r\n  // Handle unified fuel type values (new format)\r\n  if (f === 'GASOLINE') return 1;\r\n  if (f === 'GASOLINE EFI') return 2;\r\n  if (f === 'METHANOL') return 3;\r\n  if (f === 'METHANOL EFI') return 4;\r\n  if (f === 'NITROMETHANE') return 5;\r\n  if (f === 'SUPERCHARGED GASOLINE') return 6;\r\n  if (f === 'SUPERCHARGED METHANOL') return 7;\r\n  if (f === 'SUPERCHARGED NITRO') return 8;\r\n  if (f === 'E85' || f === 'DIESEL') return 1; // Treat as gasoline for now\r\n  \r\n  // Handle VB6-style fuel system strings (e.g., \"Gas+Carb\", \"Methanol+Inject\")\r\n  if (f === 'GAS+CARB' || f === 'GASOLINE+CARBURETOR') return 1;\r\n  if (f === 'GAS+INJECT' || f === 'GASOLINE+FUEL INJECTION') return 2;\r\n  if (f === 'METHANOL+CARB' || f === 'METHANOL+CARBURETOR') return 3;\r\n  if (f === 'METHANOL+INJECT' || f === 'METHANOL+FUEL INJECTION') return 4;\r\n  if (f === 'NITRO+INJECT' || f === 'NITROMETHANE+FUEL INJECTION') return 5;\r\n  if (f === 'GAS+SUPERCHARGED' || f === 'GASOLINE+SUPERCHARGED') return 6;\r\n  if (f === 'METHANOL+SUPERCHARGED') return 7;\r\n  if (f === 'NITRO+SUPERCHARGED' || f === 'NITROMETHANE+SUPERCHARGED') return 8;\r\n  if (f === 'ELECTRIC') return 9;\r\n  \r\n  // Handle legacy/descriptive strings (fallback)\r\n  if (f.includes('SUPERCHARG') || f.includes('BLOWN')) {\r\n    if (f.includes('NITRO')) return 8;\r\n    if (f.includes('METHANOL') || f.includes('ALCOHOL')) return 7;\r\n    return 6;\r\n  }\r\n  \r\n  if (f.includes('INJECT') || f.includes('EFI')) {\r\n    if (f.includes('NITRO')) return 5;\r\n    if (f.includes('METHANOL') || f.includes('ALCOHOL')) return 4;\r\n    return 2;\r\n  }\r\n  \r\n  if (f.includes('NITRO')) return 5;\r\n  if (f.includes('METHANOL') || f.includes('ALCOHOL')) return 3;\r\n  if (f.includes('ELECTRIC')) return 9;\r\n  \r\n  return 1;\r\n}\r\n\r\n/**\r\n * Extract HP curve arrays from input\r\n * \r\n * Supports both QuarterPro mode (full HP curve) and QuarterJr mode (synthetic curve)\r\n */\r\nfunction extractHPCurve(input: SimInputs): { \r\n  xrpm: number[]; \r\n  yhp: number[]; \r\n  NHP: number;\r\n  isQuarterJr: boolean;\r\n  quarterJrParams?: {\r\n    peakHP: number;\r\n    rpmAtPeakHP: number;\r\n    displacement_cid: number;\r\n    fuelSystem: FuelSystemValue;\r\n  };\r\n} {\r\n  const vehicle = input.vehicle;\r\n  const engine = (input as any).engine ?? (vehicle as any).engine;\r\n  \r\n  // Try multiple sources for HP curve\r\n  const hpCurve = engine?.hpCurve ?? \r\n                  engine?.torqueCurve ?? \r\n                  (vehicle as any).torqueCurve ?? \r\n                  (vehicle as any).hpCurve ?? \r\n                  [];\r\n  \r\n  const xrpm: number[] = [];\r\n  const yhp: number[] = [];\r\n  \r\n  for (const pt of hpCurve) {\r\n    if (Array.isArray(pt)) {\r\n      xrpm.push(pt[0]);\r\n      yhp.push(pt[1]);\r\n    } else if (pt && typeof pt === 'object') {\r\n      xrpm.push(pt.rpm);\r\n      if (pt.hp !== undefined) {\r\n        yhp.push(pt.hp);\r\n      } else if (pt.torque !== undefined) {\r\n        yhp.push(pt.torque * pt.rpm / 5252);\r\n      } else if (pt.tq_lbft !== undefined) {\r\n        yhp.push(pt.tq_lbft * pt.rpm / 5252);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // If we have a valid HP curve, use it (QuarterPro mode)\r\n  if (xrpm.length >= 2) {\r\n    return { xrpm, yhp, NHP: xrpm.length, isQuarterJr: false };\r\n  }\r\n  \r\n  // QuarterJr mode: Generate synthetic curve using ENGINE() function\r\n  const peakHP = Number(vehicle.powerHP ?? (vehicle as any).peakHP);\r\n  const rpmAtPeakHP = Number((vehicle as any).rpmAtPeakHP ?? (vehicle as any).peakRPM ?? 6500);\r\n  const displacement_cid = Number((vehicle as any).displacement_cid ?? (vehicle as any).displacementCID ?? 350);\r\n  const fuelSystem = ((input as any).fuelSystem ?? (vehicle as any).fuelSystem ?? 1) as FuelSystemValue;\r\n  \r\n  if (Number.isFinite(peakHP) && peakHP > 0) {\r\n    // Use VB6's ENGINE() function to generate synthetic curve\r\n    const curve = buildEngineCurve({\r\n      peakHP,\r\n      peakRPM: rpmAtPeakHP,\r\n      displacement_cid,\r\n      fuelSystem,\r\n    });\r\n    \r\n    // Convert to 0-indexed arrays\r\n    const { rpm, hp } = convertToZeroIndexed(curve);\r\n    \r\n    return { \r\n      xrpm: rpm, \r\n      yhp: hp, \r\n      NHP: curve.NHP,\r\n      isQuarterJr: true,\r\n      quarterJrParams: {\r\n        peakHP,\r\n        rpmAtPeakHP,\r\n        displacement_cid,\r\n        fuelSystem,\r\n      },\r\n    };\r\n  }\r\n  \r\n  // Last resort fallback (shouldn't happen with valid inputs)\r\n  return { xrpm: [4000, 6500], yhp: [100, 150], NHP: 2, isQuarterJr: false };\r\n}\r\n\r\n/**\r\n * Calculate track temperature effect\r\n * VB6 TIMESLIP.FRM:863-870\r\n */\r\nfunction calcTrackTempEffect(trackTempF: number): number {\r\n  // VB6: calc track temperature effect using modified original GoldMind logic\r\n  // If gc_TrackTemp.Value > 100 Then\r\n  //     TrackTempEffect = 1 + 0.0000025 * Abs(100 - gc_TrackTemp.Value) ^ 2.5\r\n  // Else\r\n  //     TrackTempEffect = 1 + 0.000002 * Abs(100 - gc_TrackTemp.Value) ^ 2.5\r\n  // End If\r\n  // If TrackTempEffect > 1.04 Then TrackTempEffect = 1.04\r\n  \r\n  const deviation = Math.abs(100 - trackTempF);\r\n  let effect: number;\r\n  \r\n  if (trackTempF > 100) {\r\n    effect = 1 + 0.0000025 * Math.pow(deviation, 2.5);\r\n  } else {\r\n    effect = 1 + 0.000002 * Math.pow(deviation, 2.5);\r\n  }\r\n  \r\n  if (effect > 1.04) effect = 1.04;\r\n  \r\n  return effect;\r\n}\r\n\r\n// ============================================================================\r\n// Main Simulation Function\r\n// ============================================================================\r\n\r\nexport interface VB6ExactResult extends SimResult {\r\n  vb6Diagnostics?: {\r\n    iterations: number[];\r\n    convergenceHistory: Array<{\r\n      step: number;\r\n      iterations: number;\r\n      HPSave: number;\r\n      HP: number;\r\n      PQWT: number;\r\n      AGS_g: number;\r\n    }>;\r\n  };\r\n  debugData?: {\r\n    fuelType: {\r\n      resolved: string;\r\n      fuelSystemType: number;\r\n      vehicleFuelType?: string;\r\n      vehicleFuelSystem?: string;\r\n    };\r\n    hpCurve: {\r\n      length: number;\r\n      peakHP: number;\r\n      rpmRange: string;\r\n    };\r\n    airCalc: {\r\n      rho_lbm_ft3: number;\r\n      hpc: number;\r\n    };\r\n    simParams: {\r\n      weight: number;\r\n      tireDia: number;\r\n      wheelbase: number;\r\n      finalDrive: number;\r\n      NGR: number;\r\n      peakHP: number;\r\n      stallRPM: number;\r\n      slippage: number;\r\n      isClutch: boolean;\r\n      tractionIndex: number;\r\n      trackTempEffect: number;\r\n      pmi: { engine: number; trans: number; tires: number };\r\n    };\r\n    result: {\r\n      et: number;\r\n      mph: number;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n * Run VB6 exact simulation\r\n */\r\nexport function simulateVB6Exact(input: SimInputs): VB6ExactResult {\r\n  const warnings: string[] = [];\r\n  const trace: TracePoint[] = [];\r\n  \r\n  // ========================================================================\r\n  // Extract input parameters\r\n  // ========================================================================\r\n  const vehicle = input.vehicle;\r\n  const env = input.env;\r\n  \r\n  // Race length - default to quarter mile (1320 ft)\r\n  // Support all track types from raceLengths.ts\r\n  const raceLength = (input as any).raceLength ?? 'QUARTER';\r\n  const raceLengthFt = (input as any).raceLengthFt ?? getRaceLengthFt(raceLength);\r\n  \r\n  // Determine if this is a land speed run (uses different constants)\r\n  // VB6: TIMESLIP.FRM:550-570 - different constants for ISBVPRO\r\n  const isLandSpeed = RACE_LENGTH_INFO[raceLength as RaceLength]?.category === 'landspeed';\r\n  \r\n  // VB6 Rollout/Overhang timing geometry:\r\n  // \r\n  // STAGING: Front tire sits on stage beam, nose is ahead by overhang distance\r\n  // \r\n  // TIMER START: When front tire rolls through \"rollout\" distance (back of tire clears beam)\r\n  //   - At this moment, the ENTIRE CAR has moved \"rollout\" inches forward\r\n  //   - The nose has moved \"rollout\" inches from its staged position\r\n  // \r\n  // TIMER STOP: When the NOSE crosses the finish line (60ft, 330ft, etc.)\r\n  //   - The nose is \"overhang\" inches ahead of the front wheel centerline\r\n  //   - So when nose is at 60ft, front wheel is at (60ft - overhang)\r\n  // \r\n  // Since we simulate from the rear tires, we need to account for:\r\n  //   - rollout: distance car travels before timer starts\r\n  //   - overhang: nose is ahead of front wheel (gives us a \"head start\" at finish)\r\n  //\r\n  // VB6: The simulation tracks rear tire position. When reporting times:\r\n  //   - Timer starts when car has moved \"rollout\" distance\r\n  //   - Distance is measured to where the NOSE would be (rear + wheelbase + overhang)\r\n  //\r\n  const rolloutIn = (vehicle as any).rolloutIn ?? 9;  // Staging beam rollout (inches)\r\n  const overhangIn = (vehicle as any).overhangIn ?? 0; // Front overhang (inches)\r\n  \r\n  // VB6 TIMESLIP.FRM lines 809-815: Calculate overhang adjustment\r\n  // ftd = front tire diameter = 2 * rollout (minimum 24\")\r\n  // ovradj = (overhang + 0.25 * ftd) / 12 (minimum 0.5 * ftd / 12)\r\n  let ftd = 2 * rolloutIn;\r\n  if (ftd < 24) ftd = 24;\r\n  let ovradj = (overhangIn + 0.25 * ftd) / 12;\r\n  const minOvradj = 0.5 * ftd / 12;\r\n  if (ovradj < minOvradj) ovradj = minOvradj;\r\n  \r\n  // First distance checkpoint is at rollout/12 feet\r\n  const rolloutFt = rolloutIn / 12;\r\n  \r\n  // Extract drivetrain components - check both input level and vehicle level\r\n  const drivetrain = (input as any).drivetrain ?? (vehicle as any).drivetrain;\r\n  const clutch = drivetrain?.clutch ?? (input as any).clutch ?? (vehicle as any).clutch;\r\n  const converter = drivetrain?.converter ?? (input as any).converter ?? (vehicle as any).converter;\r\n  const engine = (input as any).engine ?? (vehicle as any).engine;\r\n  const pmi = (input as any).pmi ?? (vehicle as any).pmi;\r\n  \r\n  // Extract throttle stop configuration (for bracket racing)\r\n  const throttleStopConfig = input.throttleStop;\r\n  const throttleStopParams: ThrottleStopParams | undefined = throttleStopConfig?.enabled ? {\r\n    enabled: true,\r\n    activateTime_s: throttleStopConfig.activateTime_s,\r\n    duration_s: throttleStopConfig.duration_s,\r\n    throttlePct: throttleStopConfig.throttlePct,\r\n    rampTime_s: throttleStopConfig.rampTime_s,\r\n  } : undefined;\r\n  \r\n  // Determine transmission type\r\n  // Check transmissionType field first (set by fixtureToSimInputs), then fall back to object detection\r\n  const txType = (vehicle as any).transmissionType ?? (input as any).transmissionType;\r\n  const isClutch = txType === 'clutch' ? true : \r\n                   txType === 'converter' ? false :\r\n                   !converter || (clutch && !converter);\r\n  \r\n  // ========================================================================\r\n  // Calculate air density and hpc\r\n  // ========================================================================\r\n  // Extract fuel type - could be a string or an object with fuelType/fuelSystem property\r\n  // Priority: fuelType (modern) > fuelSystem (legacy VB6 format)\r\n  const rawFuel = (input as any).fuel;\r\n  const fuelString: string | undefined = typeof rawFuel === 'string' \r\n    ? rawFuel \r\n    : (rawFuel?.fuelType ?? rawFuel?.fuelSystem ?? rawFuel?.type ?? (input as any).fuelType ?? (vehicle as any).fuelType ?? (input as any).fuelSystem ?? (vehicle as any).fuelSystem);\r\n  const fuelSystemType = getFuelSystemType(fuelString);\r\n  \r\n  const airResult = airDensityVB6({\r\n    barometer_inHg: env.barometerInHg ?? 29.92,\r\n    temperature_F: env.temperatureF ?? 59,\r\n    relHumidity_pct: env.humidityPct ?? 50,\r\n    elevation_ft: env.elevation ?? 0,\r\n    fuelSystem: fuelSystemType,\r\n  });\r\n  \r\n  // VB6 uses rho in lbm/ft³ (multiply slugs by gc)\r\n  const rho_lbm_ft3 = airResult.rho_slug_per_ft3 * gc;\r\n  const hpc = airResult.hpc;\r\n  \r\n  // ========================================================================\r\n  // Build VB6 vehicle params\r\n  // ========================================================================\r\n  const hpCurveResult = extractHPCurve(input);\r\n  const { xrpm, yhp, NHP, isQuarterJr, quarterJrParams } = hpCurveResult;\r\n  \r\n  if (NHP < 2) {\r\n    warnings.push('HP curve has fewer than 2 points');\r\n  }\r\n  \r\n  if (isQuarterJr) {\r\n    warnings.push('Using QuarterJr mode (synthetic HP curve from peak HP)');\r\n  }\r\n  \r\n  // Get gear ratios - check both drivetrain and vehicle level\r\n  const gearRatios = drivetrain?.gearRatios ?? (vehicle as any).gearRatios ?? [2.5, 1.8, 1.4, 1.1, 1.0];\r\n  const finalDrive = drivetrain?.finalDriveRatio ?? (vehicle as any).finalDrive ?? vehicle.rearGear ?? 3.73;\r\n  const NGR = gearRatios.length;\r\n  \r\n  // Tire dimensions - check nested tire object (fixture format) and flat properties\r\n  const tire = (vehicle as any).tire;\r\n  const tireDiaIn = tire?.diameter_in ?? vehicle.tireDiaIn ?? 32;\r\n  const tireWidthIn = tire?.width_in ?? vehicle.tireWidthIn ?? 17;\r\n  \r\n  // Body style - calculate from weight if not provided (VB6: QTRPERF.BAS CalcBodyStyle)\r\n  const bodyStyle = (vehicle as any).bodyStyle ?? calcBodyStyle(vehicle.weightLb);\r\n  \r\n  // ========================================================================\r\n  // QuarterJr vs QuarterPro mode handling\r\n  // VB6: TIMESLIP.FRM lines 699-806\r\n  // ========================================================================\r\n  let TGEff: number[];\r\n  let shiftRPMs: number[];\r\n  let stallRPM: number;\r\n  let slippage: number;\r\n  let torqueMult: number;\r\n  let enginePMI: number;\r\n  let transPMI: number;\r\n  let tiresPMI: number;\r\n  let overallEfficiency: number;\r\n  let dragCoef: number;\r\n  let liftCoef: number;\r\n  let overhangInCalc: number;\r\n  \r\n  if (isQuarterJr && quarterJrParams) {\r\n    // ====================================================================\r\n    // QuarterJr Mode: Calculate all derived parameters\r\n    // VB6: TIMESLIP.FRM lines 714-806 (#Else branch)\r\n    // ====================================================================\r\n    const { displacement_cid, fuelSystem } = quarterJrParams;\r\n    \r\n    // Calculate transmission efficiencies (VB6: TIMESLIP.FRM lines 721-737)\r\n    TGEff = calcTransEfficiencies(NGR, !isClutch);\r\n    \r\n    // Single shift RPM for all gears (VB6: TIMESLIP.FRM lines 726, 736)\r\n    const singleShiftRPM = (vehicle as any).shiftRPM ?? drivetrain?.shiftRPM ?? 7000;\r\n    shiftRPMs = gearRatios.map(() => singleShiftRPM);\r\n    \r\n    // Calculate slippage and torque multiplier (VB6: TIMESLIP.FRM lines 729-754)\r\n    const inputSlipStall = clutch?.slipRPM ?? converter?.stallRPM ?? \r\n                           (vehicle as any).slipStallRPM ?? 5000;\r\n    \r\n    if (isClutch) {\r\n      // Clutch: gc_Slippage.Value = 1.0025 + gc_SlipStallRPM.Value / 1000000\r\n      slippage = calcClutchSlippage(inputSlipStall);\r\n      torqueMult = 1;\r\n      stallRPM = inputSlipStall;\r\n    } else {\r\n      // Converter: Calculate from stall RPM or index\r\n      const converterDia = converter?.diameter_in ?? converter?.diameter ?? (vehicle as any).converterDiameterIn ?? (vehicle as any).converterDia_in ?? 10;\r\n      let work: number;\r\n      \r\n      if (inputSlipStall > 220) {\r\n        // Direct RPM input\r\n        stallRPM = inputSlipStall;\r\n        const shp = taby(xrpm, yhp, NHP, 1, stallRPM);\r\n        const stq = shp * (Z6 / stallRPM) / hpc;\r\n        work = (stallRPM / 1000) * (stallRPM / stq);\r\n      } else {\r\n        // Stall index input\r\n        work = inputSlipStall;\r\n        stallRPM = inputSlipStall;\r\n      }\r\n      \r\n      // VB6: lrat = Work / (200 * (7 / gc_ConvDia.Value) ^ 4)\r\n      const lrat = work / (200 * Math.pow(7 / converterDia, 4));\r\n      \r\n      // VB6: gc_Slippage.Value = 1.01 + lrat / 20 + Work / 8000\r\n      slippage = 1.01 + lrat / 20 + work / 8000;\r\n      \r\n      // VB6: TQMult = 2.633 - lrat ^ 0.3 - Work / 1500\r\n      torqueMult = 2.633 - Math.pow(lrat, 0.3) - work / 1500;\r\n      if (torqueMult < 1) torqueMult = 1;\r\n      if (torqueMult > 2) torqueMult = 2;\r\n    }\r\n    \r\n    // Calculate efficiency (VB6: TIMESLIP.FRM lines 760-765)\r\n    overallEfficiency = calcEfficiency(bodyStyle);\r\n    \r\n    // Get aero coefficients from body style (VB6: TIMESLIP.FRM lines 767-777)\r\n    const aero = getAeroByBodyStyle(bodyStyle);\r\n    dragCoef = aero.dragCoef;\r\n    liftCoef = aero.liftCoef;\r\n    overhangInCalc = aero.overhang_in;\r\n    \r\n    // Calculate PMI values (VB6: TIMESLIP.FRM lines 780-805)\r\n    const pmi = calcPMI(\r\n      displacement_cid,\r\n      fuelSystem,\r\n      !isClutch,\r\n      NGR,\r\n      tireDiaIn,\r\n      tireWidthIn,\r\n      bodyStyle\r\n    );\r\n    enginePMI = pmi.enginePMI;\r\n    transPMI = pmi.transPMI;\r\n    tiresPMI = pmi.tiresPMI;\r\n    \r\n  } else {\r\n    // ====================================================================\r\n    // QuarterPro Mode: Use user-provided values\r\n    // VB6: TIMESLIP.FRM lines 699-713 (#If ISQUARTERPRO branch)\r\n    // ====================================================================\r\n    \r\n    // Gear efficiencies - use from fixture/vehicle\r\n    const gearEfficiencies = drivetrain?.perGearEff ?? (vehicle as any).gearEfficiencies ?? null;\r\n    TGEff = gearEfficiencies ?? gearRatios.map(() => 0.99);\r\n    \r\n    // Per-gear shift RPMs\r\n    shiftRPMs = drivetrain?.shiftRPMs ?? drivetrain?.shiftsRPM ?? \r\n                (vehicle as any).shiftRPMs ?? gearRatios.map(() => 7000);\r\n    \r\n    // Get stall/slip RPM\r\n    const clutchSlipRPM = clutch?.slipRPM ?? (vehicle as any).clutchSlipRPM ?? 7200;\r\n    const converterStallRPM = converter?.stallRPM ?? (vehicle as any).converterStallRPM ?? 5500;\r\n    stallRPM = isClutch ? clutchSlipRPM : converterStallRPM;\r\n    \r\n    // Get slippage factor (VB6's gc_Slippage.Value)\r\n    // Note: slipRatio is NOT the same as slippageFactor - don't use it here\r\n    const clutchSlippage = clutch?.slippageFactor ?? clutch?.slippage ?? (vehicle as any).clutchSlippage ?? 1.0025;\r\n    const converterSlippage = converter?.slippageFactor ?? converter?.slippage ?? (vehicle as any).converterSlippage ?? 1.06;\r\n    slippage = isClutch ? clutchSlippage : converterSlippage;\r\n    \r\n    // Get torque multiplier\r\n    torqueMult = isClutch \r\n      ? 1.0 \r\n      : (converter?.torqueMult ?? converter?.torqueMultiplier ?? (vehicle as any).converterTorqueMult ?? 2.2);\r\n    \r\n    // PMI values from user input - check pmi object first, then flat vehicle properties\r\n    enginePMI = pmi?.engine_flywheel_clutch ?? (vehicle as any).enginePMI ?? engine?.enginePMI ?? 4.0;\r\n    tiresPMI = pmi?.tires_wheels_ringgear ?? (vehicle as any).tiresPMI ?? engine?.tiresPMI ?? 0.5;\r\n    transPMI = pmi?.transmission_driveshaft ?? (vehicle as any).transPMI ?? engine?.transPMI ?? 0.2;\r\n    \r\n    // Overall drivetrain efficiency\r\n    overallEfficiency = drivetrain?.overallEfficiency ?? (vehicle as any).transEfficiency ?? 0.97;\r\n    \r\n    // Aero coefficients from user input - check aero object first\r\n    const aero = (input as any).aero ?? (vehicle as any).aero;\r\n    dragCoef = aero?.Cd ?? aero?.cd ?? vehicle.cd ?? 0.35;\r\n    liftCoef = aero?.Cl ?? aero?.cl ?? vehicle.liftCoeff ?? 0;\r\n    overhangInCalc = overhangIn;\r\n  }\r\n  \r\n  // ========================================================================\r\n  // VB6 TIMESLIP.FRM lines 1005-1043: Calculate launch conditions\r\n  // YCG and StaticFWt are CALCULATED by VB6, not user inputs\r\n  // ========================================================================\r\n  \r\n  // VB6 TIMESLIP.FRM:1032 - YCG = (TireDia / 2) + 3.75\r\n  const YCG_in = (tireDiaIn / 2) + 3.75;\r\n  \r\n  // Calculate TireSlip at launch (VB6 TIMESLIP.FRM:872)\r\n  // TireSlip = 1.02 + (TractionIndex - 1) * 0.005 + (TrackTempEffect - 1) * 3\r\n  const trackTempF_early = env.trackTempF ?? 100;\r\n  const trackTempEffect_early = isLandSpeed ? 1 : calcTrackTempEffect(trackTempF_early);\r\n  const tractionIndex_early = env.tractionIndex ?? 5;\r\n  const tireSlipAtLaunch = 1.02 + (tractionIndex_early - 1) * 0.005 + (trackTempEffect_early - 1) * 3;\r\n  \r\n  // Constants from VB6 TIMESLIP.FRM:551-559\r\n  const FRCT = 1.03;\r\n  const CMU = 0.025;  // VB6 TIMESLIP.FRM:552\r\n  \r\n  const wheelbaseIn = vehicle.wheelbaseIn ?? 100;\r\n  const weight = vehicle.weightLb;\r\n  \r\n  // VB6 TIMESLIP.FRM:1010-1011 - Get HP at launch RPM, apply weather correction\r\n  const launchRPM_calc = isClutch \r\n    ? (clutch?.launchRPM ?? (vehicle as any).clutchLaunchRPM ?? stallRPM) \r\n    : stallRPM;\r\n  const HP_launch_calc = TABY(xrpm, yhp, NHP, 1, launchRPM_calc);\r\n  const HP_corrected = HP_launch_calc / hpc;\r\n  \r\n  // VB6 TIMESLIP.FRM:1013-1014 - Calculate torque at wheels\r\n  // TQ = Z6 * HP / RPM * TorqueMult * GearRatio * GearEff\r\n  const TQ = 5252 * HP_corrected / launchRPM_calc * torqueMult * gearRatios[0] * TGEff[0];\r\n  \r\n  // VB6 TIMESLIP.FRM:1016-1019 - Calculate DragForce at launch\r\n  // At Vel=0, wind still creates dynamic pressure\r\n  // WindFPS = Sqr(Vel^2 + 2*Vel*WindSpeed*Cos(angle) + WindSpeed^2) = WindSpeed at Vel=0\r\n  const windMph = env.windMph ?? 0;\r\n  // Note: windAngle doesn't matter at Vel=0 since the velocity term is 0\r\n  const Z5 = 0.681818; // mph to fps conversion factor (3600/5280)\r\n  const windFPS = windMph / Z5;\r\n  const q_launch = windFPS > 0 ? rho_lbm_ft3 * windFPS * windFPS / (2 * gc) : 0;\r\n  const frontalArea = (input as any).aero?.frontalArea_ft2 ?? vehicle.frontalArea_ft2 ?? (vehicle as any).frontalAreaFt2 ?? 20;\r\n  const dragForceAtLaunch = CMU * weight + dragCoef * frontalArea * q_launch;\r\n  \r\n  // VB6 TIMESLIP.FRM:1020 - Calculate force at tire\r\n  // force = TQ * FinalDrive * Efficiency / (TireSlip * TireDia / 24) - DragForce\r\n  const force = TQ * finalDrive * overallEfficiency / (tireSlipAtLaunch * tireDiaIn / 24) - dragForceAtLaunch;\r\n  \r\n  // VB6 TIMESLIP.FRM:1023-1027 - Estimate Ags0\r\n  // Clutch: 0.88 (12% losses), Converter: 0.96 (4% losses)\r\n  const launchEfficiency = isClutch ? 0.88 : 0.96;\r\n  const Ags0 = launchEfficiency * force / weight;\r\n  \r\n  // VB6 TIMESLIP.FRM:1035-1036 - Call Tire() to get TireCirFt, then TireRadIn\r\n  // At launch (Vel=0): TireGrowth = 1, TireSQ = 1 - 0.035 * Abs(Ags0)\r\n  // TireCirFt = TireSQ * TireDia * PI / 12\r\n  // TireRadIn = 12 * TireCirFt / (2 * PI) = TireSQ * TireDia / 2\r\n  const tireSQ = 1 - 0.035 * Math.abs(Ags0);\r\n  const tireRadIn = tireSQ * tireDiaIn / 2;\r\n  \r\n  // VB6 TIMESLIP.FRM:1037 - Calculate deltaFWT\r\n  // deltaFWT = (Ags0 * Weight * ((YCG - TireRadIn) + (FRCT / Efficiency) * TireRadIn) + DragForce * YCG) / Wheelbase\r\n  const deltaFWT = (Ags0 * weight * ((YCG_in - tireRadIn) + (FRCT / overallEfficiency) * tireRadIn) + dragForceAtLaunch * YCG_in) / wheelbaseIn;\r\n  \r\n  // VB6 TIMESLIP.FRM:1043 - StaticFWt = deltaFWT (since DynamicFWT = 0 at launch)\r\n  const staticFWt = deltaFWT;\r\n  \r\n  // Use calculated overhang for QuarterJr mode, user input for QuarterPro\r\n  const finalOverhang = isQuarterJr ? overhangInCalc : overhangIn;\r\n  \r\n  const vb6Vehicle: VB6VehicleParams = {\r\n    Weight_lbf: vehicle.weightLb,\r\n    Wheelbase_in: vehicle.wheelbaseIn ?? 100,\r\n    YCG_in,\r\n    StaticFWt_lbf: staticFWt,\r\n    TireDia_in: tireDiaIn,\r\n    TireWidth_in: tireWidthIn,\r\n    Rollout_in: vehicle.rolloutIn ?? 12,\r\n    \r\n    GearRatio: finalDrive,\r\n    TGR: gearRatios,\r\n    TGEff,\r\n    Efficiency: overallEfficiency,\r\n    DTShift: isClutch ? 0.2 : 0.25, // VB6 TIMESLIP.FRM:702-703, 722, 732\r\n    Slippage: slippage,\r\n    TorqueMult: torqueMult,\r\n    Stall: stallRPM,\r\n    LockUp: converter?.lockup ?? false,\r\n    isClutch,\r\n    \r\n    // Use calculated aero for QuarterJr, user input for QuarterPro\r\n    // Check aero object first (fixture format), then flat vehicle properties\r\n    RefArea_ft2: (input as any).aero?.frontalArea_ft2 ?? vehicle.frontalArea_ft2 ?? (vehicle as any).frontalAreaFt2 ?? 20,\r\n    DragCoef: dragCoef,\r\n    LiftCoef: liftCoef,\r\n    BodyStyle: bodyStyle,\r\n    \r\n    EnginePMI: enginePMI,\r\n    TiresPMI: tiresPMI,\r\n    TransPMI: transPMI,\r\n    \r\n    xrpm,\r\n    yhp,\r\n    NHP,\r\n    HPTQMult: (vehicle as any).hpTorqueMultiplier ?? engine?.hpTqMult ?? 1.0,\r\n    \r\n    ShiftRPM: shiftRPMs,\r\n    NGR,\r\n    LaunchRPM: isClutch \r\n      ? (clutch?.launchRPM ?? (vehicle as any).clutchLaunchRPM ?? stallRPM) \r\n      : stallRPM,\r\n    \r\n    // Shift by Time (alternative to shift by RPM)\r\n    ShiftMode: (vehicle as any).shiftMode ?? 'rpm',\r\n    ShiftTimes: (vehicle as any).shiftTimes ?? [],\r\n    \r\n    // Rev Limiter\r\n    RevLimiterRPM: (vehicle as any).revLimiterRPM ?? 0,\r\n  };\r\n  \r\n  // Update overhang adjustment if using QuarterJr calculated value\r\n  if (isQuarterJr && finalOverhang !== overhangIn) {\r\n    let ftdCalc = 2 * rolloutIn;\r\n    if (ftdCalc < 24) ftdCalc = 24;\r\n    ovradj = (finalOverhang + 0.25 * ftdCalc) / 12;\r\n    const minOvradjCalc = 0.5 * ftdCalc / 12;\r\n    if (ovradj < minOvradjCalc) ovradj = minOvradjCalc;\r\n  }\r\n  \r\n  // ========================================================================\r\n  // Build VB6 environment params\r\n  // ========================================================================\r\n  const trackTempF = env.trackTempF ?? 100;\r\n  // VB6: TIMESLIP.FRM:874 - Bonneville Pro forces TrackTempEffect = 1\r\n  const trackTempEffect = isLandSpeed ? 1 : calcTrackTempEffect(trackTempF);\r\n  \r\n  const vb6Env: VB6EnvParams = {\r\n    rho: rho_lbm_ft3,\r\n    hpc,\r\n    TractionIndex: env.tractionIndex ?? 5,\r\n    TrackTempEffect: trackTempEffect,\r\n    WindSpeed_mph: env.windMph ?? 0,\r\n    WindAngle_deg: env.windAngleDeg ?? 0,\r\n    isLandSpeed,  // Use Bonneville Pro constants for land speed runs\r\n  };\r\n  \r\n  // ========================================================================\r\n  // Initialize simulation\r\n  // ========================================================================\r\n  const launchRPM = isClutch \r\n    ? (clutch?.launchRPM ?? stallRPM)\r\n    : stallRPM;\r\n  \r\n  const state = vb6InitState(vb6Vehicle, vb6Env, launchRPM);\r\n  \r\n  // Calculate TSMax\r\n  // VB6 TIMESLIP.FRM:815: DistToPrint(1) = gc_Rollout.Value / 12\r\n  // VB6 TIMESLIP.FRM:1063: TSMax = DistToPrint(1) * 0.11 * (HP * gc_TorqueMult.Value / gc_Weight.Value) ^ (-1/3)\r\n  const rolloutFt_tsmax = (vehicle.rolloutIn ?? 12) / 12;\r\n  const DistToPrint1 = rolloutFt_tsmax > 0 ? rolloutFt_tsmax : 1; // VB6: If DistToPrint(1) = 0 Then DistToPrint(1) = 1\r\n  const HP_launch = TABY(xrpm, yhp, NHP, 1, launchRPM);\r\n  const TSMax = vb6CalcTSMaxInit(\r\n    DistToPrint1,\r\n    HP_launch,\r\n    torqueMult,\r\n    vehicle.weightLb\r\n  );\r\n  \r\n  \r\n  // ========================================================================\r\n  // Run simulation\r\n  // ========================================================================\r\n  // For land speed runs, allow more steps and time\r\n  const MAX_STEPS = isLandSpeed ? 50000 : 5000;\r\n  const MAX_TIME_S = isLandSpeed ? 300 : 30;  // 5 minutes for land speed\r\n  \r\n  const convergenceHistory: VB6ExactResult['vb6Diagnostics'] = {\r\n    iterations: [],\r\n    convergenceHistory: [],\r\n  };\r\n  \r\n  // Timeslip results (array format per SimResult)\r\n  const timeslip: { d_ft: number; t_s: number; v_mph: number }[] = [];\r\n  // Distance targets depend on race length (these are TRACK distances, not rear tire distances)\r\n  const distanceTargets = getDistanceTargets(raceLength);\r\n  let targetIdx = 0;\r\n  \r\n  // Track when the timer starts (when car has moved rolloutFt distance)\r\n  let timerStartTime_s: number | null = null;\r\n  \r\n  // VB6 trap speed calculation: average speed over last 66ft\r\n  // TIMESLIP.FRM:1388,1396,1619,1624 - SaveTime is set at 594ft (for 660) and 1254ft (for 1320)\r\n  // TIMESLIP.FRM:1392,1400,1621,1626 - MPH = Z5 * 66 / (time_at_finish - SaveTime)\r\n  let saveTime_594ft: number | null = null;  // Time at 594ft (66ft before 660ft)\r\n  let saveTime_1254ft: number | null = null; // Time at 1254ft (66ft before 1320ft)\r\n  \r\n  for (let step = 0; step < MAX_STEPS; step++) {\r\n    // Check termination conditions (track distance has passed finish line)\r\n    const currentTrackDist = state.Dist_ft - rolloutFt + ovradj;\r\n    if (currentTrackDist >= raceLengthFt + 50) break; // Stop shortly after finish line\r\n    if (state.time_s >= MAX_TIME_S) break;\r\n    \r\n    // Debug: Check for NaN before step\r\n    if (!Number.isFinite(state.Vel_ftps) || !Number.isFinite(state.Dist_ft) || !Number.isFinite(state.AGS_g)) {\r\n      warnings.push(`NaN detected at step ${step}: Vel=${state.Vel_ftps}, Dist=${state.Dist_ft}, AGS=${state.AGS_g}`);\r\n      break;\r\n    }\r\n    \r\n    // Run one VB6 step (pass throttle stop params for bracket racing)\r\n    const stepResult = vb6SimulationStep(state, vb6Vehicle, vb6Env, TSMax, throttleStopParams);\r\n    \r\n    // Track convergence\r\n    convergenceHistory.iterations.push(stepResult.iterations);\r\n    if (step < 20) {\r\n      convergenceHistory.convergenceHistory.push({\r\n        step,\r\n        iterations: stepResult.iterations,\r\n        HPSave: stepResult.HPSave,\r\n        HP: stepResult.HP,\r\n        PQWT: stepResult.PQWT,\r\n        AGS_g: state.AGS_g,\r\n      });\r\n    }\r\n    \r\n    // Check if timer has started (car has moved past rollout distance)\r\n    if (timerStartTime_s === null && state.Dist_ft >= rolloutFt) {\r\n      // Interpolate to find exact time when we crossed rolloutFt\r\n      // Use linear interpolation based on velocity\r\n      const distPastRollout = state.Dist_ft - rolloutFt;\r\n      const timeToReachRollout = distPastRollout / state.Vel_ftps;\r\n      timerStartTime_s = state.time_s - timeToReachRollout;\r\n    }\r\n    \r\n    // Calculate track distance (what the timer measures)\r\n    // VB6 TIMESLIP.FRM line 1381: After rollout, distance is adjusted by ovradj\r\n    // Dist(L) = Dist(L) + ovradj\r\n    // This accounts for the front overhang - the nose is ahead of where the rear tires are\r\n    // Track distance = (rear_tire_position - rollout) + ovradj\r\n    const trackDist_ft = Math.max(0, state.Dist_ft - rolloutFt + ovradj);\r\n    const trackTime_s = timerStartTime_s !== null ? state.time_s - timerStartTime_s : 0;\r\n    \r\n    // Calculate driveshaft RPM (transmission output, accounting for clutch/converter slip)\r\n    // Driveline: Engine → Clutch/Converter → Trans → Driveshaft → Final Drive → Wheels\r\n    // LockRPM is the clutch/converter output (accounts for slip)\r\n    // Driveshaft RPM = LockRPM / Trans Gear Ratio\r\n    const transGearRatio = vb6Vehicle.TGR[state.Gear - 1] ?? 1;\r\n    const driveshaftRPM = (stepResult.LockRPM ?? state.EngRPM) / transGearRatio;\r\n    \r\n    // Calculate wheel surface speed (what the tire tread is doing)\r\n    // This differs from car speed when there's tire slip\r\n    // Wheel surface speed = Vel * TireSlip (tire spins faster than car moves)\r\n    const tireSlipFactor = stepResult.TireSlip;\r\n    const wheelSpeed_mph = state.Vel_ftps * tireSlipFactor * FPS_TO_MPH;\r\n    \r\n    // Check if throttle stop is active at this time\r\n    const throttleStopActive = throttleStopParams?.enabled && \r\n      trackTime_s >= throttleStopParams.activateTime_s && \r\n      trackTime_s < (throttleStopParams.activateTime_s + throttleStopParams.duration_s);\r\n    \r\n    trace.push({\r\n      t_s: trackTime_s,\r\n      s_ft: trackDist_ft,\r\n      v_fps: state.Vel_ftps,\r\n      v_mph: state.Vel_ftps * FPS_TO_MPH,\r\n      a_g: state.AGS_g,\r\n      rpm: state.EngRPM,\r\n      dsrpm: driveshaftRPM,  // Driveshaft RPM (accounts for clutch/converter slip)\r\n      lockRpm: stepResult.LockRPM,\r\n      gear: state.Gear,\r\n      slip: state.SLIP,\r\n      tireSlip: tireSlipFactor,\r\n      // HPAtWheels is HP at the wheels (after drivetrain losses, before drag subtraction)\r\n      // HP is net HP (HPAtWheels - DragHP) - can be negative at terminal velocity\r\n      // For plotting, we want to show Engine HP and Drag HP separately\r\n      hp: stepResult.HPAtWheels,  // Engine HP at wheels (positive)\r\n      dragHp: stepResult.DragHP,  // Drag HP (positive)\r\n      netHp: stepResult.HP,       // Net HP = HPAtWheels - DragHP (can be negative)\r\n      wheelSpeed_mph,\r\n      throttleStopActive,\r\n    });\r\n    \r\n    // VB6 trap speed: capture time at 66ft before finish lines\r\n    // TIMESLIP.FRM:1388,1619 - Case 5 (594ft): SaveTime = time(L)\r\n    // TIMESLIP.FRM:1396,1624 - Case 8 (1254ft): SaveTime = time(L)\r\n    // We need to interpolate to get the exact time when crossing these distances\r\n    if (saveTime_594ft === null && trackDist_ft >= 594) {\r\n      // Interpolate to find exact time at 594ft\r\n      const prevDist = trace.length > 1 ? trace[trace.length - 2]?.s_ft ?? 0 : 0;\r\n      const prevTime = trace.length > 1 ? trace[trace.length - 2]?.t_s ?? 0 : 0;\r\n      if (prevDist < 594 && trackDist_ft > prevDist) {\r\n        const frac = (594 - prevDist) / (trackDist_ft - prevDist);\r\n        saveTime_594ft = prevTime + frac * (trackTime_s - prevTime);\r\n      } else {\r\n        saveTime_594ft = trackTime_s;\r\n      }\r\n    }\r\n    if (saveTime_1254ft === null && trackDist_ft >= 1254) {\r\n      // Interpolate to find exact time at 1254ft\r\n      const prevDist = trace.length > 1 ? trace[trace.length - 2]?.s_ft ?? 0 : 0;\r\n      const prevTime = trace.length > 1 ? trace[trace.length - 2]?.t_s ?? 0 : 0;\r\n      if (prevDist < 1254 && trackDist_ft > prevDist) {\r\n        const frac = (1254 - prevDist) / (trackDist_ft - prevDist);\r\n        saveTime_1254ft = prevTime + frac * (trackTime_s - prevTime);\r\n      } else {\r\n        saveTime_1254ft = trackTime_s;\r\n      }\r\n    }\r\n    \r\n    // Check distance targets (using track distance)\r\n    while (targetIdx < distanceTargets.length && trackDist_ft >= distanceTargets[targetIdx]) {\r\n      const target = distanceTargets[targetIdx];\r\n      \r\n      // Interpolate to find exact time at target distance\r\n      const prevDist = trace.length > 1 ? trace[trace.length - 2]?.s_ft ?? 0 : 0;\r\n      const prevTime = trace.length > 1 ? trace[trace.length - 2]?.t_s ?? 0 : 0;\r\n      let exactTime = trackTime_s;\r\n      if (prevDist < target && trackDist_ft > prevDist) {\r\n        const frac = (target - prevDist) / (trackDist_ft - prevDist);\r\n        exactTime = prevTime + frac * (trackTime_s - prevTime);\r\n      }\r\n      \r\n      // VB6 trap speed calculation: average speed over last 66ft\r\n      // TIMESLIP.FRM:1392,1621 - TIMESLIP(4) = Z5 * 66 / (TIMESLIP(3) - SaveTime) for 660ft\r\n      // TIMESLIP.FRM:1400,1626 - TIMESLIP(7) = Z5 * 66 / (TIMESLIP(6) - SaveTime) for 1320ft\r\n      let speed_mph: number;\r\n      if (target === 660 && saveTime_594ft !== null && exactTime > saveTime_594ft) {\r\n        // 8th mile trap speed: 66ft / (time@660 - time@594) * Z5\r\n        // Z5 = 3600/5280 = FPS_TO_MPH, so: 66 / dt * Z5 = 66 / dt * (3600/5280) mph\r\n        speed_mph = FPS_TO_MPH * 66 / (exactTime - saveTime_594ft);\r\n      } else if (target === 1320 && saveTime_1254ft !== null && exactTime > saveTime_1254ft) {\r\n        // 1/4 mile trap speed: 66ft / (time@1320 - time@1254) * Z5\r\n        speed_mph = FPS_TO_MPH * 66 / (exactTime - saveTime_1254ft);\r\n      } else {\r\n        // For other distances (60ft, 330ft, 1000ft), use instantaneous velocity\r\n        speed_mph = state.Vel_ftps * FPS_TO_MPH;\r\n      }\r\n      \r\n      timeslip.push({\r\n        d_ft: target,\r\n        t_s: exactTime,\r\n        v_mph: speed_mph,\r\n      });\r\n      targetIdx++;\r\n    }\r\n    \r\n    // Handle gear shifts - VB6 TIMESLIP.FRM:1355, 1433-1434\r\n    // VB6 uses ShiftFlag state machine:\r\n    // 1. Line 1355: If at shift RPM, set ShiftFlag = 1\r\n    // 2. Line 1433: If ShiftFlag = 1, set ShiftFlag = 2, increment gear, GoTo 230 (DTShift applied)\r\n    // 3. Line 1434: If ShiftFlag = 2, reset ShiftFlag = 0\r\n    if (state.ShiftFlag === 1) {\r\n      // ShiftFlag was set last step - now increment gear and apply DTShift\r\n      state.ShiftFlag = 2;\r\n      state.Gear++;\r\n      // PrevGear will differ from Gear, triggering DTShift in next step\r\n    } else if (state.ShiftFlag === 2) {\r\n      // Shift complete, reset flag\r\n      state.ShiftFlag = 0;\r\n    } else if (state.Gear < vb6Vehicle.NGR) {\r\n      // Check if we should initiate a shift\r\n      const shiftMode = vb6Vehicle.ShiftMode ?? 'rpm';\r\n      \r\n      if (shiftMode === 'time') {\r\n        // Shift by elapsed time\r\n        const shiftTime = vb6Vehicle.ShiftTimes?.[state.Gear - 1];\r\n        if (shiftTime !== undefined && state.time_s >= shiftTime) {\r\n          state.ShiftFlag = 1;\r\n        }\r\n      } else {\r\n        // Shift by RPM (default VB6 behavior)\r\n        const shiftRPM = vb6Vehicle.ShiftRPM[state.Gear - 1] ?? 7000;\r\n        \r\n        // VB6: Shift when RPM reaches or exceeds shift point\r\n        if (state.EngRPM >= shiftRPM) {\r\n          state.ShiftFlag = 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // ========================================================================\r\n  // Build result\r\n  // ========================================================================\r\n  \r\n  // Get final ET and MPH from target distance (or last point)\r\n  const finalResult = timeslip.find(t => t.d_ft === raceLengthFt);\r\n  const et_s = finalResult?.t_s ?? state.time_s;\r\n  const mph = finalResult?.v_mph ?? (state.Vel_ftps * FPS_TO_MPH);\r\n  \r\n  // Convert trace to SimResult format (include all data logger fields)\r\n  const traces = trace.map(t => ({\r\n    t_s: t.t_s,\r\n    s_ft: t.s_ft,\r\n    v_mph: t.v_mph,\r\n    v_fps: t.v_fps,\r\n    a_g: t.a_g,\r\n    rpm: t.rpm,\r\n    dsrpm: t.dsrpm,\r\n    lockRpm: t.lockRpm,\r\n    gear: t.gear,\r\n    slip: t.slip,\r\n    tireSlip: t.tireSlip,\r\n    hp: t.hp,\r\n    dragHp: t.dragHp,\r\n    wheelSpeed_mph: t.wheelSpeed_mph,\r\n  }));\r\n  \r\n  // Build debug data for UI display\r\n  const debugData = {\r\n    fuelType: {\r\n      resolved: fuelString ?? 'unknown',\r\n      fuelSystemType,\r\n      vehicleFuelType: (vehicle as any).fuelType,\r\n      vehicleFuelSystem: (vehicle as any).fuelSystem,\r\n    },\r\n    hpCurve: {\r\n      length: NHP,\r\n      peakHP: Math.max(...yhp),\r\n      rpmRange: `${Math.min(...xrpm)} - ${Math.max(...xrpm)}`,\r\n    },\r\n    airCalc: {\r\n      rho_lbm_ft3,\r\n      hpc,\r\n    },\r\n    simParams: {\r\n      weight: vehicle.weightLb,\r\n      tireDia: tireDiaIn,\r\n      wheelbase: vehicle.wheelbaseIn ?? 100,\r\n      finalDrive,\r\n      NGR,\r\n      peakHP: Math.max(...yhp),\r\n      stallRPM,\r\n      slippage,\r\n      slippageSource: clutch?.slippageFactor !== undefined ? 'clutch.slippageFactor' :\r\n                      clutch?.slippage !== undefined ? 'clutch.slippage' :\r\n                      (vehicle as any).clutchSlippage !== undefined ? 'vehicle.clutchSlippage' : 'default',\r\n      vehicleClutchSlippage: (vehicle as any).clutchSlippage,\r\n      isClutch,\r\n      tractionIndex: vb6Env.TractionIndex,\r\n      trackTempEffect,\r\n      pmi: { engine: enginePMI, trans: transPMI, tires: tiresPMI },\r\n      aero: { \r\n        frontalArea: vb6Vehicle.RefArea_ft2, \r\n        cd: vb6Vehicle.DragCoef, \r\n        cl: vb6Vehicle.LiftCoef \r\n      },\r\n      launchRPM: vb6Vehicle.LaunchRPM,\r\n      ycg: YCG_in,\r\n      staticFWt: staticFWt,\r\n      ags0: Ags0,\r\n      tireSlipAtLaunch: tireSlipAtLaunch,\r\n    },\r\n    result: {\r\n      et: et_s,\r\n      mph,\r\n    },\r\n  };\r\n  \r\n  return {\r\n    et_s,\r\n    mph,\r\n    timeslip,\r\n    traces,\r\n    meta: {\r\n      model: 'VB6Exact' as const,\r\n      steps: trace.length,\r\n      warnings,\r\n    },\r\n    vb6Diagnostics: convergenceHistory,\r\n    debugData,\r\n  };\r\n}\r\n\r\n/**\r\n * VB6 Exact Model class for compatibility with existing infrastructure\r\n */\r\nexport const VB6ExactModel = {\r\n  name: 'VB6Exact',\r\n  simulate: simulateVB6Exact,\r\n};\r\n","/**\n * Persistence layer for vehicle learning models.\n * Stores models in localStorage per vehicle ID.\n */\n\nimport type { VehicleModel } from '../domain/learning/model';\n\nconst STORAGE_KEY_PREFIX = 'rsa.model.';\n\n/**\n * Get a vehicle's learning model from localStorage.\n * \n * @param vehicleId - Vehicle identifier\n * @returns Model if exists, undefined otherwise\n */\nexport function getModel(vehicleId: string): VehicleModel | undefined {\n  try {\n    const key = STORAGE_KEY_PREFIX + vehicleId;\n    const data = localStorage.getItem(key);\n    \n    if (!data) {\n      return undefined;\n    }\n    \n    const model = JSON.parse(data) as VehicleModel;\n    \n    // Validate model structure\n    if (!model.w || !model.P || typeof model.n !== 'number') {\n      console.warn(`Invalid model structure for vehicle ${vehicleId}`);\n      return undefined;\n    }\n    \n    return model;\n  } catch (error) {\n    console.error(`Failed to load model for vehicle ${vehicleId}:`, error);\n    return undefined;\n  }\n}\n\n/**\n * Save a vehicle's learning model to localStorage.\n * \n * @param vehicleId - Vehicle identifier\n * @param model - Model to save\n */\nexport function saveModel(vehicleId: string, model: VehicleModel): void {\n  try {\n    const key = STORAGE_KEY_PREFIX + vehicleId;\n    const data = JSON.stringify(model);\n    localStorage.setItem(key, data);\n  } catch (error) {\n    console.error(`Failed to save model for vehicle ${vehicleId}:`, error);\n    throw new Error('Failed to save model');\n  }\n}\n\n/**\n * Delete a vehicle's learning model from localStorage.\n * \n * @param vehicleId - Vehicle identifier\n */\nexport function deleteModel(vehicleId: string): void {\n  try {\n    const key = STORAGE_KEY_PREFIX + vehicleId;\n    localStorage.removeItem(key);\n  } catch (error) {\n    console.error(`Failed to delete model for vehicle ${vehicleId}:`, error);\n  }\n}\n\n/**\n * List all vehicle IDs that have stored models.\n * \n * @returns Array of vehicle IDs\n */\nexport function listModels(): string[] {\n  try {\n    const vehicleIds: string[] = [];\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith(STORAGE_KEY_PREFIX)) {\n        const vehicleId = key.substring(STORAGE_KEY_PREFIX.length);\n        vehicleIds.push(vehicleId);\n      }\n    }\n    \n    return vehicleIds;\n  } catch (error) {\n    console.error('Failed to list models:', error);\n    return [];\n  }\n}\n","/**\n * Recursive Least Squares (RLS) model for adaptive ET correction.\n * Learns vehicle-specific corrections over time.\n */\n\n/**\n * Vehicle-specific learning model using RLS.\n */\nexport interface VehicleModel {\n  /** Weight vector (parameters) */\n  w: number[];\n  /** Covariance matrix */\n  P: number[][];\n  /** Number of updates */\n  n: number;\n  /** Model confidence (0-1) */\n  confidence: number;\n}\n\n/**\n * Create a new RLS model with specified dimension.\n * Initializes weights to zero and covariance to identity * 1000.\n * \n * @param dim - Dimension of feature vector\n * @returns Initialized model\n */\nexport function createModel(dim: number): VehicleModel {\n  // Initialize weights to zero\n  const w = new Array(dim).fill(0);\n  \n  // Initialize covariance matrix to I * 1000 (high initial uncertainty)\n  const P: number[][] = [];\n  for (let i = 0; i < dim; i++) {\n    P[i] = new Array(dim).fill(0);\n    P[i][i] = 1000;\n  }\n  \n  return {\n    w,\n    P,\n    n: 0,\n    confidence: 0,\n  };\n}\n\n/**\n * Apply model to feature vector to get predicted correction.\n * \n * @param m - Model\n * @param x - Feature vector\n * @returns Predicted delta_s (correction in seconds)\n */\nexport function apply(m: VehicleModel, x: number[]): number {\n  if (x.length !== m.w.length) {\n    throw new Error(`Feature dimension mismatch: expected ${m.w.length}, got ${x.length}`);\n  }\n  \n  // Compute dot product: w · x\n  let delta = 0;\n  for (let i = 0; i < m.w.length; i++) {\n    delta += m.w[i] * x[i];\n  }\n  \n  return delta;\n}\n\n/**\n * Update model with new observation using RLS algorithm.\n * Uses forgetting factor λ = 0.995 for gradual adaptation.\n * \n * @param m - Current model\n * @param x - Feature vector\n * @param y - Observed error (actual_ET - baseline_ET) in seconds\n * @returns Updated model\n */\nexport function update(m: VehicleModel, x: number[], y: number): VehicleModel {\n  if (x.length !== m.w.length) {\n    throw new Error(`Feature dimension mismatch: expected ${m.w.length}, got ${x.length}`);\n  }\n  \n  const dim = m.w.length;\n  const lambda = 0.995; // Forgetting factor\n  \n  // Copy current state\n  const w = [...m.w];\n  const P = m.P.map(row => [...row]);\n  \n  // Compute P * x\n  const Px: number[] = new Array(dim).fill(0);\n  for (let i = 0; i < dim; i++) {\n    for (let j = 0; j < dim; j++) {\n      Px[i] += P[i][j] * x[j];\n    }\n  }\n  \n  // Compute x^T * P * x\n  let xTPx = 0;\n  for (let i = 0; i < dim; i++) {\n    xTPx += x[i] * Px[i];\n  }\n  \n  // Compute gain: k = P * x / (λ + x^T * P * x)\n  const denominator = lambda + xTPx;\n  const k: number[] = Px.map(val => val / denominator);\n  \n  // Compute prediction error: e = y - w^T * x\n  let prediction = 0;\n  for (let i = 0; i < dim; i++) {\n    prediction += w[i] * x[i];\n  }\n  const error = y - prediction;\n  \n  // Update weights: w = w + k * e\n  for (let i = 0; i < dim; i++) {\n    w[i] += k[i] * error;\n  }\n  \n  // Update covariance: P = (P - k * x^T * P) / λ\n  for (let i = 0; i < dim; i++) {\n    for (let j = 0; j < dim; j++) {\n      P[i][j] = (P[i][j] - k[i] * Px[j]) / lambda;\n    }\n  }\n  \n  // Update sample count\n  const n = m.n + 1;\n  \n  // Calculate confidence based on number of samples and covariance trace\n  // Confidence increases with samples and decreases with uncertainty\n  const trace = P.reduce((sum, row, i) => sum + row[i], 0);\n  const avgVariance = trace / dim;\n  const sampleConfidence = Math.min(n / 20, 1.0); // Max at 20 samples\n  const uncertaintyFactor = Math.max(0, 1 - avgVariance / 1000); // Normalized by initial\n  const confidence = Math.min(sampleConfidence * uncertaintyFactor, 0.95);\n  \n  return {\n    w,\n    P,\n    n,\n    confidence,\n  };\n}\n","/**\n * Blend physics model implementation.\n * Combines RSACLASSIC physics with saved learning deltas (per-vehicle).\n */\n\nimport type { PhysicsModel, PhysicsModelId, SimInputs, SimResult } from '../index';\nimport { RSACLASSIC } from './rsaclassic';\nimport { getModel as getVehicleModel } from '../../../state/models';\nimport { apply } from '../../learning/model';\nimport { densityAltitudeFt } from '../../core/weather';\n\n/**\n * Blend physics model.\n * Uses RSACLASSIC as base physics, then applies learned corrections.\n */\nclass BlendModel implements PhysicsModel {\n  id: PhysicsModelId = 'Blend';\n\n  simulate(input: SimInputs): SimResult {\n    // First, run RSACLASSIC to get base physics result\n    const rsaResult = RSACLASSIC.simulate(input);\n    \n    // Try to load saved model for this vehicle\n    const vehicleId = input.vehicle.id;\n    const savedModel = getVehicleModel(vehicleId);\n    \n    let delta = 0;\n    const warnings = [...rsaResult.meta.warnings];\n    \n    if (savedModel) {\n      // Extract features manually (adapted from learning/features.ts)\n      const da = densityAltitudeFt(input.env);\n      const featureVector = [\n        da / 1000,\n        input.vehicle.weightLb / 3000,\n        input.vehicle.tireDiaIn / 30,\n        input.vehicle.rearGear / 4,\n        (rsaResult.et_s - 10) / 5,\n      ];\n      \n      // Apply learned model to get delta\n      delta = apply(savedModel, featureVector);\n    } else {\n      // No saved model found - use RSACLASSIC as-is\n      warnings.push('no_learned_model');\n    }\n    \n    // Apply delta with clamping to prevent unrealistic corrections\n    // Clamp to ±20% of RSACLASSIC result\n    const minET = rsaResult.et_s * 0.8;\n    const maxET = rsaResult.et_s * 1.2;\n    const correctedET = Math.max(minET, Math.min(maxET, rsaResult.et_s + delta));\n    \n    // Build result\n    const result: SimResult = {\n      et_s: correctedET,\n      mph: rsaResult.mph, // Keep MPH from RSACLASSIC (learning only adjusts ET)\n      timeslip: rsaResult.timeslip,\n      traces: rsaResult.traces,\n      meta: {\n        model: 'Blend',\n        steps: rsaResult.meta.steps,\n        warnings: warnings,\n      },\n    };\n    \n    return result;\n  }\n}\n\n/**\n * Blend model instance.\n */\nexport const Blend: PhysicsModel = new BlendModel();\n","/**\n * Pluggable physics engine with interchangeable models.\n * \n * Models:\n * - SimpleV1: Current baseline physics (simplified)\n * - RSACLASSIC: Advanced physics for Quarter Jr/Pro parity\n * - VB6Exact: Exact VB6 TIMESLIP.FRM replication (bit-for-bit parity)\n * - Blend: RSACLASSIC + adaptive learning\n */\n\nimport type { Vehicle } from '../schemas/vehicle.schema';\nimport type { Env } from '../schemas/env.schema';\nimport type { RaceLength } from '../config/raceLengths';\nimport { predictBaseline } from '../../worker/pipeline';\n\n/**\n * Available physics model identifiers.\n */\nexport type PhysicsModelId = 'SimpleV1' | 'RSACLASSIC' | 'VB6Exact' | 'Blend';\n\n/**\n * Extended vehicle configuration for advanced physics models.\n */\nexport interface ExtendedVehicle extends Vehicle {\n  // Physical dimensions (additional to base Vehicle)\n  wheelbaseIn?: number;\n  overhangIn?: number;\n  tireWidthIn?: number;\n  tireRolloutIn?: number;\n  \n  // Aerodynamics\n  frontalArea_ft2?: number;\n  cd?: number; // Drag coefficient\n  liftCoeff?: number; // Lift/downforce coefficient\n  \n  // Rolling resistance\n  rrCoeff?: number; // Rolling resistance coefficient\n  \n  // Drivetrain\n  finalDrive?: number; // Final drive ratio (defaults to vehicle.rearGear)\n  transEff?: number; // Transmission efficiency (0..1)\n  \n  // Transmission gearing\n  gearRatios?: number[]; // [g1, g2, ...] Including top gear, length >= 1\n  gearEff?: number[]; // Per-gear efficiency (0..1), optional\n  shiftRPM?: number[]; // Per-gear upshift RPM\n  \n  // Launch device - converter (automatic)\n  converter?: {\n    launchRPM?: number;\n    stallRPM?: number;\n    slipRatio?: number; // e.g. 1.06\n    torqueMult?: number; // e.g. 1.70\n    lockup?: boolean;\n    diameterIn?: number;\n  };\n  \n  // Launch device - clutch (manual)\n  clutch?: {\n    launchRPM?: number;\n    slipRPM?: number;\n    slipRatio?: number;\n    lockup?: boolean;\n  };\n  \n  // Polar moments of inertia (VB6 printout values)\n  pmi?: {\n    engine_flywheel_clutch?: number; // slug-ft²\n    transmission_driveshaft?: number; // slug-ft²\n    tires_wheels_ringgear?: number; // slug-ft²\n  };\n  \n  // Engine configuration\n  engine?: {\n    hpCurve?: { rpm: number; hp: number }[]; // HP-based curve (preferred)\n    fuelType?: string;\n    hpTorqueMultiplier?: number; // Applied to HP/torque calculations\n  };\n  \n  // Power (powerHP is required in base Vehicle, torqueCurve is optional extension)\n  torqueCurve?: { rpm: number; hp?: number; tq_lbft?: number }[]; // Allow hp-only rows\n}\n\n/**\n * Throttle stop configuration for bracket racing.\n * \n * A throttle stop temporarily reduces engine power to slow the car\n * and hit a specific dial-in time. Common types:\n * - Solenoid: Opens a bypass valve, reducing vacuum/boost\n * - Butterfly: Partially closes throttle blade\n * - Plate: Blocks airflow with a plate\n * \n * The stop activates at `activateTime_s` after launch and stays\n * active for `duration_s` seconds, reducing power by `throttlePct`.\n */\nexport interface ThrottleStopConfig {\n  enabled: boolean;\n  \n  // Timing (in seconds after launch/rollout)\n  activateTime_s: number;    // When stop activates (e.g., 0.5 = half second after launch)\n  duration_s: number;        // How long stop is active (e.g., 1.5 seconds)\n  \n  // Power reduction\n  throttlePct: number;       // Throttle percentage when stop is active (0-100)\n                             // 0 = idle, 50 = half throttle, 100 = full throttle (no effect)\n  \n  // Optional: RPM-based activation (alternative to time-based)\n  activateRPM?: number;      // Activate when RPM drops below this (after initial launch)\n  deactivateRPM?: number;    // Deactivate when RPM rises above this\n  \n  // Stop characteristics (for advanced modeling)\n  rampTime_s?: number;       // Time to ramp from full to reduced throttle (default: instant)\n}\n\n/**\n * Simulation inputs for physics models.\n */\nexport interface SimInputs {\n  vehicle: ExtendedVehicle;\n  env: Env;\n  raceLength: RaceLength;\n  \n  // Optional throttle stop for bracket racing\n  throttleStop?: ThrottleStopConfig;\n}\n\n/**\n * Simulation result from physics models.\n */\nexport interface SimResult {\n  // Final results\n  et_s: number;\n  mph: number;\n  \n  // Timeslip (standard splits)\n  timeslip: { d_ft: number; t_s: number; v_mph: number }[];\n  \n  // Optional detailed traces (for advanced models)\n  traces?: {\n    t_s: number;\n    v_mph: number;\n    a_g: number;\n    s_ft: number;\n    rpm: number;\n    gear: number;\n  }[];\n  \n  // Metadata\n  meta: {\n    model: PhysicsModelId;\n    steps: number;\n    warnings: string[];\n    windowMPH?: {\n      e660_mph?: number;  // Eighth mile trap (594-660 ft)\n      q1320_mph?: number; // Quarter mile trap (1254-1320 ft)\n    };\n    converter?: {\n      used: boolean;\n      avgTR: number;\n      avgETA: number;\n      avgSR: number;\n      deRateMax: number;\n      parasiticConst: number;\n      parasiticQuad: number;\n    };\n    clutch?: {\n      used: boolean;\n      minC: number;\n      lockupAt_ft?: number;\n    };\n    rollout?: {\n      rolloutIn: number;\n      t_roll_s: number;\n    };\n    fuel?: {\n      type: string;\n      minScale: number;\n      maxScale: number;\n    };\n    vb6?: {\n      dt_s: number;\n      trapMode: 'time' | 'distance';\n      windowsFt: {\n        eighth: { start: number; end: number; distance: number };\n        quarter: { start: number; end: number; distance: number };\n      };\n      timeslipPoints: number[];\n      rolloutBehavior: string;\n    };\n    termination?: {\n      reason: 'DISTANCE' | 'TIME_CAP' | 'STEP_CAP' | 'SAFETY';\n      steps: number;\n      t_s: number;\n      target_ft: number;\n    };\n  };\n}\n\n/**\n * Physics model interface.\n */\nexport interface PhysicsModel {\n  id: PhysicsModelId;\n  simulate(input: SimInputs): SimResult;\n}\n\n/**\n * SimpleV1 model - wraps existing pipeline.predictBaseline.\n */\nclass SimpleV1Model implements PhysicsModel {\n  id: PhysicsModelId = 'SimpleV1';\n\n  simulate(input: SimInputs): SimResult {\n    // Convert to pipeline format\n    const pipelineResult = predictBaseline({\n      vehicle: input.vehicle,\n      env: input.env,\n      raceLength: input.raceLength,\n    });\n\n    // Convert to SimResult format\n    return {\n      et_s: pipelineResult.baseET_s,\n      mph: pipelineResult.baseMPH,\n      timeslip: pipelineResult.timeslip,\n      meta: {\n        model: 'SimpleV1',\n        steps: pipelineResult.timeslip.length,\n        warnings: [],\n      },\n    };\n  }\n}\n\n// Import RSACLASSIC, VB6Exact, and Blend implementations\nimport { RSACLASSIC as RSACLASSICImpl } from './models/rsaclassic';\nimport { simulateVB6Exact } from './models/vb6Exact';\nimport { Blend as BlendImpl } from './models/blend';\n\n/**\n * VB6 Exact model wrapper\n */\nclass VB6ExactModel implements PhysicsModel {\n  id: PhysicsModelId = 'VB6Exact';\n  \n  simulate(input: SimInputs): SimResult {\n    const result = simulateVB6Exact(input);\n    // Ensure model ID is correct\n    return {\n      ...result,\n      meta: {\n        ...result.meta,\n        model: 'VB6Exact',\n      },\n    };\n  }\n}\n\n/**\n * Model registry.\n */\nconst models: Record<PhysicsModelId, PhysicsModel> = {\n  SimpleV1: new SimpleV1Model(),\n  RSACLASSIC: RSACLASSICImpl,\n  VB6Exact: new VB6ExactModel(),\n  Blend: BlendImpl,\n};\n\n/**\n * Get a physics model by ID.\n * \n * @param id - Model identifier\n * @returns Physics model instance\n */\nexport function getModel(id: PhysicsModelId): PhysicsModel {\n  const model = models[id];\n  if (!model) {\n    throw new Error(`Unknown physics model: ${id}`);\n  }\n  return model;\n}\n","/**\n * Web Worker for quarter-mile predictions.\n * Handles message-based communication with the main thread.\n */\n\nimport { predictBaseline } from './pipeline';\nimport type { PredictRequest } from '../domain/quarter/types';\nimport { getModel, type PhysicsModelId, type SimInputs, type SimResult } from '../domain/physics';\n\n/**\n * Power point for engine curve.\n */\ntype PowerPt = { rpm: number; hp: number };\n\n/**\n * Add field name aliases for compatibility.\n * Handles: shiftsRPM → shiftRPM, overallEfficiency → overallEff, ratios ↔ gearRatios\n */\nfunction aliasFields(input: any): any {\n  // Drivetrain aliases\n  if (input?.drivetrain) {\n    const dt = input.drivetrain;\n    \n    // shiftsRPM → shiftRPM\n    if (dt.shiftsRPM && !dt.shiftRPM) {\n      dt.shiftRPM = dt.shiftsRPM;\n    }\n    // overallEfficiency → overallEff\n    if (dt.overallEfficiency !== undefined && dt.overallEff === undefined) {\n      dt.overallEff = dt.overallEfficiency;\n    }\n    // Bidirectional: ratios ↔ gearRatios\n    if (dt.ratios && !dt.gearRatios) {\n      dt.gearRatios = dt.ratios;\n    }\n    if (dt.gearRatios && !dt.ratios) {\n      dt.ratios = dt.gearRatios;\n    }\n  }\n  \n  // Vehicle aliases (same pattern)\n  if (input?.vehicle) {\n    const v = input.vehicle;\n    if (v.ratios && !v.gearRatios) {\n      v.gearRatios = v.ratios;\n    }\n    if (v.gearRatios && !v.ratios) {\n      v.ratios = v.gearRatios;\n    }\n  }\n  \n  return input;\n}\n\n/**\n * Convert torque curve point to HP.\n * If point has hp, use it directly. If point has torque, compute hp = torque * rpm / 5252.\n */\nfunction torquePtToHP(pt: any, mult: number): PowerPt | null {\n  const rpm = Number(pt?.rpm);\n  if (!Number.isFinite(rpm)) return null;\n  \n  // If hp is present, use it directly\n  if (Number.isFinite(pt?.hp)) {\n    return { rpm, hp: Number(pt.hp) * mult };\n  }\n  // If torque is present, convert: hp = torque * rpm / 5252\n  if (Number.isFinite(pt?.torque)) {\n    const hp = (Number(pt.torque) * rpm / 5252) * mult;\n    return { rpm, hp };\n  }\n  // Also check tq_lbft alias\n  if (Number.isFinite(pt?.tq_lbft)) {\n    const hp = (Number(pt.tq_lbft) * rpm / 5252) * mult;\n    return { rpm, hp };\n  }\n  return null;\n}\n\n/**\n * Ensure engineParams.powerHP exists.\n * Converts VB6-style engineHP array, torqueCurve, or simple powerHP to modern format.\n */\nfunction ensurePowerHP(input: any): any {\n  // Already has powerHP array?\n  if (Array.isArray(input?.engineParams?.powerHP) && input.engineParams.powerHP.length >= 2) {\n    return input;\n  }\n  \n  const hpMult = input?.fuel?.hpTorqueMultiplier ?? 1;\n  let powerHP: PowerPt[] = [];\n  \n  // Try vehicle.hpCurve first (new Vehicle schema format)\n  if (Array.isArray(input?.vehicle?.hpCurve) && input.vehicle.hpCurve.length >= 2) {\n    powerHP = input.vehicle.hpCurve\n      .map((pt: any) => torquePtToHP(pt, hpMult))\n      .filter((p: PowerPt | null): p is PowerPt => p !== null && Number.isFinite(p.rpm) && Number.isFinite(p.hp))\n      .sort((a: PowerPt, b: PowerPt) => a.rpm - b.rpm);\n  }\n  \n  // Try engineHP (VB6 format)\n  if (powerHP.length < 2 && Array.isArray(input?.engineHP) && input.engineHP.length >= 2) {\n    powerHP = input.engineHP\n      .map((pt: any) => {\n        if (Array.isArray(pt)) {\n          return { rpm: Number(pt[0]), hp: Number(pt[1]) * hpMult };\n        }\n        return torquePtToHP(pt, hpMult);\n      })\n      .filter((p: PowerPt | null): p is PowerPt => p !== null && Number.isFinite(p.rpm) && Number.isFinite(p.hp))\n      .sort((a: PowerPt, b: PowerPt) => a.rpm - b.rpm);\n  }\n  \n  // Try engineParams.torqueCurve\n  if (powerHP.length < 2 && Array.isArray(input?.engineParams?.torqueCurve) && input.engineParams.torqueCurve.length >= 2) {\n    powerHP = input.engineParams.torqueCurve\n      .map((pt: any) => torquePtToHP(pt, hpMult))\n      .filter((p: PowerPt | null): p is PowerPt => p !== null && Number.isFinite(p.rpm) && Number.isFinite(p.hp))\n      .sort((a: PowerPt, b: PowerPt) => a.rpm - b.rpm);\n  }\n  \n  // Try vehicle.torqueCurve\n  if (powerHP.length < 2 && Array.isArray(input?.vehicle?.torqueCurve) && input.vehicle.torqueCurve.length >= 2) {\n    powerHP = input.vehicle.torqueCurve\n      .map((pt: any) => torquePtToHP(pt, hpMult))\n      .filter((p: PowerPt | null): p is PowerPt => p !== null && Number.isFinite(p.rpm) && Number.isFinite(p.hp))\n      .sort((a: PowerPt, b: PowerPt) => a.rpm - b.rpm);\n  }\n  \n  // Fallback: Generate synthetic curve from peak powerHP (QuarterJr mode)\n  if (powerHP.length < 2) {\n    const peakHP = Number(input?.vehicle?.powerHP);\n    if (Number.isFinite(peakHP) && peakHP > 0) {\n      // Generate a simple flat curve at peak HP (simplified model)\n      // This assumes peak HP is available across the RPM range\n      powerHP = [\n        { rpm: 4000, hp: peakHP * 0.85 * hpMult },\n        { rpm: 5000, hp: peakHP * 0.92 * hpMult },\n        { rpm: 6000, hp: peakHP * 0.97 * hpMult },\n        { rpm: 6500, hp: peakHP * 1.00 * hpMult },\n        { rpm: 7000, hp: peakHP * 0.98 * hpMult },\n        { rpm: 7500, hp: peakHP * 0.94 * hpMult },\n        { rpm: 8000, hp: peakHP * 0.88 * hpMult },\n      ];\n    }\n  }\n  \n  if (powerHP.length >= 2) {\n    input.engineParams = { ...(input.engineParams ?? {}), powerHP };\n  }\n  \n  return input;\n}\n\n/**\n * Message envelope for worker communication.\n */\ntype WorkerMessage =\n  | {\n      id: string;\n      kind: 'quarter';\n      payload: PredictRequest;\n    }\n  | {\n      id: string;\n      kind: 'physics';\n      model: PhysicsModelId;\n      payload: SimInputs;\n    };\n\n/**\n * Success response envelope.\n */\ntype WorkerSuccessResponse =\n  | {\n      id: string;\n      ok: true;\n      kind: 'quarter';\n      result: ReturnType<typeof predictBaseline>;\n    }\n  | {\n      id: string;\n      ok: true;\n      kind: 'physics';\n      result: SimResult;\n    };\n\n/**\n * Error response envelope.\n */\ninterface WorkerErrorResponse {\n  id: string;\n  ok: false;\n  error: string;\n}\n\ntype WorkerResponse = WorkerSuccessResponse | WorkerErrorResponse;\n\n/**\n * Normalize field names (aliases) and ensure powerHP exists.\n * Combines aliasFields and ensurePowerHP for complete normalization.\n */\nfunction normalizeInput(input: any): void {\n  aliasFields(input);\n  ensurePowerHP(input);\n}\n\n/**\n * Create debug hash of HP array to verify data integrity.\n */\nfunction hpDebugHash(hp?: any[]): string {\n  if (!Array.isArray(hp)) return 'none';\n  const first = hp[0]?.rpm, last = hp[hp.length - 1]?.rpm, n = hp.length;\n  return `n=${n},first=${first},last=${last}`;\n}\n\n/**\n * Handle incoming messages from the main thread.\n */\nself.onmessage = async (ev: MessageEvent) => {\n  try {\n    const msg = ev.data;\n    if (!msg?.model || !msg?.payload) throw new Error('Bad worker message');\n\n    // 1) Deep-clone to avoid structured clone surprises\n    const input = JSON.parse(JSON.stringify(msg.payload));\n\n    // VB6Exact model: Pass SimInputs directly without RSACLASSIC normalization\n    if (msg.model === 'VB6Exact') {\n      console.log('[WORKER:VB6Exact] Running with SimInputs format', {\n        hasVehicle: !!input.vehicle,\n        vehicleName: input.vehicle?.name,\n        powerHP: input.vehicle?.powerHP,\n        hasHpCurve: !!input.vehicle?.hpCurve,\n        raceLength: input.raceLength,\n      });\n      \n      const model = getModel(msg.model);\n      const result = model.simulate(input);\n      (self as any).postMessage({ ok: true, result });\n      return;\n    }\n\n    // 2) Normalize field names (aliases) and ensure powerHP exists (for RSACLASSIC/Blend)\n    normalizeInput(input);\n\n    // 3) Validate\n    const hp = input?.engineParams?.powerHP;\n    if (!Array.isArray(hp) || hp.length < 2) {\n      console.error('[WORKER] bad powerHP', { hpLen: hp?.length, sample: hp?.slice?.(0, 2) });\n      throw new Error('EngineParams must provide either torqueCurve or powerHP');\n    }\n\n    // 5) Ensure race length\n    if (!Number.isFinite(input?.raceLengthFt)) {\n      input.raceLengthFt = msg?.raceLengthFt ?? 1320;\n    }\n\n    const dt = input?.drivetrain ?? {};\n    console.log('[WORKER:normalized.input]', {\n      hasEngineParams: !!input.engineParams,\n      hasPowerHP: !!hp,\n      raceLengthFt: input.raceLengthFt,\n      hpSummary: hpDebugHash(hp),\n      hasClutch: !!dt.clutch,\n      hasConverter: !!dt.converter,\n      slipRPM: dt?.clutch?.slipRPM,\n      stallRPM: dt?.converter?.stallRPM,\n    });\n\n    // Log tuning parameters only when present (null-safe)\n    try {\n      if (input?.tuning) {\n        // eslint-disable-next-line no-console\n        console.debug('[WORKER:TUNING]', true, input.tuning);\n      }\n    } catch { /* ignore */ }\n\n    // Pipe vb6Strict flag (default true for VB6 parity)\n    if (input.flags === undefined) input.flags = {};\n    if (input.flags.vb6Strict === undefined) {\n      input.flags.vb6Strict = msg.payload?.flags?.vb6Strict ?? true;\n    }\n\n    const model = getModel(msg.model);\n    const result = model.simulate(input);\n    (self as any).postMessage({ ok: true, result });\n  } catch (e: any) {\n    console.error('[WORKER ERROR]', e);\n    (self as any).postMessage({ ok: false, error: String(e?.message || e) });\n  }\n};\n\n// Export types for use in main thread\nexport type { WorkerMessage, WorkerResponse, WorkerSuccessResponse, WorkerErrorResponse };\n"],"names":["DISTANCES","RACE_LENGTH_INFO","densityAltitudeFt","env","pressureAlt","stdTemp","tempCorrection","humidityCorrection","grainsOfWater","vaporPressure","grains","hpCorrectionV1","stdTempRankine","currentTempRankine","pressureRatio","tempRatio","correction","humidityFactor","predictBaseline","req","vehicle","raceLength","distances","corr","effectiveHP","safeHP","safeWeight","ETq","MPHq","ETe","MPHe","baseET_s","baseMPH","baseETnoWeather","weatherDelta_s","splitFractions","timeslip","d_ft","fraction","t_s","distanceFraction","v_mph","factors","lbToSlug","lb","lerp","a","b","t","ensurePowerPts","src","hp","_a","keys","power_hp_atRPM","rpm","pts","lo","hi","mid","wheelTorque_lbft","gearEff","p","baseTorque","interpolateTorqueCurve","safeRpm","curve","sorted","i","p1","p2","f32","x","F","y","vb6Round","places","v","f","frac","lerpF32","x0","x1","y0","y1","xf","x0f","x1f","y0f","y1f","tableLookupF32","table","getGearRatios","d","rpmFromSpeed","v_fps","gearIdx","slip","tireDia_ft","wheelCirc_ft","wheelRPM","ratios","gearRatio","createInitialState","PI","gc","Z6","TSTD","PSTD","BSTD","WTAIR","WTH20","RSTD","Z5","CMU","CMUK","CMU_BV","CMUK_BV","AX_BV","FRCT_BV","KP21_BV","KP22_BV","AMin","JMin","JMax","K6","K61","KP21","KP22","FRCT","AX","FPS_TO_MPH","RANKINE_OFFSET","g","computeAgs0","input","engineTorque_lbft_atSlip","transEff","drivelineEff","finalDrive","tireDia_in","tireSlip","dragForce_lbf","vehicleWeight_lbf","isAutoTrans","torqueMult","wheelRadius_ft","netThrust_lbf","airDensityVB6","air","elevation_ft","fuelSystem","cps","psdry","PWV","elevationFactor","pamb","pair","delta","WAR","RGAS","rgrs","temp_R","theta","rho","ifuel","icarb","kwar","px","tx","mech","dtx","hpc","vb6RollingResistanceForce","downForce_lbf","distance_ft","cmu","cmuk","cmu1","F_rr_constant","F_rr_speed","vb6RollingResistanceTorque","tireRadiusFt","vb6ConverterCoupling","lockRPM","stallRPM","slippage","stepCount","zStall","SlipRatio","ClutchSlip","engRPM","Work","VB6_AX","computeCRTF","params","tireWidth_in","dynamicRWT_lbf","tractionIndexAdj","bodyStyle","weightFactor","CRTF","computeAMaxVB6","weight_lbf","tireGrowth","computeAMinVB6","AMin_CONSTANT","clampAGSVB6","AGS_candidate","PQWT_candidate","AMax","AGS","PQWT","SLIP","computeCAXI","tractionIndex","trackTempEffect","computeChassisPMI","tiresPMI","transPMI","computeDSRPM","tireCircumference_ft","hpEngPMI","prevRPM","dt_s","PMI_engine_slugft2","isClutch","engAccHP","work","hpChasPMI","prevWheelRPM","PMI_chassis_slugft2","chasAccHP","computeTireGrowth","ags_ftps2","TGK","TGLinear","ags_g","tireSQ","tireCirFt","tireRadIn","dia_eff_in","radius_eff_ft","computeRefAreaWithTireGrowth","baseRefArea_ft2","isMotorcycle","totalGrowthArea_ft2","shouldShift","currentGear","numGears","shiftRPM","targetShiftRPM","shiftRPMTol","ShiftState","updateShiftState","currentState","shouldTrigger","vb6ShiftDwell_s","shouldShift_f32","maxGear","tireSlipFactor","distRatio","vb6WeightTransferToFront","AGS_g","cg_height_in","tire_radius_in","wheelbase_in","drag_force_lbf","frct","driveline_eff","accel_term","drag_term","vb6RearWeightDynamic","static_front_weight_lbf","downforce_lbf","deltaFWT","DynamicFWT","WheelBarWT","DynamicRWT","vb6StepDistance","Vel0_ftps","Dist0_ft","PQWT_ftps2","VelSqrd","Vel_ftps","term1","term2","term3","Dist_ft","vb6ApplyAccelClamp","AGS_candidate_ftps2","AMin_ftps2","AMax_ftps2","PQWT_scale","overshoot","corrected_AMAX","vb6AGSFromPQWT","vb6AdaptiveTimestep","TSMax","AgsMax_g","Ags0_g","TimeStep","vb6CalcTSMax","rollout_ft","HP","powerToWeight","getFuelSystemType","fuel","torquePtToHP","pt","mult","asPowerPtsFromTuple","arr","resolveEngineParams","sources","hpA","_b","powerHP","vb6","epTc","_c","tc","_d","_e","finite","fallback","hpAtRPM_f32","hpPts","wheelTorque_f32","tq","clampFinite","clamp01","RSACLASSICModel","__publicField","STRICT","WATCH_START_MS","WATCH_WALL_MS","WATCH_STEP_CAP","WATCH_HEARTBEAT","watchLastDist","watchdog","step","dist_ft","gained","raceLenFt","dt","drivetrain","vehicleBlock","clutch","converter","isConverter","slipRPM","launchRPM","clutchSlippage","converterSlippage","rpmPin","tuning","cdScale","effOffset","warnings","finishDistance_ft","cd","frontalArea_ft2","gearRatios","tireRolloutIn","tireDiaInRaw","tireDiaIn","rolloutIn","fuelString","fuelSystemType","rho_slug_ft3","mass_slugs","rolloutFt","terminationReason","MAX_TIME_S","traceInterval_s","peakHP","max","state","nextTraceTime","traces","lastHPSave","lastHP_wheel","lastDragHP","rolloutCompleted","t_at_rollout","timeslipPoints","nextTimeslipIdx","t_at_594","t_at_1254","prevV_fps","sumTR","sumETA","sumSR","converterSteps","minC","lockupAt_ft","minFuelScale","maxFuelScale","E_engine_total","E_drag_total","E_rr_total","E_driveline_loss","E_pmi_engine","E_pmi_chassis","E_kinetic_trans","E_kinetic_rot","prevAGS_g_stored","Ags0","launchTorque","launchHP","TQ","force","BOOT_MAX_STEPS","LOCKRPM_MIN","RPM0","DSRPM0","shiftState","shiftDwellRemaining_s","totalShiftDwell_s","getTransEff","getDrivelineEff","baseEff","getTireSlip","tireGrowthResult","tireRadius_ft","tireDia_eff_in","effectiveRPM","clutchCoupling","converterWork","converterSlipRatio","converterZStall","currentGearEff","M_fuel","trackTempF","rampProgress","LockRPM","EngRPM","inFirstGear","noLockup","deviceStallRPM","rpmIsPinned","lockThreshold","converterResult","windMph","windAngleDeg","windFps","windAngleRad","windEffectiveFps","effectiveFrontalArea_ft2","v2","q_psf","F_drag_lbf","F_lift_up_lbf","v_aero","v_f32","normal_lbf","F_drag","normalForce_lbf","T_rr","F_roll","CAXI","prevAGS_g","weightTransfer","tq_at_slip","bootTorqueMult","bootstrapResult","clamped","overallRatio","hp_at_EngRPM","HPSave","dragHP","DSRPM","enginePMI","chassisPMI","HPEngPMI","HPChasPMI","HP_afterLine1","hp_times_eff","hp_minus_pmi","hp_div_slip","HP_afterLine2","Ags0_g_local","Jerk","newAGS_g","clampResult","distance_step","gearEffLoss","overallEffLoss","totalEffLoss","v_now","dist_now","a_now","pqwt_now","stepResult","currentShiftRPM","shiftTriggered","executeShift","shiftUpdate","oldGear","oldEngRPM","dwellTime","distance","measuredTime","a_g","measuredET","finalMPH","eighthMileTrapMPH","quarterMileTrapMPH","deltaT","windowMPH","E_total_in","E_total_out","E_total_kinetic","E_balance","result","_f","_h","_g","RSACLASSIC","TABY","xrpm","yhp","NHP","_order","vb6Tire","TireDia_in","TireWidth_in","isLandSpeed","TireGrowth","TireCirFt","calcCAXI","TractionIndex","TrackTempEffect","calcAX","calcThrottleStopMultiplier","currentTime_s","throttleStop","activateTime_s","duration_s","throttlePct","rampTime_s","deactivateTime_s","targetMult","vb6SimulationStep","iGear","gearChanged","ratio","Work_time","tireResult","TireSlip","TGR_gear","ChassisPMI","Vel_L","ShiftRPM_gear","VelAtShift","EngRPM_L","throttleStopMult","WindFPS","q","RefArea2","DownForce","cmu_const","cmuk_const","frct_const","DragForce","DragHP","TireRadIn","AX_val","AMax_g","TGEff_gear","HPAtWheels","time_L","kp21_const","kp22_const","EngAccHP","ChasAccHP","k","dtk1","Jerk_iter","dtk2_time","dtk2","z","dt_final","Dist_L","avgVel","Vel0_cubed","term","vb6InitState","HP_launch","TGR_1","TGEff_1","cmu_launch","WindFPS_launch","q_launch","DragForce_launch","TireSlip_init","StaticRWT","CAXI_init","AX_init","CRTF_init","AMax_init","vb6CalcTSMaxInit","DistToPrint1_ft","TorqueMult","Weight_lbf","bisc","X","XVAL","N","JJ","KBOTM","KTOP","X1","XN","KMID","taby","XTAB","YTAB","L","YVAL","j","P","xtabj","xtabi","dtaby","ZTAB","NX","NZ","LX","LZ","ZVAL","zResult","YY","ZZ","YX","yInterp","L2","L4","calcWork","isNaturallyAspirated","SX_0","SZ_0","SY_FLAT","SX","SZ","SYS","interpolateTorqueRatio","rpmRatio","hpCidRatio","buildEngineCurve","inputs","peakRPM","displacement_cid","TQPHP","workMultiplier","HPCID","ztq","n","convertToZeroIndexed","calcBodyStyle","getAeroByBodyStyle","calcTransEfficiencies","NGR","efficiencies","teff","calcPMI","estCID","calcEfficiency","calcClutchSlippage","slipStallRPM","getRaceLengthFt","info","getDistanceTargets","extractHPCurve","engine","hpCurve","rpmAtPeakHP","calcTrackTempEffect","deviation","effect","simulateVB6Exact","trace","raceLengthFt","overhangIn","ftd","ovradj","minOvradj","pmi","throttleStopConfig","throttleStopParams","txType","rawFuel","airResult","rho_lbm_ft3","hpCurveResult","isQuarterJr","quarterJrParams","tire","tireWidthIn","TGEff","shiftRPMs","overallEfficiency","dragCoef","liftCoef","overhangInCalc","singleShiftRPM","inputSlipStall","converterDia","stq","lrat","aero","clutchSlipRPM","converterStallRPM","YCG_in","trackTempF_early","trackTempEffect_early","tireSlipAtLaunch","wheelbaseIn","weight","launchRPM_calc","windFPS","frontalArea","dragForceAtLaunch","staticFWt","finalOverhang","vb6Vehicle","ftdCalc","minOvradjCalc","vb6Env","rolloutFt_tsmax","DistToPrint1","MAX_STEPS","convergenceHistory","distanceTargets","targetIdx","timerStartTime_s","saveTime_594ft","saveTime_1254ft","timeToReachRollout","trackDist_ft","trackTime_s","transGearRatio","driveshaftRPM","wheelSpeed_mph","throttleStopActive","prevDist","prevTime","target","_i","exactTime","speed_mph","shiftTime","_j","finalResult","et_s","mph","debugData","STORAGE_KEY_PREFIX","getModel","vehicleId","key","data","model","error","apply","m","BlendModel","rsaResult","savedModel","getVehicleModel","featureVector","minET","maxET","Blend","SimpleV1Model","pipelineResult","VB6ExactModel","models","RSACLASSICImpl","BlendImpl","id","aliasFields","ensurePowerHP","hpMult","normalizeInput","hpDebugHash","first","last","ev","msg","e"],"mappings":"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"}